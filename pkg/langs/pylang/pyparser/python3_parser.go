// Code generated from Python3Parser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package pyparser // Python3Parser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Python3Parser struct {
	Python3ParserBase
}

var Python3ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func python3parserParserInit() {
	staticData := &Python3ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'",
		"'nonlocal'", "'as'", "'global'", "'assert'", "'if'", "'elif'", "'else'",
		"'while'", "'for'", "'in'", "'try'", "'None'", "'finally'", "'with'",
		"'except'", "'lambda'", "'or'", "'and'", "'not'", "'is'", "'class'",
		"'yield'", "'del'", "'pass'", "'continue'", "'break'", "'async'", "'await'",
		"'print'", "'exec'", "'True'", "'False'", "'.'", "'...'", "'`'", "'*'",
		"','", "':'", "';'", "'**'", "'='", "'|'", "'^'", "'&'", "'<<'", "'>>'",
		"'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'<'", "'>'", "'=='", "'>='",
		"'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='", "'*='", "'@='",
		"'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", "'**='", "'//='",
		"", "", "", "", "", "", "", "'('", "')'", "'{'", "'}'", "'['", "']'",
	}
	staticData.SymbolicNames = []string{
		"", "INDENT", "DEDENT", "LINE_BREAK", "DEF", "RETURN", "RAISE", "FROM",
		"IMPORT", "NONLOCAL", "AS", "GLOBAL", "ASSERT", "IF", "ELIF", "ELSE",
		"WHILE", "FOR", "IN", "TRY", "NONE", "FINALLY", "WITH", "EXCEPT", "LAMBDA",
		"OR", "AND", "NOT", "IS", "CLASS", "YIELD", "DEL", "PASS", "CONTINUE",
		"BREAK", "ASYNC", "AWAIT", "PRINT", "EXEC", "TRUE", "FALSE", "DOT",
		"ELLIPSIS", "REVERSE_QUOTE", "STAR", "COMMA", "COLON", "SEMI_COLON",
		"POWER", "ASSIGN", "OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT",
		"ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP", "LESS_THAN", "GREATER_THAN",
		"EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", "AT", "ARROW", "ADD_ASSIGN",
		"SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN",
		"POWER_ASSIGN", "IDIV_ASSIGN", "STRING", "DECIMAL_INTEGER", "OCT_INTEGER",
		"HEX_INTEGER", "BIN_INTEGER", "IMAG_NUMBER", "FLOAT_NUMBER", "OPEN_PAREN",
		"CLOSE_PAREN", "OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET",
		"NAME", "LINE_JOIN", "NEWLINE", "WS", "COMMENT",
	}
	staticData.RuleNames = []string{
		"root", "single_input", "file_input", "eval_input", "stmt", "compound_stmt",
		"suite", "decorator", "elif_clause", "else_clause", "finally_clause",
		"with_item", "except_clause", "classdef", "funcdef", "typedargslist",
		"args", "kwargs", "def_parameters", "def_parameter", "named_parameter",
		"simple_stmt", "small_stmt", "testlist_star_expr", "star_expr", "assign_part",
		"exprlist", "import_as_names", "import_as_name", "dotted_as_names",
		"dotted_as_name", "test", "varargslist", "vardef_parameters", "vardef_parameter",
		"varargs", "varkwargs", "logical_test", "comparison", "expr", "atom",
		"dictorsetmaker", "testlist_comp", "testlist", "dotted_name", "name",
		"number", "integer", "yield_expr", "yield_arg", "trailer", "arguments",
		"arglist", "argument", "subscriptlist", "subscript", "sliceop", "comp_for",
		"comp_iter",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 100, 970, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 1, 0, 1, 0, 1, 0, 3, 0, 122, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 3, 1, 131, 8, 1, 1, 2, 1, 2, 4, 2, 135, 8, 2, 11, 2,
		12, 2, 136, 1, 3, 1, 3, 5, 3, 141, 8, 3, 10, 3, 12, 3, 144, 9, 3, 1, 4,
		1, 4, 3, 4, 148, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 155, 8, 5, 10,
		5, 12, 5, 158, 9, 5, 1, 5, 3, 5, 161, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 168, 8, 5, 1, 5, 3, 5, 171, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 180, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 4, 5, 186, 8, 5, 11,
		5, 12, 5, 187, 1, 5, 3, 5, 191, 8, 5, 1, 5, 3, 5, 194, 8, 5, 1, 5, 3, 5,
		197, 8, 5, 1, 5, 3, 5, 200, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 206, 8,
		5, 10, 5, 12, 5, 209, 9, 5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 215, 8, 5, 10,
		5, 12, 5, 218, 9, 5, 1, 5, 1, 5, 3, 5, 222, 8, 5, 3, 5, 224, 8, 5, 1, 6,
		1, 6, 1, 6, 1, 6, 4, 6, 230, 8, 6, 11, 6, 12, 6, 231, 1, 6, 1, 6, 3, 6,
		236, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 242, 8, 7, 1, 7, 3, 7, 245, 8,
		7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 265, 8, 11, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 279, 8, 12, 3, 12, 281, 8, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 290, 8, 13, 1, 13, 3, 13, 293, 8, 13, 1, 13, 1,
		13, 1, 13, 1, 14, 3, 14, 299, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		305, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 310, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 15, 1, 15, 1, 15, 3, 15, 318, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 323,
		8, 15, 1, 15, 1, 15, 3, 15, 327, 8, 15, 1, 15, 3, 15, 330, 8, 15, 1, 15,
		3, 15, 333, 8, 15, 1, 15, 1, 15, 3, 15, 337, 8, 15, 3, 15, 339, 8, 15,
		1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 5, 18, 350,
		8, 18, 10, 18, 12, 18, 353, 9, 18, 1, 19, 1, 19, 1, 19, 3, 19, 358, 8,
		19, 1, 19, 3, 19, 361, 8, 19, 1, 20, 1, 20, 1, 20, 3, 20, 366, 8, 20, 1,
		21, 1, 21, 1, 21, 5, 21, 371, 8, 21, 10, 21, 12, 21, 374, 9, 21, 1, 21,
		3, 21, 377, 8, 21, 1, 21, 1, 21, 1, 22, 1, 22, 3, 22, 383, 8, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 390, 8, 22, 10, 22, 12, 22, 393, 9,
		22, 1, 22, 3, 22, 396, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 4, 22, 402, 8,
		22, 11, 22, 12, 22, 403, 1, 22, 3, 22, 407, 8, 22, 3, 22, 409, 8, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 420,
		8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 428, 8, 22, 3,
		22, 430, 8, 22, 3, 22, 432, 8, 22, 1, 22, 1, 22, 3, 22, 436, 8, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 443, 8, 22, 10, 22, 12, 22, 446,
		9, 22, 1, 22, 1, 22, 4, 22, 450, 8, 22, 11, 22, 12, 22, 451, 3, 22, 454,
		8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 463, 8,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 469, 8, 22, 10, 22, 12, 22, 472,
		9, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 481, 8,
		22, 3, 22, 483, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22,
		491, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 498, 8, 22, 10, 22,
		12, 22, 501, 9, 22, 1, 22, 1, 22, 3, 22, 505, 8, 22, 1, 23, 1, 23, 3, 23,
		509, 8, 23, 1, 23, 1, 23, 4, 23, 513, 8, 23, 11, 23, 12, 23, 514, 1, 23,
		1, 23, 3, 23, 519, 8, 23, 1, 23, 3, 23, 522, 8, 23, 1, 24, 1, 24, 1, 24,
		1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 531, 8, 25, 10, 25, 12, 25, 534, 9,
		25, 1, 25, 1, 25, 3, 25, 538, 8, 25, 1, 25, 3, 25, 541, 8, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 3, 25, 548, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 3, 25, 555, 8, 25, 3, 25, 557, 8, 25, 1, 26, 1, 26, 1, 26, 5, 26,
		562, 8, 26, 10, 26, 12, 26, 565, 9, 26, 1, 26, 3, 26, 568, 8, 26, 1, 27,
		1, 27, 1, 27, 5, 27, 573, 8, 27, 10, 27, 12, 27, 576, 9, 27, 1, 27, 3,
		27, 579, 8, 27, 1, 28, 1, 28, 1, 28, 3, 28, 584, 8, 28, 1, 29, 1, 29, 1,
		29, 5, 29, 589, 8, 29, 10, 29, 12, 29, 592, 9, 29, 1, 30, 1, 30, 1, 30,
		3, 30, 597, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 605,
		8, 31, 1, 31, 1, 31, 3, 31, 609, 8, 31, 1, 31, 1, 31, 3, 31, 613, 8, 31,
		1, 32, 1, 32, 1, 32, 3, 32, 618, 8, 32, 1, 32, 1, 32, 1, 32, 3, 32, 623,
		8, 32, 1, 32, 1, 32, 3, 32, 627, 8, 32, 1, 32, 3, 32, 630, 8, 32, 1, 32,
		3, 32, 633, 8, 32, 1, 32, 1, 32, 3, 32, 637, 8, 32, 3, 32, 639, 8, 32,
		1, 33, 1, 33, 1, 33, 5, 33, 644, 8, 33, 10, 33, 12, 33, 647, 9, 33, 1,
		34, 1, 34, 1, 34, 3, 34, 652, 8, 34, 1, 34, 3, 34, 655, 8, 34, 1, 35, 1,
		35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 667,
		8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 675, 8, 37, 10,
		37, 12, 37, 678, 9, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 692, 8, 38, 1, 38, 1, 38, 1,
		38, 3, 38, 697, 8, 38, 3, 38, 699, 8, 38, 1, 38, 5, 38, 702, 8, 38, 10,
		38, 12, 38, 705, 9, 38, 1, 39, 1, 39, 3, 39, 709, 8, 39, 1, 39, 1, 39,
		5, 39, 713, 8, 39, 10, 39, 12, 39, 716, 9, 39, 1, 39, 1, 39, 3, 39, 720,
		8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		1, 39, 5, 39, 743, 8, 39, 10, 39, 12, 39, 746, 9, 39, 1, 40, 1, 40, 1,
		40, 3, 40, 751, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 756, 8, 40, 1, 40, 1,
		40, 1, 40, 3, 40, 761, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 767, 8,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 776, 8, 40,
		1, 40, 1, 40, 1, 40, 4, 40, 781, 8, 40, 11, 40, 12, 40, 782, 3, 40, 785,
		8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 793, 8, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 802, 8, 41, 5, 41,
		804, 8, 41, 10, 41, 12, 41, 807, 9, 41, 1, 41, 3, 41, 810, 8, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 818, 8, 41, 1, 42, 1, 42, 3,
		42, 822, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 828, 8, 42, 5, 42, 830,
		8, 42, 10, 42, 12, 42, 833, 9, 42, 1, 42, 3, 42, 836, 8, 42, 3, 42, 838,
		8, 42, 1, 43, 1, 43, 1, 43, 5, 43, 843, 8, 43, 10, 43, 12, 43, 846, 9,
		43, 1, 43, 3, 43, 849, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		5, 44, 857, 8, 44, 10, 44, 12, 44, 860, 9, 44, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 46, 3, 46, 867, 8, 46, 1, 47, 1, 47, 1, 48, 1, 48, 3, 48, 873, 8,
		48, 1, 49, 1, 49, 1, 49, 3, 49, 878, 8, 49, 1, 50, 1, 50, 1, 50, 3, 50,
		883, 8, 50, 1, 50, 3, 50, 886, 8, 50, 1, 51, 1, 51, 3, 51, 890, 8, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 897, 8, 51, 1, 52, 1, 52, 1,
		52, 5, 52, 902, 8, 52, 10, 52, 12, 52, 905, 9, 52, 1, 52, 3, 52, 908, 8,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 914, 8, 53, 1, 53, 1, 53, 3, 53,
		918, 8, 53, 1, 54, 1, 54, 1, 54, 5, 54, 923, 8, 54, 10, 54, 12, 54, 926,
		9, 54, 1, 54, 3, 54, 929, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 935,
		8, 55, 1, 55, 3, 55, 938, 8, 55, 3, 55, 940, 8, 55, 1, 55, 1, 55, 3, 55,
		944, 8, 55, 1, 55, 3, 55, 947, 8, 55, 3, 55, 949, 8, 55, 1, 56, 1, 56,
		3, 56, 953, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 960, 8, 57,
		1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 966, 8, 58, 3, 58, 968, 8, 58, 1, 58,
		0, 4, 74, 76, 78, 88, 59, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 0, 10, 1, 1, 3, 3, 1,
		0, 41, 42, 1, 0, 70, 82, 2, 0, 55, 56, 60, 60, 3, 0, 44, 44, 57, 59, 68,
		68, 1, 0, 55, 56, 1, 0, 53, 54, 2, 0, 39, 40, 96, 96, 1, 0, 84, 87, 2,
		0, 44, 44, 48, 48, 1111, 0, 121, 1, 0, 0, 0, 2, 130, 1, 0, 0, 0, 4, 134,
		1, 0, 0, 0, 6, 138, 1, 0, 0, 0, 8, 147, 1, 0, 0, 0, 10, 223, 1, 0, 0, 0,
		12, 235, 1, 0, 0, 0, 14, 237, 1, 0, 0, 0, 16, 248, 1, 0, 0, 0, 18, 253,
		1, 0, 0, 0, 20, 257, 1, 0, 0, 0, 22, 261, 1, 0, 0, 0, 24, 266, 1, 0, 0,
		0, 26, 285, 1, 0, 0, 0, 28, 298, 1, 0, 0, 0, 30, 338, 1, 0, 0, 0, 32, 340,
		1, 0, 0, 0, 34, 343, 1, 0, 0, 0, 36, 346, 1, 0, 0, 0, 38, 360, 1, 0, 0,
		0, 40, 362, 1, 0, 0, 0, 42, 367, 1, 0, 0, 0, 44, 504, 1, 0, 0, 0, 46, 521,
		1, 0, 0, 0, 48, 523, 1, 0, 0, 0, 50, 556, 1, 0, 0, 0, 52, 558, 1, 0, 0,
		0, 54, 569, 1, 0, 0, 0, 56, 580, 1, 0, 0, 0, 58, 585, 1, 0, 0, 0, 60, 593,
		1, 0, 0, 0, 62, 612, 1, 0, 0, 0, 64, 638, 1, 0, 0, 0, 66, 640, 1, 0, 0,
		0, 68, 654, 1, 0, 0, 0, 70, 656, 1, 0, 0, 0, 72, 659, 1, 0, 0, 0, 74, 666,
		1, 0, 0, 0, 76, 679, 1, 0, 0, 0, 78, 719, 1, 0, 0, 0, 80, 784, 1, 0, 0,
		0, 82, 817, 1, 0, 0, 0, 84, 821, 1, 0, 0, 0, 86, 839, 1, 0, 0, 0, 88, 850,
		1, 0, 0, 0, 90, 861, 1, 0, 0, 0, 92, 866, 1, 0, 0, 0, 94, 868, 1, 0, 0,
		0, 96, 870, 1, 0, 0, 0, 98, 877, 1, 0, 0, 0, 100, 885, 1, 0, 0, 0, 102,
		896, 1, 0, 0, 0, 104, 898, 1, 0, 0, 0, 106, 917, 1, 0, 0, 0, 108, 919,
		1, 0, 0, 0, 110, 948, 1, 0, 0, 0, 112, 950, 1, 0, 0, 0, 114, 954, 1, 0,
		0, 0, 116, 967, 1, 0, 0, 0, 118, 122, 3, 2, 1, 0, 119, 122, 3, 4, 2, 0,
		120, 122, 3, 6, 3, 0, 121, 118, 1, 0, 0, 0, 121, 119, 1, 0, 0, 0, 121,
		120, 1, 0, 0, 0, 121, 122, 1, 0, 0, 0, 122, 123, 1, 0, 0, 0, 123, 124,
		5, 0, 0, 1, 124, 1, 1, 0, 0, 0, 125, 131, 5, 3, 0, 0, 126, 131, 3, 42,
		21, 0, 127, 128, 3, 10, 5, 0, 128, 129, 5, 3, 0, 0, 129, 131, 1, 0, 0,
		0, 130, 125, 1, 0, 0, 0, 130, 126, 1, 0, 0, 0, 130, 127, 1, 0, 0, 0, 131,
		3, 1, 0, 0, 0, 132, 135, 5, 3, 0, 0, 133, 135, 3, 8, 4, 0, 134, 132, 1,
		0, 0, 0, 134, 133, 1, 0, 0, 0, 135, 136, 1, 0, 0, 0, 136, 134, 1, 0, 0,
		0, 136, 137, 1, 0, 0, 0, 137, 5, 1, 0, 0, 0, 138, 142, 3, 86, 43, 0, 139,
		141, 5, 3, 0, 0, 140, 139, 1, 0, 0, 0, 141, 144, 1, 0, 0, 0, 142, 140,
		1, 0, 0, 0, 142, 143, 1, 0, 0, 0, 143, 7, 1, 0, 0, 0, 144, 142, 1, 0, 0,
		0, 145, 148, 3, 42, 21, 0, 146, 148, 3, 10, 5, 0, 147, 145, 1, 0, 0, 0,
		147, 146, 1, 0, 0, 0, 148, 9, 1, 0, 0, 0, 149, 150, 5, 13, 0, 0, 150, 151,
		3, 62, 31, 0, 151, 152, 5, 46, 0, 0, 152, 156, 3, 12, 6, 0, 153, 155, 3,
		16, 8, 0, 154, 153, 1, 0, 0, 0, 155, 158, 1, 0, 0, 0, 156, 154, 1, 0, 0,
		0, 156, 157, 1, 0, 0, 0, 157, 160, 1, 0, 0, 0, 158, 156, 1, 0, 0, 0, 159,
		161, 3, 18, 9, 0, 160, 159, 1, 0, 0, 0, 160, 161, 1, 0, 0, 0, 161, 224,
		1, 0, 0, 0, 162, 163, 5, 16, 0, 0, 163, 164, 3, 62, 31, 0, 164, 165, 5,
		46, 0, 0, 165, 167, 3, 12, 6, 0, 166, 168, 3, 18, 9, 0, 167, 166, 1, 0,
		0, 0, 167, 168, 1, 0, 0, 0, 168, 224, 1, 0, 0, 0, 169, 171, 5, 35, 0, 0,
		170, 169, 1, 0, 0, 0, 170, 171, 1, 0, 0, 0, 171, 172, 1, 0, 0, 0, 172,
		173, 5, 17, 0, 0, 173, 174, 3, 52, 26, 0, 174, 175, 5, 18, 0, 0, 175, 176,
		3, 86, 43, 0, 176, 177, 5, 46, 0, 0, 177, 179, 3, 12, 6, 0, 178, 180, 3,
		18, 9, 0, 179, 178, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180, 224, 1, 0, 0,
		0, 181, 182, 5, 19, 0, 0, 182, 183, 5, 46, 0, 0, 183, 196, 3, 12, 6, 0,
		184, 186, 3, 24, 12, 0, 185, 184, 1, 0, 0, 0, 186, 187, 1, 0, 0, 0, 187,
		185, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 190, 1, 0, 0, 0, 189, 191,
		3, 18, 9, 0, 190, 189, 1, 0, 0, 0, 190, 191, 1, 0, 0, 0, 191, 193, 1, 0,
		0, 0, 192, 194, 3, 20, 10, 0, 193, 192, 1, 0, 0, 0, 193, 194, 1, 0, 0,
		0, 194, 197, 1, 0, 0, 0, 195, 197, 3, 20, 10, 0, 196, 185, 1, 0, 0, 0,
		196, 195, 1, 0, 0, 0, 197, 224, 1, 0, 0, 0, 198, 200, 5, 35, 0, 0, 199,
		198, 1, 0, 0, 0, 199, 200, 1, 0, 0, 0, 200, 201, 1, 0, 0, 0, 201, 202,
		5, 22, 0, 0, 202, 207, 3, 22, 11, 0, 203, 204, 5, 45, 0, 0, 204, 206, 3,
		22, 11, 0, 205, 203, 1, 0, 0, 0, 206, 209, 1, 0, 0, 0, 207, 205, 1, 0,
		0, 0, 207, 208, 1, 0, 0, 0, 208, 210, 1, 0, 0, 0, 209, 207, 1, 0, 0, 0,
		210, 211, 5, 46, 0, 0, 211, 212, 3, 12, 6, 0, 212, 224, 1, 0, 0, 0, 213,
		215, 3, 14, 7, 0, 214, 213, 1, 0, 0, 0, 215, 218, 1, 0, 0, 0, 216, 214,
		1, 0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 221, 1, 0, 0, 0, 218, 216, 1, 0,
		0, 0, 219, 222, 3, 26, 13, 0, 220, 222, 3, 28, 14, 0, 221, 219, 1, 0, 0,
		0, 221, 220, 1, 0, 0, 0, 222, 224, 1, 0, 0, 0, 223, 149, 1, 0, 0, 0, 223,
		162, 1, 0, 0, 0, 223, 170, 1, 0, 0, 0, 223, 181, 1, 0, 0, 0, 223, 199,
		1, 0, 0, 0, 223, 216, 1, 0, 0, 0, 224, 11, 1, 0, 0, 0, 225, 236, 3, 42,
		21, 0, 226, 227, 5, 3, 0, 0, 227, 229, 5, 1, 0, 0, 228, 230, 3, 8, 4, 0,
		229, 228, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0, 231, 229, 1, 0, 0, 0, 231,
		232, 1, 0, 0, 0, 232, 233, 1, 0, 0, 0, 233, 234, 5, 2, 0, 0, 234, 236,
		1, 0, 0, 0, 235, 225, 1, 0, 0, 0, 235, 226, 1, 0, 0, 0, 236, 13, 1, 0,
		0, 0, 237, 238, 5, 68, 0, 0, 238, 244, 3, 88, 44, 0, 239, 241, 5, 90, 0,
		0, 240, 242, 3, 104, 52, 0, 241, 240, 1, 0, 0, 0, 241, 242, 1, 0, 0, 0,
		242, 243, 1, 0, 0, 0, 243, 245, 5, 91, 0, 0, 244, 239, 1, 0, 0, 0, 244,
		245, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246, 247, 5, 3, 0, 0, 247, 15, 1,
		0, 0, 0, 248, 249, 5, 14, 0, 0, 249, 250, 3, 62, 31, 0, 250, 251, 5, 46,
		0, 0, 251, 252, 3, 12, 6, 0, 252, 17, 1, 0, 0, 0, 253, 254, 5, 15, 0, 0,
		254, 255, 5, 46, 0, 0, 255, 256, 3, 12, 6, 0, 256, 19, 1, 0, 0, 0, 257,
		258, 5, 21, 0, 0, 258, 259, 5, 46, 0, 0, 259, 260, 3, 12, 6, 0, 260, 21,
		1, 0, 0, 0, 261, 264, 3, 62, 31, 0, 262, 263, 5, 10, 0, 0, 263, 265, 3,
		78, 39, 0, 264, 262, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265, 23, 1, 0, 0,
		0, 266, 280, 5, 23, 0, 0, 267, 278, 3, 62, 31, 0, 268, 269, 4, 12, 0, 0,
		269, 270, 5, 45, 0, 0, 270, 271, 3, 90, 45, 0, 271, 272, 6, 12, -1, 0,
		272, 279, 1, 0, 0, 0, 273, 274, 4, 12, 1, 0, 274, 275, 5, 10, 0, 0, 275,
		276, 3, 90, 45, 0, 276, 277, 6, 12, -1, 0, 277, 279, 1, 0, 0, 0, 278, 268,
		1, 0, 0, 0, 278, 273, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 281, 1, 0,
		0, 0, 280, 267, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 282, 1, 0, 0, 0,
		282, 283, 5, 46, 0, 0, 283, 284, 3, 12, 6, 0, 284, 25, 1, 0, 0, 0, 285,
		286, 5, 29, 0, 0, 286, 292, 3, 90, 45, 0, 287, 289, 5, 90, 0, 0, 288, 290,
		3, 104, 52, 0, 289, 288, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 291, 1,
		0, 0, 0, 291, 293, 5, 91, 0, 0, 292, 287, 1, 0, 0, 0, 292, 293, 1, 0, 0,
		0, 293, 294, 1, 0, 0, 0, 294, 295, 5, 46, 0, 0, 295, 296, 3, 12, 6, 0,
		296, 27, 1, 0, 0, 0, 297, 299, 5, 35, 0, 0, 298, 297, 1, 0, 0, 0, 298,
		299, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301, 5, 4, 0, 0, 301, 302,
		3, 90, 45, 0, 302, 304, 5, 90, 0, 0, 303, 305, 3, 30, 15, 0, 304, 303,
		1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 309, 5, 91,
		0, 0, 307, 308, 5, 69, 0, 0, 308, 310, 3, 62, 31, 0, 309, 307, 1, 0, 0,
		0, 309, 310, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 5, 46, 0, 0, 312,
		313, 3, 12, 6, 0, 313, 29, 1, 0, 0, 0, 314, 315, 3, 36, 18, 0, 315, 316,
		5, 45, 0, 0, 316, 318, 1, 0, 0, 0, 317, 314, 1, 0, 0, 0, 317, 318, 1, 0,
		0, 0, 318, 329, 1, 0, 0, 0, 319, 322, 3, 32, 16, 0, 320, 321, 5, 45, 0,
		0, 321, 323, 3, 36, 18, 0, 322, 320, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0,
		323, 326, 1, 0, 0, 0, 324, 325, 5, 45, 0, 0, 325, 327, 3, 34, 17, 0, 326,
		324, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 330, 1, 0, 0, 0, 328, 330,
		3, 34, 17, 0, 329, 319, 1, 0, 0, 0, 329, 328, 1, 0, 0, 0, 330, 332, 1,
		0, 0, 0, 331, 333, 5, 45, 0, 0, 332, 331, 1, 0, 0, 0, 332, 333, 1, 0, 0,
		0, 333, 339, 1, 0, 0, 0, 334, 336, 3, 36, 18, 0, 335, 337, 5, 45, 0, 0,
		336, 335, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 339, 1, 0, 0, 0, 338,
		317, 1, 0, 0, 0, 338, 334, 1, 0, 0, 0, 339, 31, 1, 0, 0, 0, 340, 341, 5,
		44, 0, 0, 341, 342, 3, 40, 20, 0, 342, 33, 1, 0, 0, 0, 343, 344, 5, 48,
		0, 0, 344, 345, 3, 40, 20, 0, 345, 35, 1, 0, 0, 0, 346, 351, 3, 38, 19,
		0, 347, 348, 5, 45, 0, 0, 348, 350, 3, 38, 19, 0, 349, 347, 1, 0, 0, 0,
		350, 353, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0, 352,
		37, 1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 354, 357, 3, 40, 20, 0, 355, 356,
		5, 49, 0, 0, 356, 358, 3, 62, 31, 0, 357, 355, 1, 0, 0, 0, 357, 358, 1,
		0, 0, 0, 358, 361, 1, 0, 0, 0, 359, 361, 5, 44, 0, 0, 360, 354, 1, 0, 0,
		0, 360, 359, 1, 0, 0, 0, 361, 39, 1, 0, 0, 0, 362, 365, 3, 90, 45, 0, 363,
		364, 5, 46, 0, 0, 364, 366, 3, 62, 31, 0, 365, 363, 1, 0, 0, 0, 365, 366,
		1, 0, 0, 0, 366, 41, 1, 0, 0, 0, 367, 372, 3, 44, 22, 0, 368, 369, 5, 47,
		0, 0, 369, 371, 3, 44, 22, 0, 370, 368, 1, 0, 0, 0, 371, 374, 1, 0, 0,
		0, 372, 370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 376, 1, 0, 0, 0, 374,
		372, 1, 0, 0, 0, 375, 377, 5, 47, 0, 0, 376, 375, 1, 0, 0, 0, 376, 377,
		1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379, 7, 0, 0, 0, 379, 43, 1, 0,
		0, 0, 380, 382, 3, 46, 23, 0, 381, 383, 3, 50, 25, 0, 382, 381, 1, 0, 0,
		0, 382, 383, 1, 0, 0, 0, 383, 505, 1, 0, 0, 0, 384, 385, 4, 22, 2, 0, 385,
		408, 5, 37, 0, 0, 386, 391, 3, 62, 31, 0, 387, 388, 5, 45, 0, 0, 388, 390,
		3, 62, 31, 0, 389, 387, 1, 0, 0, 0, 390, 393, 1, 0, 0, 0, 391, 389, 1,
		0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 395, 1, 0, 0, 0, 393, 391, 1, 0, 0,
		0, 394, 396, 5, 45, 0, 0, 395, 394, 1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396,
		409, 1, 0, 0, 0, 397, 398, 5, 54, 0, 0, 398, 401, 3, 62, 31, 0, 399, 400,
		5, 45, 0, 0, 400, 402, 3, 62, 31, 0, 401, 399, 1, 0, 0, 0, 402, 403, 1,
		0, 0, 0, 403, 401, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 406, 1, 0, 0,
		0, 405, 407, 5, 45, 0, 0, 406, 405, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407,
		409, 1, 0, 0, 0, 408, 386, 1, 0, 0, 0, 408, 397, 1, 0, 0, 0, 409, 410,
		1, 0, 0, 0, 410, 411, 6, 22, -1, 0, 411, 505, 1, 0, 0, 0, 412, 413, 5,
		31, 0, 0, 413, 505, 3, 52, 26, 0, 414, 505, 5, 32, 0, 0, 415, 505, 5, 34,
		0, 0, 416, 505, 5, 33, 0, 0, 417, 419, 5, 5, 0, 0, 418, 420, 3, 86, 43,
		0, 419, 418, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 505, 1, 0, 0, 0, 421,
		431, 5, 6, 0, 0, 422, 429, 3, 62, 31, 0, 423, 424, 5, 45, 0, 0, 424, 427,
		3, 62, 31, 0, 425, 426, 5, 45, 0, 0, 426, 428, 3, 62, 31, 0, 427, 425,
		1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 430, 1, 0, 0, 0, 429, 423, 1, 0,
		0, 0, 429, 430, 1, 0, 0, 0, 430, 432, 1, 0, 0, 0, 431, 422, 1, 0, 0, 0,
		431, 432, 1, 0, 0, 0, 432, 435, 1, 0, 0, 0, 433, 434, 5, 7, 0, 0, 434,
		436, 3, 62, 31, 0, 435, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 505,
		1, 0, 0, 0, 437, 505, 3, 96, 48, 0, 438, 439, 5, 8, 0, 0, 439, 505, 3,
		58, 29, 0, 440, 453, 5, 7, 0, 0, 441, 443, 7, 1, 0, 0, 442, 441, 1, 0,
		0, 0, 443, 446, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0,
		445, 447, 1, 0, 0, 0, 446, 444, 1, 0, 0, 0, 447, 454, 3, 88, 44, 0, 448,
		450, 7, 1, 0, 0, 449, 448, 1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 449,
		1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 454, 1, 0, 0, 0, 453, 444, 1, 0,
		0, 0, 453, 449, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 462, 5, 8, 0, 0,
		456, 463, 5, 44, 0, 0, 457, 458, 5, 90, 0, 0, 458, 459, 3, 54, 27, 0, 459,
		460, 5, 91, 0, 0, 460, 463, 1, 0, 0, 0, 461, 463, 3, 54, 27, 0, 462, 456,
		1, 0, 0, 0, 462, 457, 1, 0, 0, 0, 462, 461, 1, 0, 0, 0, 463, 505, 1, 0,
		0, 0, 464, 465, 5, 11, 0, 0, 465, 470, 3, 90, 45, 0, 466, 467, 5, 45, 0,
		0, 467, 469, 3, 90, 45, 0, 468, 466, 1, 0, 0, 0, 469, 472, 1, 0, 0, 0,
		470, 468, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 505, 1, 0, 0, 0, 472,
		470, 1, 0, 0, 0, 473, 474, 4, 22, 3, 0, 474, 475, 5, 38, 0, 0, 475, 482,
		3, 78, 39, 0, 476, 477, 5, 18, 0, 0, 477, 480, 3, 62, 31, 0, 478, 479,
		5, 45, 0, 0, 479, 481, 3, 62, 31, 0, 480, 478, 1, 0, 0, 0, 480, 481, 1,
		0, 0, 0, 481, 483, 1, 0, 0, 0, 482, 476, 1, 0, 0, 0, 482, 483, 1, 0, 0,
		0, 483, 484, 1, 0, 0, 0, 484, 485, 6, 22, -1, 0, 485, 505, 1, 0, 0, 0,
		486, 487, 5, 12, 0, 0, 487, 490, 3, 62, 31, 0, 488, 489, 5, 45, 0, 0, 489,
		491, 3, 62, 31, 0, 490, 488, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 505,
		1, 0, 0, 0, 492, 493, 4, 22, 4, 0, 493, 494, 5, 9, 0, 0, 494, 499, 3, 90,
		45, 0, 495, 496, 5, 45, 0, 0, 496, 498, 3, 90, 45, 0, 497, 495, 1, 0, 0,
		0, 498, 501, 1, 0, 0, 0, 499, 497, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500,
		502, 1, 0, 0, 0, 501, 499, 1, 0, 0, 0, 502, 503, 6, 22, -1, 0, 503, 505,
		1, 0, 0, 0, 504, 380, 1, 0, 0, 0, 504, 384, 1, 0, 0, 0, 504, 412, 1, 0,
		0, 0, 504, 414, 1, 0, 0, 0, 504, 415, 1, 0, 0, 0, 504, 416, 1, 0, 0, 0,
		504, 417, 1, 0, 0, 0, 504, 421, 1, 0, 0, 0, 504, 437, 1, 0, 0, 0, 504,
		438, 1, 0, 0, 0, 504, 440, 1, 0, 0, 0, 504, 464, 1, 0, 0, 0, 504, 473,
		1, 0, 0, 0, 504, 486, 1, 0, 0, 0, 504, 492, 1, 0, 0, 0, 505, 45, 1, 0,
		0, 0, 506, 509, 3, 62, 31, 0, 507, 509, 3, 48, 24, 0, 508, 506, 1, 0, 0,
		0, 508, 507, 1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 511, 5, 45, 0, 0, 511,
		513, 1, 0, 0, 0, 512, 508, 1, 0, 0, 0, 513, 514, 1, 0, 0, 0, 514, 512,
		1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 518, 1, 0, 0, 0, 516, 519, 3, 62,
		31, 0, 517, 519, 3, 48, 24, 0, 518, 516, 1, 0, 0, 0, 518, 517, 1, 0, 0,
		0, 518, 519, 1, 0, 0, 0, 519, 522, 1, 0, 0, 0, 520, 522, 3, 86, 43, 0,
		521, 512, 1, 0, 0, 0, 521, 520, 1, 0, 0, 0, 522, 47, 1, 0, 0, 0, 523, 524,
		5, 44, 0, 0, 524, 525, 3, 78, 39, 0, 525, 49, 1, 0, 0, 0, 526, 540, 5,
		49, 0, 0, 527, 532, 3, 46, 23, 0, 528, 529, 5, 49, 0, 0, 529, 531, 3, 46,
		23, 0, 530, 528, 1, 0, 0, 0, 531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0,
		532, 533, 1, 0, 0, 0, 533, 537, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535,
		536, 5, 49, 0, 0, 536, 538, 3, 96, 48, 0, 537, 535, 1, 0, 0, 0, 537, 538,
		1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 541, 3, 96, 48, 0, 540, 527, 1,
		0, 0, 0, 540, 539, 1, 0, 0, 0, 541, 557, 1, 0, 0, 0, 542, 543, 4, 25, 5,
		0, 543, 544, 5, 46, 0, 0, 544, 547, 3, 62, 31, 0, 545, 546, 5, 49, 0, 0,
		546, 548, 3, 86, 43, 0, 547, 545, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548,
		549, 1, 0, 0, 0, 549, 550, 6, 25, -1, 0, 550, 557, 1, 0, 0, 0, 551, 554,
		7, 2, 0, 0, 552, 555, 3, 96, 48, 0, 553, 555, 3, 86, 43, 0, 554, 552, 1,
		0, 0, 0, 554, 553, 1, 0, 0, 0, 555, 557, 1, 0, 0, 0, 556, 526, 1, 0, 0,
		0, 556, 542, 1, 0, 0, 0, 556, 551, 1, 0, 0, 0, 557, 51, 1, 0, 0, 0, 558,
		563, 3, 78, 39, 0, 559, 560, 5, 45, 0, 0, 560, 562, 3, 78, 39, 0, 561,
		559, 1, 0, 0, 0, 562, 565, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 563, 564,
		1, 0, 0, 0, 564, 567, 1, 0, 0, 0, 565, 563, 1, 0, 0, 0, 566, 568, 5, 45,
		0, 0, 567, 566, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 53, 1, 0, 0, 0,
		569, 574, 3, 56, 28, 0, 570, 571, 5, 45, 0, 0, 571, 573, 3, 56, 28, 0,
		572, 570, 1, 0, 0, 0, 573, 576, 1, 0, 0, 0, 574, 572, 1, 0, 0, 0, 574,
		575, 1, 0, 0, 0, 575, 578, 1, 0, 0, 0, 576, 574, 1, 0, 0, 0, 577, 579,
		5, 45, 0, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 55, 1, 0,
		0, 0, 580, 583, 3, 90, 45, 0, 581, 582, 5, 10, 0, 0, 582, 584, 3, 90, 45,
		0, 583, 581, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 57, 1, 0, 0, 0, 585,
		590, 3, 60, 30, 0, 586, 587, 5, 45, 0, 0, 587, 589, 3, 60, 30, 0, 588,
		586, 1, 0, 0, 0, 589, 592, 1, 0, 0, 0, 590, 588, 1, 0, 0, 0, 590, 591,
		1, 0, 0, 0, 591, 59, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0, 593, 596, 3, 88,
		44, 0, 594, 595, 5, 10, 0, 0, 595, 597, 3, 90, 45, 0, 596, 594, 1, 0, 0,
		0, 596, 597, 1, 0, 0, 0, 597, 61, 1, 0, 0, 0, 598, 604, 3, 74, 37, 0, 599,
		600, 5, 13, 0, 0, 600, 601, 3, 74, 37, 0, 601, 602, 5, 15, 0, 0, 602, 603,
		3, 62, 31, 0, 603, 605, 1, 0, 0, 0, 604, 599, 1, 0, 0, 0, 604, 605, 1,
		0, 0, 0, 605, 613, 1, 0, 0, 0, 606, 608, 5, 24, 0, 0, 607, 609, 3, 64,
		32, 0, 608, 607, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0,
		610, 611, 5, 46, 0, 0, 611, 613, 3, 62, 31, 0, 612, 598, 1, 0, 0, 0, 612,
		606, 1, 0, 0, 0, 613, 63, 1, 0, 0, 0, 614, 615, 3, 66, 33, 0, 615, 616,
		5, 45, 0, 0, 616, 618, 1, 0, 0, 0, 617, 614, 1, 0, 0, 0, 617, 618, 1, 0,
		0, 0, 618, 629, 1, 0, 0, 0, 619, 622, 3, 70, 35, 0, 620, 621, 5, 45, 0,
		0, 621, 623, 3, 66, 33, 0, 622, 620, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0,
		623, 626, 1, 0, 0, 0, 624, 625, 5, 45, 0, 0, 625, 627, 3, 72, 36, 0, 626,
		624, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628, 630,
		3, 72, 36, 0, 629, 619, 1, 0, 0, 0, 629, 628, 1, 0, 0, 0, 630, 632, 1,
		0, 0, 0, 631, 633, 5, 45, 0, 0, 632, 631, 1, 0, 0, 0, 632, 633, 1, 0, 0,
		0, 633, 639, 1, 0, 0, 0, 634, 636, 3, 66, 33, 0, 635, 637, 5, 45, 0, 0,
		636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 639, 1, 0, 0, 0, 638,
		617, 1, 0, 0, 0, 638, 634, 1, 0, 0, 0, 639, 65, 1, 0, 0, 0, 640, 645, 3,
		68, 34, 0, 641, 642, 5, 45, 0, 0, 642, 644, 3, 68, 34, 0, 643, 641, 1,
		0, 0, 0, 644, 647, 1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 645, 646, 1, 0, 0,
		0, 646, 67, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 648, 651, 3, 90, 45, 0, 649,
		650, 5, 49, 0, 0, 650, 652, 3, 62, 31, 0, 651, 649, 1, 0, 0, 0, 651, 652,
		1, 0, 0, 0, 652, 655, 1, 0, 0, 0, 653, 655, 5, 44, 0, 0, 654, 648, 1, 0,
		0, 0, 654, 653, 1, 0, 0, 0, 655, 69, 1, 0, 0, 0, 656, 657, 5, 44, 0, 0,
		657, 658, 3, 90, 45, 0, 658, 71, 1, 0, 0, 0, 659, 660, 5, 48, 0, 0, 660,
		661, 3, 90, 45, 0, 661, 73, 1, 0, 0, 0, 662, 663, 6, 37, -1, 0, 663, 667,
		3, 76, 38, 0, 664, 665, 5, 27, 0, 0, 665, 667, 3, 74, 37, 3, 666, 662,
		1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 667, 676, 1, 0, 0, 0, 668, 669, 10, 2,
		0, 0, 669, 670, 5, 26, 0, 0, 670, 675, 3, 74, 37, 3, 671, 672, 10, 1, 0,
		0, 672, 673, 5, 25, 0, 0, 673, 675, 3, 74, 37, 2, 674, 668, 1, 0, 0, 0,
		674, 671, 1, 0, 0, 0, 675, 678, 1, 0, 0, 0, 676, 674, 1, 0, 0, 0, 676,
		677, 1, 0, 0, 0, 677, 75, 1, 0, 0, 0, 678, 676, 1, 0, 0, 0, 679, 680, 6,
		38, -1, 0, 680, 681, 3, 78, 39, 0, 681, 703, 1, 0, 0, 0, 682, 698, 10,
		2, 0, 0, 683, 699, 5, 61, 0, 0, 684, 699, 5, 62, 0, 0, 685, 699, 5, 63,
		0, 0, 686, 699, 5, 64, 0, 0, 687, 699, 5, 65, 0, 0, 688, 699, 5, 66, 0,
		0, 689, 699, 5, 67, 0, 0, 690, 692, 5, 27, 0, 0, 691, 690, 1, 0, 0, 0,
		691, 692, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 699, 5, 18, 0, 0, 694,
		696, 5, 28, 0, 0, 695, 697, 5, 27, 0, 0, 696, 695, 1, 0, 0, 0, 696, 697,
		1, 0, 0, 0, 697, 699, 1, 0, 0, 0, 698, 683, 1, 0, 0, 0, 698, 684, 1, 0,
		0, 0, 698, 685, 1, 0, 0, 0, 698, 686, 1, 0, 0, 0, 698, 687, 1, 0, 0, 0,
		698, 688, 1, 0, 0, 0, 698, 689, 1, 0, 0, 0, 698, 691, 1, 0, 0, 0, 698,
		694, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 702, 3, 76, 38, 3, 701, 682,
		1, 0, 0, 0, 702, 705, 1, 0, 0, 0, 703, 701, 1, 0, 0, 0, 703, 704, 1, 0,
		0, 0, 704, 77, 1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 706, 708, 6, 39, -1, 0,
		707, 709, 5, 36, 0, 0, 708, 707, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709,
		710, 1, 0, 0, 0, 710, 714, 3, 80, 40, 0, 711, 713, 3, 100, 50, 0, 712,
		711, 1, 0, 0, 0, 713, 716, 1, 0, 0, 0, 714, 712, 1, 0, 0, 0, 714, 715,
		1, 0, 0, 0, 715, 720, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 717, 718, 7, 3,
		0, 0, 718, 720, 3, 78, 39, 7, 719, 706, 1, 0, 0, 0, 719, 717, 1, 0, 0,
		0, 720, 744, 1, 0, 0, 0, 721, 722, 10, 8, 0, 0, 722, 723, 5, 48, 0, 0,
		723, 743, 3, 78, 39, 8, 724, 725, 10, 6, 0, 0, 725, 726, 7, 4, 0, 0, 726,
		743, 3, 78, 39, 7, 727, 728, 10, 5, 0, 0, 728, 729, 7, 5, 0, 0, 729, 743,
		3, 78, 39, 6, 730, 731, 10, 4, 0, 0, 731, 732, 7, 6, 0, 0, 732, 743, 3,
		78, 39, 5, 733, 734, 10, 3, 0, 0, 734, 735, 5, 52, 0, 0, 735, 743, 3, 78,
		39, 4, 736, 737, 10, 2, 0, 0, 737, 738, 5, 51, 0, 0, 738, 743, 3, 78, 39,
		3, 739, 740, 10, 1, 0, 0, 740, 741, 5, 50, 0, 0, 741, 743, 3, 78, 39, 2,
		742, 721, 1, 0, 0, 0, 742, 724, 1, 0, 0, 0, 742, 727, 1, 0, 0, 0, 742,
		730, 1, 0, 0, 0, 742, 733, 1, 0, 0, 0, 742, 736, 1, 0, 0, 0, 742, 739,
		1, 0, 0, 0, 743, 746, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 745, 1, 0,
		0, 0, 745, 79, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 747, 750, 5, 90, 0, 0,
		748, 751, 3, 96, 48, 0, 749, 751, 3, 84, 42, 0, 750, 748, 1, 0, 0, 0, 750,
		749, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 785,
		5, 91, 0, 0, 753, 755, 5, 94, 0, 0, 754, 756, 3, 84, 42, 0, 755, 754, 1,
		0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 785, 5, 95, 0,
		0, 758, 760, 5, 92, 0, 0, 759, 761, 3, 82, 41, 0, 760, 759, 1, 0, 0, 0,
		760, 761, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 785, 5, 93, 0, 0, 763,
		764, 5, 43, 0, 0, 764, 766, 3, 86, 43, 0, 765, 767, 5, 45, 0, 0, 766, 765,
		1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 769, 5, 43,
		0, 0, 769, 785, 1, 0, 0, 0, 770, 785, 5, 42, 0, 0, 771, 785, 3, 90, 45,
		0, 772, 785, 5, 37, 0, 0, 773, 785, 5, 38, 0, 0, 774, 776, 5, 56, 0, 0,
		775, 774, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777,
		785, 3, 92, 46, 0, 778, 785, 5, 20, 0, 0, 779, 781, 5, 83, 0, 0, 780, 779,
		1, 0, 0, 0, 781, 782, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 782, 783, 1, 0,
		0, 0, 783, 785, 1, 0, 0, 0, 784, 747, 1, 0, 0, 0, 784, 753, 1, 0, 0, 0,
		784, 758, 1, 0, 0, 0, 784, 763, 1, 0, 0, 0, 784, 770, 1, 0, 0, 0, 784,
		771, 1, 0, 0, 0, 784, 772, 1, 0, 0, 0, 784, 773, 1, 0, 0, 0, 784, 775,
		1, 0, 0, 0, 784, 778, 1, 0, 0, 0, 784, 780, 1, 0, 0, 0, 785, 81, 1, 0,
		0, 0, 786, 787, 3, 62, 31, 0, 787, 788, 5, 46, 0, 0, 788, 789, 3, 62, 31,
		0, 789, 793, 1, 0, 0, 0, 790, 791, 5, 48, 0, 0, 791, 793, 3, 78, 39, 0,
		792, 786, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 793, 805, 1, 0, 0, 0, 794,
		801, 5, 45, 0, 0, 795, 796, 3, 62, 31, 0, 796, 797, 5, 46, 0, 0, 797, 798,
		3, 62, 31, 0, 798, 802, 1, 0, 0, 0, 799, 800, 5, 48, 0, 0, 800, 802, 3,
		78, 39, 0, 801, 795, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 802, 804, 1, 0,
		0, 0, 803, 794, 1, 0, 0, 0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0,
		805, 806, 1, 0, 0, 0, 806, 809, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808,
		810, 5, 45, 0, 0, 809, 808, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 818,
		1, 0, 0, 0, 811, 812, 3, 62, 31, 0, 812, 813, 5, 46, 0, 0, 813, 814, 3,
		62, 31, 0, 814, 815, 3, 114, 57, 0, 815, 818, 1, 0, 0, 0, 816, 818, 3,
		84, 42, 0, 817, 792, 1, 0, 0, 0, 817, 811, 1, 0, 0, 0, 817, 816, 1, 0,
		0, 0, 818, 83, 1, 0, 0, 0, 819, 822, 3, 62, 31, 0, 820, 822, 3, 48, 24,
		0, 821, 819, 1, 0, 0, 0, 821, 820, 1, 0, 0, 0, 822, 837, 1, 0, 0, 0, 823,
		838, 3, 114, 57, 0, 824, 827, 5, 45, 0, 0, 825, 828, 3, 62, 31, 0, 826,
		828, 3, 48, 24, 0, 827, 825, 1, 0, 0, 0, 827, 826, 1, 0, 0, 0, 828, 830,
		1, 0, 0, 0, 829, 824, 1, 0, 0, 0, 830, 833, 1, 0, 0, 0, 831, 829, 1, 0,
		0, 0, 831, 832, 1, 0, 0, 0, 832, 835, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0,
		834, 836, 5, 45, 0, 0, 835, 834, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836,
		838, 1, 0, 0, 0, 837, 823, 1, 0, 0, 0, 837, 831, 1, 0, 0, 0, 838, 85, 1,
		0, 0, 0, 839, 844, 3, 62, 31, 0, 840, 841, 5, 45, 0, 0, 841, 843, 3, 62,
		31, 0, 842, 840, 1, 0, 0, 0, 843, 846, 1, 0, 0, 0, 844, 842, 1, 0, 0, 0,
		844, 845, 1, 0, 0, 0, 845, 848, 1, 0, 0, 0, 846, 844, 1, 0, 0, 0, 847,
		849, 5, 45, 0, 0, 848, 847, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 87,
		1, 0, 0, 0, 850, 851, 6, 44, -1, 0, 851, 852, 3, 90, 45, 0, 852, 858, 1,
		0, 0, 0, 853, 854, 10, 2, 0, 0, 854, 855, 5, 41, 0, 0, 855, 857, 3, 90,
		45, 0, 856, 853, 1, 0, 0, 0, 857, 860, 1, 0, 0, 0, 858, 856, 1, 0, 0, 0,
		858, 859, 1, 0, 0, 0, 859, 89, 1, 0, 0, 0, 860, 858, 1, 0, 0, 0, 861, 862,
		7, 7, 0, 0, 862, 91, 1, 0, 0, 0, 863, 867, 3, 94, 47, 0, 864, 867, 5, 88,
		0, 0, 865, 867, 5, 89, 0, 0, 866, 863, 1, 0, 0, 0, 866, 864, 1, 0, 0, 0,
		866, 865, 1, 0, 0, 0, 867, 93, 1, 0, 0, 0, 868, 869, 7, 8, 0, 0, 869, 95,
		1, 0, 0, 0, 870, 872, 5, 30, 0, 0, 871, 873, 3, 98, 49, 0, 872, 871, 1,
		0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 97, 1, 0, 0, 0, 874, 875, 5, 7, 0,
		0, 875, 878, 3, 62, 31, 0, 876, 878, 3, 86, 43, 0, 877, 874, 1, 0, 0, 0,
		877, 876, 1, 0, 0, 0, 878, 99, 1, 0, 0, 0, 879, 880, 5, 41, 0, 0, 880,
		882, 3, 90, 45, 0, 881, 883, 3, 102, 51, 0, 882, 881, 1, 0, 0, 0, 882,
		883, 1, 0, 0, 0, 883, 886, 1, 0, 0, 0, 884, 886, 3, 102, 51, 0, 885, 879,
		1, 0, 0, 0, 885, 884, 1, 0, 0, 0, 886, 101, 1, 0, 0, 0, 887, 889, 5, 90,
		0, 0, 888, 890, 3, 104, 52, 0, 889, 888, 1, 0, 0, 0, 889, 890, 1, 0, 0,
		0, 890, 891, 1, 0, 0, 0, 891, 897, 5, 91, 0, 0, 892, 893, 5, 94, 0, 0,
		893, 894, 3, 108, 54, 0, 894, 895, 5, 95, 0, 0, 895, 897, 1, 0, 0, 0, 896,
		887, 1, 0, 0, 0, 896, 892, 1, 0, 0, 0, 897, 103, 1, 0, 0, 0, 898, 903,
		3, 106, 53, 0, 899, 900, 5, 45, 0, 0, 900, 902, 3, 106, 53, 0, 901, 899,
		1, 0, 0, 0, 902, 905, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 903, 904, 1, 0,
		0, 0, 904, 907, 1, 0, 0, 0, 905, 903, 1, 0, 0, 0, 906, 908, 5, 45, 0, 0,
		907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 105, 1, 0, 0, 0, 909,
		913, 3, 62, 31, 0, 910, 914, 3, 114, 57, 0, 911, 912, 5, 49, 0, 0, 912,
		914, 3, 62, 31, 0, 913, 910, 1, 0, 0, 0, 913, 911, 1, 0, 0, 0, 913, 914,
		1, 0, 0, 0, 914, 918, 1, 0, 0, 0, 915, 916, 7, 9, 0, 0, 916, 918, 3, 62,
		31, 0, 917, 909, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 918, 107, 1, 0, 0, 0,
		919, 924, 3, 110, 55, 0, 920, 921, 5, 45, 0, 0, 921, 923, 3, 110, 55, 0,
		922, 920, 1, 0, 0, 0, 923, 926, 1, 0, 0, 0, 924, 922, 1, 0, 0, 0, 924,
		925, 1, 0, 0, 0, 925, 928, 1, 0, 0, 0, 926, 924, 1, 0, 0, 0, 927, 929,
		5, 45, 0, 0, 928, 927, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 109, 1, 0,
		0, 0, 930, 949, 5, 42, 0, 0, 931, 939, 3, 62, 31, 0, 932, 934, 5, 46, 0,
		0, 933, 935, 3, 62, 31, 0, 934, 933, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0,
		935, 937, 1, 0, 0, 0, 936, 938, 3, 112, 56, 0, 937, 936, 1, 0, 0, 0, 937,
		938, 1, 0, 0, 0, 938, 940, 1, 0, 0, 0, 939, 932, 1, 0, 0, 0, 939, 940,
		1, 0, 0, 0, 940, 949, 1, 0, 0, 0, 941, 943, 5, 46, 0, 0, 942, 944, 3, 62,
		31, 0, 943, 942, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 946, 1, 0, 0, 0,
		945, 947, 3, 112, 56, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947,
		949, 1, 0, 0, 0, 948, 930, 1, 0, 0, 0, 948, 931, 1, 0, 0, 0, 948, 941,
		1, 0, 0, 0, 949, 111, 1, 0, 0, 0, 950, 952, 5, 46, 0, 0, 951, 953, 3, 62,
		31, 0, 952, 951, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 113, 1, 0, 0, 0,
		954, 955, 5, 17, 0, 0, 955, 956, 3, 52, 26, 0, 956, 957, 5, 18, 0, 0, 957,
		959, 3, 74, 37, 0, 958, 960, 3, 116, 58, 0, 959, 958, 1, 0, 0, 0, 959,
		960, 1, 0, 0, 0, 960, 115, 1, 0, 0, 0, 961, 968, 3, 114, 57, 0, 962, 963,
		5, 13, 0, 0, 963, 965, 3, 62, 31, 0, 964, 966, 3, 116, 58, 0, 965, 964,
		1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968, 1, 0, 0, 0, 967, 961, 1, 0,
		0, 0, 967, 962, 1, 0, 0, 0, 968, 117, 1, 0, 0, 0, 151, 121, 130, 134, 136,
		142, 147, 156, 160, 167, 170, 179, 187, 190, 193, 196, 199, 207, 216, 221,
		223, 231, 235, 241, 244, 264, 278, 280, 289, 292, 298, 304, 309, 317, 322,
		326, 329, 332, 336, 338, 351, 357, 360, 365, 372, 376, 382, 391, 395, 403,
		406, 408, 419, 427, 429, 431, 435, 444, 451, 453, 462, 470, 480, 482, 490,
		499, 504, 508, 514, 518, 521, 532, 537, 540, 547, 554, 556, 563, 567, 574,
		578, 583, 590, 596, 604, 608, 612, 617, 622, 626, 629, 632, 636, 638, 645,
		651, 654, 666, 674, 676, 691, 696, 698, 703, 708, 714, 719, 742, 744, 750,
		755, 760, 766, 775, 782, 784, 792, 801, 805, 809, 817, 821, 827, 831, 835,
		837, 844, 848, 858, 866, 872, 877, 882, 885, 889, 896, 903, 907, 913, 917,
		924, 928, 934, 937, 939, 943, 946, 948, 952, 959, 965, 967,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Python3ParserInit initializes any static state used to implement Python3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPython3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Python3ParserInit() {
	staticData := &Python3ParserParserStaticData
	staticData.once.Do(python3parserParserInit)
}

// NewPython3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewPython3Parser(input antlr.TokenStream) *Python3Parser {
	Python3ParserInit()
	this := new(Python3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Python3ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Python3Parser.g4"

	return this
}

// Python3Parser tokens.
const (
	Python3ParserEOF                = antlr.TokenEOF
	Python3ParserINDENT             = 1
	Python3ParserDEDENT             = 2
	Python3ParserLINE_BREAK         = 3
	Python3ParserDEF                = 4
	Python3ParserRETURN             = 5
	Python3ParserRAISE              = 6
	Python3ParserFROM               = 7
	Python3ParserIMPORT             = 8
	Python3ParserNONLOCAL           = 9
	Python3ParserAS                 = 10
	Python3ParserGLOBAL             = 11
	Python3ParserASSERT             = 12
	Python3ParserIF                 = 13
	Python3ParserELIF               = 14
	Python3ParserELSE               = 15
	Python3ParserWHILE              = 16
	Python3ParserFOR                = 17
	Python3ParserIN                 = 18
	Python3ParserTRY                = 19
	Python3ParserNONE               = 20
	Python3ParserFINALLY            = 21
	Python3ParserWITH               = 22
	Python3ParserEXCEPT             = 23
	Python3ParserLAMBDA             = 24
	Python3ParserOR                 = 25
	Python3ParserAND                = 26
	Python3ParserNOT                = 27
	Python3ParserIS                 = 28
	Python3ParserCLASS              = 29
	Python3ParserYIELD              = 30
	Python3ParserDEL                = 31
	Python3ParserPASS               = 32
	Python3ParserCONTINUE           = 33
	Python3ParserBREAK              = 34
	Python3ParserASYNC              = 35
	Python3ParserAWAIT              = 36
	Python3ParserPRINT              = 37
	Python3ParserEXEC               = 38
	Python3ParserTRUE               = 39
	Python3ParserFALSE              = 40
	Python3ParserDOT                = 41
	Python3ParserELLIPSIS           = 42
	Python3ParserREVERSE_QUOTE      = 43
	Python3ParserSTAR               = 44
	Python3ParserCOMMA              = 45
	Python3ParserCOLON              = 46
	Python3ParserSEMI_COLON         = 47
	Python3ParserPOWER              = 48
	Python3ParserASSIGN             = 49
	Python3ParserOR_OP              = 50
	Python3ParserXOR                = 51
	Python3ParserAND_OP             = 52
	Python3ParserLEFT_SHIFT         = 53
	Python3ParserRIGHT_SHIFT        = 54
	Python3ParserADD                = 55
	Python3ParserMINUS              = 56
	Python3ParserDIV                = 57
	Python3ParserMOD                = 58
	Python3ParserIDIV               = 59
	Python3ParserNOT_OP             = 60
	Python3ParserLESS_THAN          = 61
	Python3ParserGREATER_THAN       = 62
	Python3ParserEQUALS             = 63
	Python3ParserGT_EQ              = 64
	Python3ParserLT_EQ              = 65
	Python3ParserNOT_EQ_1           = 66
	Python3ParserNOT_EQ_2           = 67
	Python3ParserAT                 = 68
	Python3ParserARROW              = 69
	Python3ParserADD_ASSIGN         = 70
	Python3ParserSUB_ASSIGN         = 71
	Python3ParserMULT_ASSIGN        = 72
	Python3ParserAT_ASSIGN          = 73
	Python3ParserDIV_ASSIGN         = 74
	Python3ParserMOD_ASSIGN         = 75
	Python3ParserAND_ASSIGN         = 76
	Python3ParserOR_ASSIGN          = 77
	Python3ParserXOR_ASSIGN         = 78
	Python3ParserLEFT_SHIFT_ASSIGN  = 79
	Python3ParserRIGHT_SHIFT_ASSIGN = 80
	Python3ParserPOWER_ASSIGN       = 81
	Python3ParserIDIV_ASSIGN        = 82
	Python3ParserSTRING             = 83
	Python3ParserDECIMAL_INTEGER    = 84
	Python3ParserOCT_INTEGER        = 85
	Python3ParserHEX_INTEGER        = 86
	Python3ParserBIN_INTEGER        = 87
	Python3ParserIMAG_NUMBER        = 88
	Python3ParserFLOAT_NUMBER       = 89
	Python3ParserOPEN_PAREN         = 90
	Python3ParserCLOSE_PAREN        = 91
	Python3ParserOPEN_BRACE         = 92
	Python3ParserCLOSE_BRACE        = 93
	Python3ParserOPEN_BRACKET       = 94
	Python3ParserCLOSE_BRACKET      = 95
	Python3ParserNAME               = 96
	Python3ParserLINE_JOIN          = 97
	Python3ParserNEWLINE            = 98
	Python3ParserWS                 = 99
	Python3ParserCOMMENT            = 100
)

// Python3Parser rules.
const (
	Python3ParserRULE_root               = 0
	Python3ParserRULE_single_input       = 1
	Python3ParserRULE_file_input         = 2
	Python3ParserRULE_eval_input         = 3
	Python3ParserRULE_stmt               = 4
	Python3ParserRULE_compound_stmt      = 5
	Python3ParserRULE_suite              = 6
	Python3ParserRULE_decorator          = 7
	Python3ParserRULE_elif_clause        = 8
	Python3ParserRULE_else_clause        = 9
	Python3ParserRULE_finally_clause     = 10
	Python3ParserRULE_with_item          = 11
	Python3ParserRULE_except_clause      = 12
	Python3ParserRULE_classdef           = 13
	Python3ParserRULE_funcdef            = 14
	Python3ParserRULE_typedargslist      = 15
	Python3ParserRULE_args               = 16
	Python3ParserRULE_kwargs             = 17
	Python3ParserRULE_def_parameters     = 18
	Python3ParserRULE_def_parameter      = 19
	Python3ParserRULE_named_parameter    = 20
	Python3ParserRULE_simple_stmt        = 21
	Python3ParserRULE_small_stmt         = 22
	Python3ParserRULE_testlist_star_expr = 23
	Python3ParserRULE_star_expr          = 24
	Python3ParserRULE_assign_part        = 25
	Python3ParserRULE_exprlist           = 26
	Python3ParserRULE_import_as_names    = 27
	Python3ParserRULE_import_as_name     = 28
	Python3ParserRULE_dotted_as_names    = 29
	Python3ParserRULE_dotted_as_name     = 30
	Python3ParserRULE_test               = 31
	Python3ParserRULE_varargslist        = 32
	Python3ParserRULE_vardef_parameters  = 33
	Python3ParserRULE_vardef_parameter   = 34
	Python3ParserRULE_varargs            = 35
	Python3ParserRULE_varkwargs          = 36
	Python3ParserRULE_logical_test       = 37
	Python3ParserRULE_comparison         = 38
	Python3ParserRULE_expr               = 39
	Python3ParserRULE_atom               = 40
	Python3ParserRULE_dictorsetmaker     = 41
	Python3ParserRULE_testlist_comp      = 42
	Python3ParserRULE_testlist           = 43
	Python3ParserRULE_dotted_name        = 44
	Python3ParserRULE_name               = 45
	Python3ParserRULE_number             = 46
	Python3ParserRULE_integer            = 47
	Python3ParserRULE_yield_expr         = 48
	Python3ParserRULE_yield_arg          = 49
	Python3ParserRULE_trailer            = 50
	Python3ParserRULE_arguments          = 51
	Python3ParserRULE_arglist            = 52
	Python3ParserRULE_argument           = 53
	Python3ParserRULE_subscriptlist      = 54
	Python3ParserRULE_subscript          = 55
	Python3ParserRULE_sliceop            = 56
	Python3ParserRULE_comp_for           = 57
	Python3ParserRULE_comp_iter          = 58
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Single_input() ISingle_inputContext
	File_input() IFile_inputContext
	Eval_input() IEval_inputContext

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *RootContext) Single_input() ISingle_inputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_inputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_inputContext)
}

func (s *RootContext) File_input() IFile_inputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_inputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_inputContext)
}

func (s *RootContext) Eval_input() IEval_inputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEval_inputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEval_inputContext)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python3ParserRULE_root)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(121)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(118)
			p.Single_input()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(119)
			p.File_input()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(120)
			p.Eval_input()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(123)
		p.Match(Python3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LINE_BREAK() antlr.TerminalNode
	Simple_stmt() ISimple_stmtContext
	Compound_stmt() ICompound_stmtContext

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
	return p
}

func InitEmptySingle_inputContext(p *Single_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (s *Single_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSingle_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python3ParserRULE_single_input)
	p.SetState(130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(125)
			p.Match(Python3ParserLINE_BREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(126)
			p.Simple_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(127)
			p.Compound_stmt()
		}
		{
			p.SetState(128)
			p.Match(Python3ParserLINE_BREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLINE_BREAK() []antlr.TerminalNode
	LINE_BREAK(i int) antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
	return p
}

func InitEmptyFile_inputContext(p *File_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) AllLINE_BREAK() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserLINE_BREAK)
}

func (s *File_inputContext) LINE_BREAK(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (s *File_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitFile_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python3ParserRULE_file_input)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(134)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(132)
					p.Match(Python3ParserLINE_BREAK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(133)
					p.Stmt()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(136)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Testlist() ITestlistContext
	AllLINE_BREAK() []antlr.TerminalNode
	LINE_BREAK(i int) antlr.TerminalNode

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
	return p
}

func InitEmptyEval_inputContext(p *Eval_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) AllLINE_BREAK() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserLINE_BREAK)
}

func (s *Eval_inputContext) LINE_BREAK(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (s *Eval_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitEval_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python3ParserRULE_eval_input)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(138)
		p.Testlist()
	}
	p.SetState(142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserLINE_BREAK {
		{
			p.SetState(139)
			p.Match(Python3ParserLINE_BREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmt() ISimple_stmtContext
	Compound_stmt() ICompound_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python3ParserRULE_stmt)
	p.SetState(147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(145)
			p.Simple_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(146)
			p.Compound_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
	return p
}

func InitEmptyCompound_stmtContext(p *Compound_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) CopyAll(ctx *Compound_stmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type While_stmtContext struct {
	Compound_stmtContext
}

func NewWhile_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *While_stmtContext {
	var p = new(While_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Python3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *While_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) Else_clause() IElse_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (s *While_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitWhile_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Try_stmtContext struct {
	Compound_stmtContext
}

func NewTry_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Try_stmtContext {
	var p = new(Try_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRY, 0)
}

func (s *Try_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Try_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) Finally_clause() IFinally_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinally_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinally_clauseContext)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			len++
		}
	}

	tst := make([]IExcept_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExcept_clauseContext); ok {
			tst[i] = t.(IExcept_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) Else_clause() IElse_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (s *Try_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTry_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type If_stmtContext struct {
	Compound_stmtContext
	cond ITestContext
}

func NewIf_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *If_stmtContext {
	var p = new(If_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *If_stmtContext) GetCond() ITestContext { return s.cond }

func (s *If_stmtContext) SetCond(v ITestContext) { s.cond = v }

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *If_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllElif_clause() []IElif_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElif_clauseContext); ok {
			len++
		}
	}

	tst := make([]IElif_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElif_clauseContext); ok {
			tst[i] = t.(IElif_clauseContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Elif_clause(i int) IElif_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElif_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElif_clauseContext)
}

func (s *If_stmtContext) Else_clause() IElse_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (s *If_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitIf_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type With_stmtContext struct {
	Compound_stmtContext
}

func NewWith_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *With_stmtContext {
	var p = new(With_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Python3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWith_itemContext); ok {
			len++
		}
	}

	tst := make([]IWith_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWith_itemContext); ok {
			tst[i] = t.(IWith_itemContext)
			i++
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *With_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *With_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (s *With_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitWith_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Class_or_func_def_stmtContext struct {
	Compound_stmtContext
}

func NewClass_or_func_def_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Class_or_func_def_stmtContext {
	var p = new(Class_or_func_def_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *Class_or_func_def_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_or_func_def_stmtContext) Classdef() IClassdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Class_or_func_def_stmtContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Class_or_func_def_stmtContext) AllDecorator() []IDecoratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecoratorContext); ok {
			len++
		}
	}

	tst := make([]IDecoratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecoratorContext); ok {
			tst[i] = t.(IDecoratorContext)
			i++
		}
	}

	return tst
}

func (s *Class_or_func_def_stmtContext) Decorator(i int) IDecoratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *Class_or_func_def_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClass_or_func_def_stmt(s)
	}
}

func (s *Class_or_func_def_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClass_or_func_def_stmt(s)
	}
}

func (s *Class_or_func_def_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitClass_or_func_def_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type For_stmtContext struct {
	Compound_stmtContext
}

func NewFor_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *For_stmtContext {
	var p = new(For_stmtContext)

	InitEmptyCompound_stmtContext(&p.Compound_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Compound_stmtContext))

	return p
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *For_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *For_stmtContext) Else_clause() IElse_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (s *For_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitFor_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python3ParserRULE_compound_stmt)
	var _la int

	var _alt int

	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIf_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(149)
			p.Match(Python3ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(150)

			var _x = p.Test()

			localctx.(*If_stmtContext).cond = _x
		}
		{
			p.SetState(151)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(152)
			p.Suite()
		}
		p.SetState(156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(153)
					p.Elif_clause()
				}

			}
			p.SetState(158)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(160)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(159)
				p.Else_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewWhile_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(162)
			p.Match(Python3ParserWHILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(163)
			p.Test()
		}
		{
			p.SetState(164)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(165)
			p.Suite()
		}
		p.SetState(167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(166)
				p.Else_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewFor_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASYNC {
			{
				p.SetState(169)
				p.Match(Python3ParserASYNC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(172)
			p.Match(Python3ParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(173)
			p.Exprlist()
		}
		{
			p.SetState(174)
			p.Match(Python3ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(175)
			p.Testlist()
		}
		{
			p.SetState(176)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(177)
			p.Suite()
		}
		p.SetState(179)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(178)
				p.Else_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewTry_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(181)
			p.Match(Python3ParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(182)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(183)
			p.Suite()
		}
		p.SetState(196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserEXCEPT:
			p.SetState(185)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(184)
						p.Except_clause()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

				p.SetState(187)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(190)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(189)
					p.Else_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(193)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(192)
					p.Finally_clause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case Python3ParserFINALLY:
			{
				p.SetState(195)
				p.Finally_clause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewWith_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASYNC {
			{
				p.SetState(198)
				p.Match(Python3ParserASYNC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(201)
			p.Match(Python3ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(202)
			p.With_item()
		}
		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserCOMMA {
			{
				p.SetState(203)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(204)
				p.With_item()
			}

			p.SetState(209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(210)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(211)
			p.Suite()
		}

	case 6:
		localctx = NewClass_or_func_def_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserAT {
			{
				p.SetState(213)
				p.Decorator()
			}

			p.SetState(218)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserCLASS:
			{
				p.SetState(219)
				p.Classdef()
			}

		case Python3ParserDEF, Python3ParserASYNC:
			{
				p.SetState(220)
				p.Funcdef()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmt() ISimple_stmtContext
	LINE_BREAK() antlr.TerminalNode
	INDENT() antlr.TerminalNode
	DEDENT() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
	return p
}

func InitEmptySuiteContext(p *SuiteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSuite(s)
	}
}

func (s *SuiteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSuite(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python3ParserRULE_suite)
	var _alt int

	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(225)
			p.Simple_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(226)
			p.Match(Python3ParserLINE_BREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(227)
			p.Match(Python3ParserINDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(228)
					p.Stmt()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(231)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(233)
			p.Match(Python3ParserDEDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	Dotted_name() IDotted_nameContext
	LINE_BREAK() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
	return p
}

func InitEmptyDecoratorContext(p *DecoratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) AT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, 0)
}

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, 0)
}

func (s *DecoratorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *DecoratorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDecorator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python3ParserRULE_decorator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(Python3ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(238)
		p.dotted_name(0)
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(239)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261322287421849600) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(240)
				p.Arglist()
			}

		}
		{
			p.SetState(243)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(246)
		p.Match(Python3ParserLINE_BREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElif_clauseContext is an interface to support dynamic dispatch.
type IElif_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELIF() antlr.TerminalNode
	Test() ITestContext
	COLON() antlr.TerminalNode
	Suite() ISuiteContext

	// IsElif_clauseContext differentiates from other interfaces.
	IsElif_clauseContext()
}

type Elif_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElif_clauseContext() *Elif_clauseContext {
	var p = new(Elif_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_elif_clause
	return p
}

func InitEmptyElif_clauseContext(p *Elif_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_elif_clause
}

func (*Elif_clauseContext) IsElif_clauseContext() {}

func NewElif_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elif_clauseContext {
	var p = new(Elif_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_elif_clause

	return p
}

func (s *Elif_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Elif_clauseContext) ELIF() antlr.TerminalNode {
	return s.GetToken(Python3ParserELIF, 0)
}

func (s *Elif_clauseContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Elif_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Elif_clauseContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Elif_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elif_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elif_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterElif_clause(s)
	}
}

func (s *Elif_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitElif_clause(s)
	}
}

func (s *Elif_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitElif_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Elif_clause() (localctx IElif_clauseContext) {
	localctx = NewElif_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python3ParserRULE_elif_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(248)
		p.Match(Python3ParserELIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(249)
		p.Test()
	}
	{
		p.SetState(250)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(251)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_clauseContext is an interface to support dynamic dispatch.
type IElse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Suite() ISuiteContext

	// IsElse_clauseContext differentiates from other interfaces.
	IsElse_clauseContext()
}

type Else_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_clauseContext() *Else_clauseContext {
	var p = new(Else_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_else_clause
	return p
}

func InitEmptyElse_clauseContext(p *Else_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_else_clause
}

func (*Else_clauseContext) IsElse_clauseContext() {}

func NewElse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_clauseContext {
	var p = new(Else_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_else_clause

	return p
}

func (s *Else_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_clauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *Else_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Else_clauseContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Else_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterElse_clause(s)
	}
}

func (s *Else_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitElse_clause(s)
	}
}

func (s *Else_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitElse_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Else_clause() (localctx IElse_clauseContext) {
	localctx = NewElse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python3ParserRULE_else_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(253)
		p.Match(Python3ParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(254)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(255)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinally_clauseContext is an interface to support dynamic dispatch.
type IFinally_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Suite() ISuiteContext

	// IsFinally_clauseContext differentiates from other interfaces.
	IsFinally_clauseContext()
}

type Finally_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_clauseContext() *Finally_clauseContext {
	var p = new(Finally_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_finally_clause
	return p
}

func InitEmptyFinally_clauseContext(p *Finally_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_finally_clause
}

func (*Finally_clauseContext) IsFinally_clauseContext() {}

func NewFinally_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_clauseContext {
	var p = new(Finally_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_finally_clause

	return p
}

func (s *Finally_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Finally_clauseContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Python3ParserFINALLY, 0)
}

func (s *Finally_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Finally_clauseContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Finally_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finally_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFinally_clause(s)
	}
}

func (s *Finally_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFinally_clause(s)
	}
}

func (s *Finally_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitFinally_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Finally_clause() (localctx IFinally_clauseContext) {
	localctx = NewFinally_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python3ParserRULE_finally_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(Python3ParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(259)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Test() ITestContext
	AS() antlr.TerminalNode
	Expr() IExprContext

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
	return p
}

func InitEmptyWith_itemContext(p *With_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (s *With_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitWith_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python3ParserRULE_with_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Test()
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(262)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(263)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	Test() ITestContext
	COMMA() antlr.TerminalNode
	Name() INameContext
	AS() antlr.TerminalNode

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
	return p
}

func InitEmptyExcept_clauseContext(p *Except_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Except_clauseContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Except_clauseContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (s *Except_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitExcept_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python3ParserRULE_except_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		p.Match(Python3ParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
		{
			p.SetState(267)
			p.Test()
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			p.SetState(268)

			if !(p.CheckVersion(2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
				goto errorExit
			}
			{
				p.SetState(269)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(270)
				p.Name()
			}
			p.SetVersion(2)

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 2 {
			p.SetState(273)

			if !(p.CheckVersion(3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
				goto errorExit
			}
			{
				p.SetState(274)
				p.Match(Python3ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(275)
				p.Name()
			}
			p.SetVersion(3)

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	{
		p.SetState(282)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(283)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Name() INameContext
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
	return p
}

func InitEmptyClassdefContext(p *ClassdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLASS, 0)
}

func (s *ClassdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ClassdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ClassdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (s *ClassdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitClassdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python3ParserRULE_classdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.Match(Python3ParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(286)
		p.Name()
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(287)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261322287421849600) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(288)
				p.Arglist()
			}

		}
		{
			p.SetState(291)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(294)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(295)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEF() antlr.TerminalNode
	Name() INameContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	ASYNC() antlr.TerminalNode
	Typedargslist() ITypedargslistContext
	ARROW() antlr.TerminalNode
	Test() ITestContext

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
	return p
}

func InitEmptyFuncdefContext(p *FuncdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEF, 0)
}

func (s *FuncdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FuncdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *FuncdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *FuncdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *FuncdefContext) Typedargslist() ITypedargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *FuncdefContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Python3ParserARROW, 0)
}

func (s *FuncdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (s *FuncdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitFuncdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python3ParserRULE_funcdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserASYNC {
		{
			p.SetState(297)
			p.Match(Python3ParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(300)
		p.Match(Python3ParserDEF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(301)
		p.Name()
	}
	{
		p.SetState(302)
		p.Match(Python3ParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-39)) & ^0x3f) == 0 && ((int64(1)<<(_la-39))&144115188075856419) != 0 {
		{
			p.SetState(303)
			p.Typedargslist()
		}

	}
	{
		p.SetState(306)
		p.Match(Python3ParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserARROW {
		{
			p.SetState(307)
			p.Match(Python3ParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)
			p.Test()
		}

	}
	{
		p.SetState(311)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(312)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Args() IArgsContext
	Kwargs() IKwargsContext
	AllDef_parameters() []IDef_parametersContext
	Def_parameters(i int) IDef_parametersContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
	return p
}

func InitEmptyTypedargslistContext(p *TypedargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) Args() IArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *TypedargslistContext) Kwargs() IKwargsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwargsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwargsContext)
}

func (s *TypedargslistContext) AllDef_parameters() []IDef_parametersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDef_parametersContext); ok {
			len++
		}
	}

	tst := make([]IDef_parametersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDef_parametersContext); ok {
			tst[i] = t.(IDef_parametersContext)
			i++
		}
	}

	return tst
}

func (s *TypedargslistContext) Def_parameters(i int) IDef_parametersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDef_parametersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDef_parametersContext)
}

func (s *TypedargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TypedargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (s *TypedargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTypedargslist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python3ParserRULE_typedargslist)
	var _la int

	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(314)
				p.Def_parameters()
			}
			{
				p.SetState(315)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTAR:
			{
				p.SetState(319)
				p.Args()
			}
			p.SetState(322)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(320)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(321)
					p.Def_parameters()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(326)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(324)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(325)
					p.Kwargs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case Python3ParserPOWER:
			{
				p.SetState(328)
				p.Kwargs()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(331)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(334)
			p.Def_parameters()
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(335)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgsContext is an interface to support dynamic dispatch.
type IArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Named_parameter() INamed_parameterContext

	// IsArgsContext differentiates from other interfaces.
	IsArgsContext()
}

type ArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsContext() *ArgsContext {
	var p = new(ArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_args
	return p
}

func InitEmptyArgsContext(p *ArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_args
}

func (*ArgsContext) IsArgsContext() {}

func NewArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsContext {
	var p = new(ArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_args

	return p
}

func (s *ArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ArgsContext) Named_parameter() INamed_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *ArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArgs(s)
	}
}

func (s *ArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArgs(s)
	}
}

func (s *ArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Args() (localctx IArgsContext) {
	localctx = NewArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python3ParserRULE_args)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(Python3ParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(341)
		p.Named_parameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwargsContext is an interface to support dynamic dispatch.
type IKwargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POWER() antlr.TerminalNode
	Named_parameter() INamed_parameterContext

	// IsKwargsContext differentiates from other interfaces.
	IsKwargsContext()
}

type KwargsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwargsContext() *KwargsContext {
	var p = new(KwargsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_kwargs
	return p
}

func InitEmptyKwargsContext(p *KwargsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_kwargs
}

func (*KwargsContext) IsKwargsContext() {}

func NewKwargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwargsContext {
	var p = new(KwargsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_kwargs

	return p
}

func (s *KwargsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwargsContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *KwargsContext) Named_parameter() INamed_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *KwargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterKwargs(s)
	}
}

func (s *KwargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitKwargs(s)
	}
}

func (s *KwargsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitKwargs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Kwargs() (localctx IKwargsContext) {
	localctx = NewKwargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python3ParserRULE_kwargs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.Match(Python3ParserPOWER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(344)
		p.Named_parameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDef_parametersContext is an interface to support dynamic dispatch.
type IDef_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDef_parameter() []IDef_parameterContext
	Def_parameter(i int) IDef_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDef_parametersContext differentiates from other interfaces.
	IsDef_parametersContext()
}

type Def_parametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDef_parametersContext() *Def_parametersContext {
	var p = new(Def_parametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_def_parameters
	return p
}

func InitEmptyDef_parametersContext(p *Def_parametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_def_parameters
}

func (*Def_parametersContext) IsDef_parametersContext() {}

func NewDef_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_parametersContext {
	var p = new(Def_parametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_def_parameters

	return p
}

func (s *Def_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Def_parametersContext) AllDef_parameter() []IDef_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDef_parameterContext); ok {
			len++
		}
	}

	tst := make([]IDef_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDef_parameterContext); ok {
			tst[i] = t.(IDef_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Def_parametersContext) Def_parameter(i int) IDef_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDef_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDef_parameterContext)
}

func (s *Def_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Def_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Def_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDef_parameters(s)
	}
}

func (s *Def_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDef_parameters(s)
	}
}

func (s *Def_parametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDef_parameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Def_parameters() (localctx IDef_parametersContext) {
	localctx = NewDef_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python3ParserRULE_def_parameters)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Def_parameter()
	}
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(347)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(348)
				p.Def_parameter()
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDef_parameterContext is an interface to support dynamic dispatch.
type IDef_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Named_parameter() INamed_parameterContext
	ASSIGN() antlr.TerminalNode
	Test() ITestContext
	STAR() antlr.TerminalNode

	// IsDef_parameterContext differentiates from other interfaces.
	IsDef_parameterContext()
}

type Def_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDef_parameterContext() *Def_parameterContext {
	var p = new(Def_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_def_parameter
	return p
}

func InitEmptyDef_parameterContext(p *Def_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_def_parameter
}

func (*Def_parameterContext) IsDef_parameterContext() {}

func NewDef_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_parameterContext {
	var p = new(Def_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_def_parameter

	return p
}

func (s *Def_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Def_parameterContext) Named_parameter() INamed_parameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_parameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *Def_parameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *Def_parameterContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Def_parameterContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Def_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDef_parameter(s)
	}
}

func (s *Def_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDef_parameter(s)
	}
}

func (s *Def_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDef_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Def_parameter() (localctx IDef_parameterContext) {
	localctx = NewDef_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python3ParserRULE_def_parameter)
	var _la int

	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(354)
			p.Named_parameter()
		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(355)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(356)
				p.Test()
			}

		}

	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(359)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_parameterContext is an interface to support dynamic dispatch.
type INamed_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsNamed_parameterContext differentiates from other interfaces.
	IsNamed_parameterContext()
}

type Named_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameterContext() *Named_parameterContext {
	var p = new(Named_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_named_parameter
	return p
}

func InitEmptyNamed_parameterContext(p *Named_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_named_parameter
}

func (*Named_parameterContext) IsNamed_parameterContext() {}

func NewNamed_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameterContext {
	var p = new(Named_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_named_parameter

	return p
}

func (s *Named_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameterContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Named_parameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Named_parameterContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Named_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNamed_parameter(s)
	}
}

func (s *Named_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNamed_parameter(s)
	}
}

func (s *Named_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitNamed_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Named_parameter() (localctx INamed_parameterContext) {
	localctx = NewNamed_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python3ParserRULE_named_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Name()
	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOLON {
		{
			p.SetState(363)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(364)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSmall_stmt() []ISmall_stmtContext
	Small_stmt(i int) ISmall_stmtContext
	LINE_BREAK() antlr.TerminalNode
	EOF() antlr.TerminalNode
	AllSEMI_COLON() []antlr.TerminalNode
	SEMI_COLON(i int) antlr.TerminalNode

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
	return p
}

func InitEmptySimple_stmtContext(p *Simple_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISmall_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISmall_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISmall_stmtContext); ok {
			tst[i] = t.(ISmall_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISmall_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserLINE_BREAK, 0)
}

func (s *Simple_stmtContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *Simple_stmtContext) AllSEMI_COLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSEMI_COLON)
}

func (s *Simple_stmtContext) SEMI_COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSEMI_COLON, i)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSimple_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python3ParserRULE_simple_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Small_stmt()
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(368)
				p.Match(Python3ParserSEMI_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(369)
				p.Small_stmt()
			}

		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserSEMI_COLON {
		{
			p.SetState(375)
			p.Match(Python3ParserSEMI_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(378)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Python3ParserEOF || _la == Python3ParserLINE_BREAK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
	return p
}

func InitEmptySmall_stmtContext(p *Small_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) CopyAll(ctx *Small_stmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Assert_stmtContext struct {
	Small_stmtContext
}

func NewAssert_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitAssert_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Nonlocal_stmtContext struct {
	Small_stmtContext
}

func NewNonlocal_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Nonlocal_stmtContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Nonlocal_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Nonlocal_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitNonlocal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Pass_stmtContext struct {
	Small_stmtContext
}

func NewPass_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserPASS, 0)
}

func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (s *Pass_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitPass_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Import_stmtContext struct {
	Small_stmtContext
}

func NewImport_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Import_stmtContext {
	var p = new(Import_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_stmtContext) Dotted_as_names() IDotted_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (s *Import_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitImport_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Expr_stmtContext struct {
	Small_stmtContext
}

func NewExpr_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) Testlist_star_expr() ITestlist_star_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Assign_part() IAssign_partContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssign_partContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssign_partContext)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitExpr_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Raise_stmtContext struct {
	Small_stmtContext
}

func NewRaise_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(Python3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Raise_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Raise_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitRaise_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Yield_stmtContext struct {
	Small_stmtContext
}

func NewYield_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (s *Yield_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitYield_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type From_stmtContext struct {
	Small_stmtContext
}

func NewFrom_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *From_stmtContext {
	var p = new(From_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *From_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *From_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *From_stmtContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *From_stmtContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *From_stmtContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *From_stmtContext) Import_as_names() IImport_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *From_stmtContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *From_stmtContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *From_stmtContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *From_stmtContext) AllELLIPSIS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELLIPSIS)
}

func (s *From_stmtContext) ELLIPSIS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, i)
}

func (s *From_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFrom_stmt(s)
	}
}

func (s *From_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFrom_stmt(s)
	}
}

func (s *From_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitFrom_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Global_stmtContext struct {
	Small_stmtContext
}

func NewGlobal_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Global_stmtContext {
	var p = new(Global_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Global_stmtContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Global_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Global_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitGlobal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Continue_stmtContext struct {
	Small_stmtContext
}

func NewContinue_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitContinue_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Exec_stmtContext struct {
	Small_stmtContext
}

func NewExec_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) EXEC() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXEC, 0)
}

func (s *Exec_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Exec_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Exec_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Exec_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExec_stmt(s)
	}
}

func (s *Exec_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitExec_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Break_stmtContext struct {
	Small_stmtContext
}

func NewBreak_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Break_stmtContext {
	var p = new(Break_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserBREAK, 0)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (s *Break_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitBreak_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Del_stmtContext struct {
	Small_stmtContext
}

func NewDel_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Del_stmtContext {
	var p = new(Del_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (s *Del_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDel_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Print_stmtContext struct {
	Small_stmtContext
}

func NewPrint_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Print_stmtContext {
	var p = new(Print_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) PRINT() antlr.TerminalNode {
	return s.GetToken(Python3ParserPRINT, 0)
}

func (s *Print_stmtContext) RIGHT_SHIFT() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT, 0)
}

func (s *Print_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Print_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Print_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Print_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

func (s *Print_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitPrint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

type Return_stmtContext struct {
	Small_stmtContext
}

func NewReturn_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Return_stmtContext {
	var p = new(Return_stmtContext)

	InitEmptySmall_stmtContext(&p.Small_stmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*Small_stmtContext))

	return p
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (s *Return_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitReturn_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python3ParserRULE_small_stmt)
	var _la int

	var _alt int

	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExpr_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(380)
			p.Testlist_star_expr()
		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(381)
				p.Assign_part()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewPrint_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(384)

		if !(p.CheckVersion(2)) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
			goto errorExit
		}
		{
			p.SetState(385)
			p.Match(Python3ParserPRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
			{
				p.SetState(386)
				p.Test()
			}
			p.SetState(391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(387)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(388)
						p.Test()
					}

				}
				p.SetState(393)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(395)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(394)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case Python3ParserRIGHT_SHIFT:
			{
				p.SetState(397)
				p.Match(Python3ParserRIGHT_SHIFT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(398)
				p.Test()
			}

			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(399)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(400)
						p.Test()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

				p.SetState(403)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(406)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(405)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetVersion(2)

	case 3:
		localctx = NewDel_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(412)
			p.Match(Python3ParserDEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(413)
			p.Exprlist()
		}

	case 4:
		localctx = NewPass_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(414)
			p.Match(Python3ParserPASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewBreak_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(415)
			p.Match(Python3ParserBREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewContinue_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(416)
			p.Match(Python3ParserCONTINUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewReturn_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(417)
			p.Match(Python3ParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(418)
				p.Testlist()
			}

		}

	case 8:
		localctx = NewRaise_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(421)
			p.Match(Python3ParserRAISE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(422)
				p.Test()
			}
			p.SetState(429)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(423)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(424)
					p.Test()
				}
				p.SetState(427)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(425)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(426)
						p.Test()
					}

				}

			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFROM {
			{
				p.SetState(433)
				p.Match(Python3ParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(434)
				p.Test()
			}

		}

	case 9:
		localctx = NewYield_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(437)
			p.Yield_expr()
		}

	case 10:
		localctx = NewImport_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(438)
			p.Match(Python3ParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(439)
			p.Dotted_as_names()
		}

	case 11:
		localctx = NewFrom_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(440)
			p.Match(Python3ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
				{
					p.SetState(441)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

				p.SetState(446)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(447)
				p.dotted_name(0)
			}

		case 2:
			p.SetState(449)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
				{
					p.SetState(448)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

				p.SetState(451)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(455)
			p.Match(Python3ParserIMPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTAR:
			{
				p.SetState(456)
				p.Match(Python3ParserSTAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Python3ParserOPEN_PAREN:
			{
				p.SetState(457)
				p.Match(Python3ParserOPEN_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(458)
				p.Import_as_names()
			}
			{
				p.SetState(459)
				p.Match(Python3ParserCLOSE_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME:
			{
				p.SetState(461)
				p.Import_as_names()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 12:
		localctx = NewGlobal_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(464)
			p.Match(Python3ParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(465)
			p.Name()
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserCOMMA {
			{
				p.SetState(466)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(467)
				p.Name()
			}

			p.SetState(472)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 13:
		localctx = NewExec_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(473)

		if !(p.CheckVersion(2)) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
			goto errorExit
		}
		{
			p.SetState(474)
			p.Match(Python3ParserEXEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			p.expr(0)
		}
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserIN {
			{
				p.SetState(476)
				p.Match(Python3ParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(477)
				p.Test()
			}
			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(478)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(479)
					p.Test()
				}

			}

		}
		p.SetVersion(2)

	case 14:
		localctx = NewAssert_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(486)
			p.Match(Python3ParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(487)
			p.Test()
		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(488)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(489)
				p.Test()
			}

		}

	case 15:
		localctx = NewNonlocal_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(492)

		if !(p.CheckVersion(3)) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
			goto errorExit
		}
		{
			p.SetState(493)
			p.Match(Python3ParserNONLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.Name()
		}
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserCOMMA {
			{
				p.SetState(495)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(496)
				p.Name()
			}

			p.SetState(501)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetVersion(3)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	Testlist() ITestlistContext

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
	return p
}

func InitEmptyTestlist_star_exprContext(p *Testlist_star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_star_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTestlist_star_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python3ParserRULE_testlist_star_expr)
	var _alt int

	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(508)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
					{
						p.SetState(506)
						p.Test()
					}

				case Python3ParserSTAR:
					{
						p.SetState(507)
						p.Star_expr()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(510)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(514)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(516)
				p.Test()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(517)
				p.Star_expr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(520)
			p.Testlist()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Expr() IExprContext

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
	return p
}

func InitEmptyStar_exprContext(p *Star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (s *Star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitStar_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python3ParserRULE_star_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(Python3ParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssign_partContext is an interface to support dynamic dispatch.
type IAssign_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllTestlist_star_expr() []ITestlist_star_exprContext
	Testlist_star_expr(i int) ITestlist_star_exprContext
	Yield_expr() IYield_exprContext
	COLON() antlr.TerminalNode
	Test() ITestContext
	Testlist() ITestlistContext
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	MULT_ASSIGN() antlr.TerminalNode
	AT_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	LEFT_SHIFT_ASSIGN() antlr.TerminalNode
	RIGHT_SHIFT_ASSIGN() antlr.TerminalNode
	POWER_ASSIGN() antlr.TerminalNode
	IDIV_ASSIGN() antlr.TerminalNode

	// IsAssign_partContext differentiates from other interfaces.
	IsAssign_partContext()
}

type Assign_partContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAssign_partContext() *Assign_partContext {
	var p = new(Assign_partContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assign_part
	return p
}

func InitEmptyAssign_partContext(p *Assign_partContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assign_part
}

func (*Assign_partContext) IsAssign_partContext() {}

func NewAssign_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_partContext {
	var p = new(Assign_partContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_assign_part

	return p
}

func (s *Assign_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_partContext) GetOp() antlr.Token { return s.op }

func (s *Assign_partContext) SetOp(v antlr.Token) { s.op = v }

func (s *Assign_partContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *Assign_partContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *Assign_partContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			len++
		}
	}

	tst := make([]ITestlist_star_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestlist_star_exprContext); ok {
			tst[i] = t.(ITestlist_star_exprContext)
			i++
		}
	}

	return tst
}

func (s *Assign_partContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Assign_partContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Assign_partContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Assign_partContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assign_partContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Assign_partContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD_ASSIGN, 0)
}

func (s *Assign_partContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserSUB_ASSIGN, 0)
}

func (s *Assign_partContext) MULT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMULT_ASSIGN, 0)
}

func (s *Assign_partContext) AT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT_ASSIGN, 0)
}

func (s *Assign_partContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV_ASSIGN, 0)
}

func (s *Assign_partContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD_ASSIGN, 0)
}

func (s *Assign_partContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_ASSIGN, 0)
}

func (s *Assign_partContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_ASSIGN, 0)
}

func (s *Assign_partContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR_ASSIGN, 0)
}

func (s *Assign_partContext) LEFT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT_ASSIGN, 0)
}

func (s *Assign_partContext) RIGHT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT_ASSIGN, 0)
}

func (s *Assign_partContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER_ASSIGN, 0)
}

func (s *Assign_partContext) IDIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV_ASSIGN, 0)
}

func (s *Assign_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assign_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAssign_part(s)
	}
}

func (s *Assign_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAssign_part(s)
	}
}

func (s *Assign_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitAssign_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Assign_part() (localctx IAssign_partContext) {
	localctx = NewAssign_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python3ParserRULE_assign_part)
	var _la int

	var _alt int

	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(526)
			p.Match(Python3ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserSTAR, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
			{
				p.SetState(527)
				p.Testlist_star_expr()
			}
			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(528)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(529)
						p.Testlist_star_expr()
					}

				}
				p.SetState(534)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(537)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserASSIGN {
				{
					p.SetState(535)
					p.Match(Python3ParserASSIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(536)
					p.Yield_expr()
				}

			}

		case Python3ParserYIELD:
			{
				p.SetState(539)
				p.Yield_expr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(542)

		if !(p.CheckVersion(3)) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
			goto errorExit
		}
		{
			p.SetState(543)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			p.Test()
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(545)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(546)
				p.Testlist()
			}

		}
		p.SetVersion(3)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(551)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Assign_partContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&8191) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Assign_partContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(552)
				p.Yield_expr()
			}

		case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
			{
				p.SetState(553)
				p.Testlist()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
	return p
}

func InitEmptyExprlistContext(p *ExprlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (s *ExprlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitExprlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python3ParserRULE_exprlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.expr(0)
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(559)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(560)
				p.expr(0)
			}

		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(566)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImport_as_name() []IImport_as_nameContext
	Import_as_name(i int) IImport_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
	return p
}

func InitEmptyImport_as_namesContext(p *Import_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IImport_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImport_as_nameContext); ok {
			tst[i] = t.(IImport_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Import_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (s *Import_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitImport_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python3ParserRULE_import_as_names)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Import_as_name()
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(570)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(571)
				p.Import_as_name()
			}

		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(577)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllName() []INameContext
	Name(i int) INameContext
	AS() antlr.TerminalNode

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
	return p
}

func InitEmptyImport_as_nameContext(p *Import_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Import_as_nameContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (s *Import_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitImport_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python3ParserRULE_import_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Name()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(581)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.Name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDotted_as_name() []IDotted_as_nameContext
	Dotted_as_name(i int) IDotted_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
	return p
}

func InitEmptyDotted_as_namesContext(p *Dotted_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IDotted_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDotted_as_nameContext); ok {
			tst[i] = t.(IDotted_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Dotted_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDotted_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python3ParserRULE_dotted_as_names)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Dotted_as_name()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(586)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.Dotted_as_name()
		}

		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dotted_name() IDotted_nameContext
	AS() antlr.TerminalNode
	Name() INameContext

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
	return p
}

func InitEmptyDotted_as_nameContext(p *Dotted_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Dotted_as_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDotted_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python3ParserRULE_dotted_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.dotted_name(0)
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(594)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.Name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLogical_test() []ILogical_testContext
	Logical_test(i int) ILogical_testContext
	IF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Test() ITestContext
	LAMBDA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Varargslist() IVarargslistContext

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
	return p
}

func InitEmptyTestContext(p *TestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllLogical_test() []ILogical_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogical_testContext); ok {
			len++
		}
	}

	tst := make([]ILogical_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogical_testContext); ok {
			tst[i] = t.(ILogical_testContext)
			i++
		}
	}

	return tst
}

func (s *TestContext) Logical_test(i int) ILogical_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogical_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *TestContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *TestContext) Varargslist() IVarargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTest(s)
	}
}

func (s *TestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python3ParserRULE_test)
	var _la int

	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNONE, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(598)
			p.logical_test(0)
		}
		p.SetState(604)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(599)
				p.Match(Python3ParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(600)
				p.logical_test(0)
			}
			{
				p.SetState(601)
				p.Match(Python3ParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(602)
				p.Test()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(606)
			p.Match(Python3ParserLAMBDA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-39)) & ^0x3f) == 0 && ((int64(1)<<(_la-39))&144115188075856419) != 0 {
			{
				p.SetState(607)
				p.Varargslist()
			}

		}
		{
			p.SetState(610)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.Test()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Varargs() IVarargsContext
	Varkwargs() IVarkwargsContext
	AllVardef_parameters() []IVardef_parametersContext
	Vardef_parameters(i int) IVardef_parametersContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
	return p
}

func InitEmptyVarargslistContext(p *VarargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) Varargs() IVarargsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargsContext)
}

func (s *VarargslistContext) Varkwargs() IVarkwargsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarkwargsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarkwargsContext)
}

func (s *VarargslistContext) AllVardef_parameters() []IVardef_parametersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVardef_parametersContext); ok {
			len++
		}
	}

	tst := make([]IVardef_parametersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVardef_parametersContext); ok {
			tst[i] = t.(IVardef_parametersContext)
			i++
		}
	}

	return tst
}

func (s *VarargslistContext) Vardef_parameters(i int) IVardef_parametersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardef_parametersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardef_parametersContext)
}

func (s *VarargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *VarargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (s *VarargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitVarargslist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python3ParserRULE_varargslist)
	var _la int

	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(617)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(614)
				p.Vardef_parameters()
			}
			{
				p.SetState(615)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTAR:
			{
				p.SetState(619)
				p.Varargs()
			}
			p.SetState(622)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(620)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(621)
					p.Vardef_parameters()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(624)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(625)
					p.Varkwargs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case Python3ParserPOWER:
			{
				p.SetState(628)
				p.Varkwargs()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(631)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(634)
			p.Vardef_parameters()
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(635)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVardef_parametersContext is an interface to support dynamic dispatch.
type IVardef_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVardef_parameter() []IVardef_parameterContext
	Vardef_parameter(i int) IVardef_parameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVardef_parametersContext differentiates from other interfaces.
	IsVardef_parametersContext()
}

type Vardef_parametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardef_parametersContext() *Vardef_parametersContext {
	var p = new(Vardef_parametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vardef_parameters
	return p
}

func InitEmptyVardef_parametersContext(p *Vardef_parametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vardef_parameters
}

func (*Vardef_parametersContext) IsVardef_parametersContext() {}

func NewVardef_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vardef_parametersContext {
	var p = new(Vardef_parametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vardef_parameters

	return p
}

func (s *Vardef_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Vardef_parametersContext) AllVardef_parameter() []IVardef_parameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVardef_parameterContext); ok {
			len++
		}
	}

	tst := make([]IVardef_parameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVardef_parameterContext); ok {
			tst[i] = t.(IVardef_parameterContext)
			i++
		}
	}

	return tst
}

func (s *Vardef_parametersContext) Vardef_parameter(i int) IVardef_parameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVardef_parameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVardef_parameterContext)
}

func (s *Vardef_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Vardef_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Vardef_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vardef_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vardef_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVardef_parameters(s)
	}
}

func (s *Vardef_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVardef_parameters(s)
	}
}

func (s *Vardef_parametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitVardef_parameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Vardef_parameters() (localctx IVardef_parametersContext) {
	localctx = NewVardef_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python3ParserRULE_vardef_parameters)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Vardef_parameter()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(641)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(642)
				p.Vardef_parameter()
			}

		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVardef_parameterContext is an interface to support dynamic dispatch.
type IVardef_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	ASSIGN() antlr.TerminalNode
	Test() ITestContext
	STAR() antlr.TerminalNode

	// IsVardef_parameterContext differentiates from other interfaces.
	IsVardef_parameterContext()
}

type Vardef_parameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardef_parameterContext() *Vardef_parameterContext {
	var p = new(Vardef_parameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vardef_parameter
	return p
}

func InitEmptyVardef_parameterContext(p *Vardef_parameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vardef_parameter
}

func (*Vardef_parameterContext) IsVardef_parameterContext() {}

func NewVardef_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vardef_parameterContext {
	var p = new(Vardef_parameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vardef_parameter

	return p
}

func (s *Vardef_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Vardef_parameterContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Vardef_parameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *Vardef_parameterContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Vardef_parameterContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Vardef_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vardef_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vardef_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVardef_parameter(s)
	}
}

func (s *Vardef_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVardef_parameter(s)
	}
}

func (s *Vardef_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitVardef_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Vardef_parameter() (localctx IVardef_parameterContext) {
	localctx = NewVardef_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python3ParserRULE_vardef_parameter)
	var _la int

	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(648)
			p.Name()
		}
		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(649)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(650)
				p.Test()
			}

		}

	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarargsContext is an interface to support dynamic dispatch.
type IVarargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Name() INameContext

	// IsVarargsContext differentiates from other interfaces.
	IsVarargsContext()
}

type VarargsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargsContext() *VarargsContext {
	var p = new(VarargsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargs
	return p
}

func InitEmptyVarargsContext(p *VarargsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargs
}

func (*VarargsContext) IsVarargsContext() {}

func NewVarargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargsContext {
	var p = new(VarargsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargs

	return p
}

func (s *VarargsContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargsContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *VarargsContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VarargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVarargs(s)
	}
}

func (s *VarargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVarargs(s)
	}
}

func (s *VarargsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitVarargs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Varargs() (localctx IVarargsContext) {
	localctx = NewVarargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python3ParserRULE_varargs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(Python3ParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarkwargsContext is an interface to support dynamic dispatch.
type IVarkwargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POWER() antlr.TerminalNode
	Name() INameContext

	// IsVarkwargsContext differentiates from other interfaces.
	IsVarkwargsContext()
}

type VarkwargsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarkwargsContext() *VarkwargsContext {
	var p = new(VarkwargsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varkwargs
	return p
}

func InitEmptyVarkwargsContext(p *VarkwargsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varkwargs
}

func (*VarkwargsContext) IsVarkwargsContext() {}

func NewVarkwargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarkwargsContext {
	var p = new(VarkwargsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varkwargs

	return p
}

func (s *VarkwargsContext) GetParser() antlr.Parser { return s.parser }

func (s *VarkwargsContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *VarkwargsContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VarkwargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarkwargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarkwargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVarkwargs(s)
	}
}

func (s *VarkwargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVarkwargs(s)
	}
}

func (s *VarkwargsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitVarkwargs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Varkwargs() (localctx IVarkwargsContext) {
	localctx = NewVarkwargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python3ParserRULE_varkwargs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Match(Python3ParserPOWER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(660)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogical_testContext is an interface to support dynamic dispatch.
type ILogical_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	Comparison() IComparisonContext
	NOT() antlr.TerminalNode
	AllLogical_test() []ILogical_testContext
	Logical_test(i int) ILogical_testContext
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsLogical_testContext differentiates from other interfaces.
	IsLogical_testContext()
}

type Logical_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyLogical_testContext() *Logical_testContext {
	var p = new(Logical_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_logical_test
	return p
}

func InitEmptyLogical_testContext(p *Logical_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_logical_test
}

func (*Logical_testContext) IsLogical_testContext() {}

func NewLogical_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_testContext {
	var p = new(Logical_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_logical_test

	return p
}

func (s *Logical_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_testContext) GetOp() antlr.Token { return s.op }

func (s *Logical_testContext) SetOp(v antlr.Token) { s.op = v }

func (s *Logical_testContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Logical_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Logical_testContext) AllLogical_test() []ILogical_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogical_testContext); ok {
			len++
		}
	}

	tst := make([]ILogical_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogical_testContext); ok {
			tst[i] = t.(ILogical_testContext)
			i++
		}
	}

	return tst
}

func (s *Logical_testContext) Logical_test(i int) ILogical_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogical_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *Logical_testContext) AND() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND, 0)
}

func (s *Logical_testContext) OR() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR, 0)
}

func (s *Logical_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLogical_test(s)
	}
}

func (s *Logical_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLogical_test(s)
	}
}

func (s *Logical_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitLogical_test(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Logical_test() (localctx ILogical_testContext) {
	return p.logical_test(0)
}

func (p *Python3Parser) logical_test(_p int) (localctx ILogical_testContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogical_testContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_testContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, Python3ParserRULE_logical_test, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNONE, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
		{
			p.SetState(663)
			p.comparison(0)
		}

	case Python3ParserNOT:
		{
			p.SetState(664)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(665)
			p.logical_test(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogical_testContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_logical_test)
				p.SetState(668)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(669)

					var _m = p.Match(Python3ParserAND)

					localctx.(*Logical_testContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(670)
					p.logical_test(3)
				}

			case 2:
				localctx = NewLogical_testContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_logical_test)
				p.SetState(671)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(672)

					var _m = p.Match(Python3ParserOR)

					localctx.(*Logical_testContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(673)
					p.logical_test(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptional returns the optional token.
	GetOptional() antlr.Token

	// SetOptional sets the optional token.
	SetOptional(antlr.Token)

	// Getter signatures
	Expr() IExprContext
	AllComparison() []IComparisonContext
	Comparison(i int) IComparisonContext
	LESS_THAN() antlr.TerminalNode
	GREATER_THAN() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	GT_EQ() antlr.TerminalNode
	LT_EQ() antlr.TerminalNode
	NOT_EQ_1() antlr.TerminalNode
	NOT_EQ_2() antlr.TerminalNode
	IN() antlr.TerminalNode
	IS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	optional antlr.Token
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
	return p
}

func InitEmptyComparisonContext(p *ComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) GetOptional() antlr.Token { return s.optional }

func (s *ComparisonContext) SetOptional(v antlr.Token) { s.optional = v }

func (s *ComparisonContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComparison() []IComparisonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonContext); ok {
			len++
		}
	}

	tst := make([]IComparisonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonContext); ok {
			tst[i] = t.(IComparisonContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Comparison(i int) IComparisonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *ComparisonContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLESS_THAN, 0)
}

func (s *ComparisonContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserGREATER_THAN, 0)
}

func (s *ComparisonContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(Python3ParserEQUALS, 0)
}

func (s *ComparisonContext) GT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserGT_EQ, 0)
}

func (s *ComparisonContext) LT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserLT_EQ, 0)
}

func (s *ComparisonContext) NOT_EQ_1() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_1, 0)
}

func (s *ComparisonContext) NOT_EQ_2() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_2, 0)
}

func (s *ComparisonContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *ComparisonContext) IS() antlr.TerminalNode {
	return s.GetToken(Python3ParserIS, 0)
}

func (s *ComparisonContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comparison() (localctx IComparisonContext) {
	return p.comparison(0)
}

func (p *Python3Parser) comparison(_p int) (localctx IComparisonContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, Python3ParserRULE_comparison, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.expr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_comparison)
			p.SetState(682)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(698)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserLESS_THAN:
				{
					p.SetState(683)
					p.Match(Python3ParserLESS_THAN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserGREATER_THAN:
				{
					p.SetState(684)
					p.Match(Python3ParserGREATER_THAN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserEQUALS:
				{
					p.SetState(685)
					p.Match(Python3ParserEQUALS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserGT_EQ:
				{
					p.SetState(686)
					p.Match(Python3ParserGT_EQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserLT_EQ:
				{
					p.SetState(687)
					p.Match(Python3ParserLT_EQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserNOT_EQ_1:
				{
					p.SetState(688)
					p.Match(Python3ParserNOT_EQ_1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserNOT_EQ_2:
				{
					p.SetState(689)
					p.Match(Python3ParserNOT_EQ_2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserIN, Python3ParserNOT:
				p.SetState(691)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNOT {
					{
						p.SetState(690)

						var _m = p.Match(Python3ParserNOT)

						localctx.(*ComparisonContext).optional = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(693)
					p.Match(Python3ParserIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Python3ParserIS:
				{
					p.SetState(694)
					p.Match(Python3ParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(696)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNOT {
					{
						p.SetState(695)

						var _m = p.Match(Python3ParserNOT)

						localctx.(*ComparisonContext).optional = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(700)
				p.comparison(3)
			}

		}
		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	Atom() IAtomContext
	AWAIT() antlr.TerminalNode
	AllTrailer() []ITrailerContext
	Trailer(i int) ITrailerContext
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	ADD() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT_OP() antlr.TerminalNode
	POWER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	IDIV() antlr.TerminalNode
	AT() antlr.TerminalNode
	LEFT_SHIFT() antlr.TerminalNode
	RIGHT_SHIFT() antlr.TerminalNode
	AND_OP() antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR_OP() antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) GetOp() antlr.Token { return s.op }

func (s *ExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAWAIT, 0)
}

func (s *ExprContext) AllTrailer() []ITrailerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITrailerContext); ok {
			len++
		}
	}

	tst := make([]ITrailerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITrailerContext); ok {
			tst[i] = t.(ITrailerContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Trailer(i int) ITrailerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) ADD() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, 0)
}

func (s *ExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *ExprContext) NOT_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_OP, 0)
}

func (s *ExprContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *ExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ExprContext) DIV() antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV, 0)
}

func (s *ExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD, 0)
}

func (s *ExprContext) IDIV() antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV, 0)
}

func (s *ExprContext) AT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, 0)
}

func (s *ExprContext) LEFT_SHIFT() antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT, 0)
}

func (s *ExprContext) RIGHT_SHIFT() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT, 0)
}

func (s *ExprContext) AND_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_OP, 0)
}

func (s *ExprContext) XOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR, 0)
}

func (s *ExprContext) OR_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_OP, 0)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *Python3Parser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, Python3ParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserAWAIT {
			{
				p.SetState(707)
				p.Match(Python3ParserAWAIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(710)
			p.Atom()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(711)
					p.Trailer()
				}

			}
			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(717)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261007895663738880) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(718)
			p.expr(7)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(721)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(722)

					var _m = p.Match(Python3ParserPOWER)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(723)
					p.expr(8)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(724)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(725)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-44)) & ^0x3f) == 0 && ((int64(1)<<(_la-44))&16834561) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(726)
					p.expr(7)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(727)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(728)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == Python3ParserADD || _la == Python3ParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(729)
					p.expr(6)
				}

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(730)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(731)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(732)
					p.expr(5)
				}

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(733)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(734)

					var _m = p.Match(Python3ParserAND_OP)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(735)
					p.expr(4)
				}

			case 6:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(736)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(737)

					var _m = p.Match(Python3ParserXOR)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(738)
					p.expr(3)
				}

			case 7:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_expr)
				p.SetState(739)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(740)

					var _m = p.Match(Python3ParserOR_OP)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(741)
					p.expr(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Yield_expr() IYield_exprContext
	Testlist_comp() ITestlist_compContext
	OPEN_BRACKET() antlr.TerminalNode
	CLOSE_BRACKET() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	Dictorsetmaker() IDictorsetmakerContext
	AllREVERSE_QUOTE() []antlr.TerminalNode
	REVERSE_QUOTE(i int) antlr.TerminalNode
	Testlist() ITestlistContext
	COMMA() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode
	Name() INameContext
	PRINT() antlr.TerminalNode
	EXEC() antlr.TerminalNode
	Number() INumberContext
	MINUS() antlr.TerminalNode
	NONE() antlr.TerminalNode
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *AtomContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_compContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) OPEN_BRACKET() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACKET, 0)
}

func (s *AtomContext) CLOSE_BRACKET() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACKET, 0)
}

func (s *AtomContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACE, 0)
}

func (s *AtomContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACE, 0)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictorsetmakerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) AllREVERSE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserREVERSE_QUOTE)
}

func (s *AtomContext) REVERSE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserREVERSE_QUOTE, i)
}

func (s *AtomContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *AtomContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *AtomContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, 0)
}

func (s *AtomContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AtomContext) PRINT() antlr.TerminalNode {
	return s.GetToken(Python3ParserPRINT, 0)
}

func (s *AtomContext) EXEC() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXEC, 0)
}

func (s *AtomContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *AtomContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING, i)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python3ParserRULE_atom)
	var _la int

	var _alt int

	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(747)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(748)
				p.Yield_expr()
			}

		case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserSTAR, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
			{
				p.SetState(749)
				p.Testlist_comp()
			}

		case Python3ParserCLOSE_PAREN:

		default:
		}
		{
			p.SetState(752)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Match(Python3ParserOPEN_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261040812445138944) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(754)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(757)
			p.Match(Python3ParserCLOSE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(758)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261322287421849600) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(759)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(762)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserREVERSE_QUOTE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(763)
			p.Match(Python3ParserREVERSE_QUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)
			p.Testlist()
		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(765)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(768)
			p.Match(Python3ParserREVERSE_QUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserELLIPSIS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(770)
			p.Match(Python3ParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(771)
			p.Name()
		}

	case Python3ParserPRINT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(772)
			p.Match(Python3ParserPRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserEXEC:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(773)
			p.Match(Python3ParserEXEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserMINUS, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserMINUS {
			{
				p.SetState(774)
				p.Match(Python3ParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(777)
			p.Number()
		}

	case Python3ParserNONE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(778)
			p.Match(Python3ParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserSTRING:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(779)
					p.Match(Python3ParserSTRING)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(782)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllPOWER() []antlr.TerminalNode
	POWER(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Comp_for() IComp_forContext
	Testlist_comp() ITestlist_compContext

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
	return p
}

func InitEmptyDictorsetmakerContext(p *DictorsetmakerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *DictorsetmakerContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *DictorsetmakerContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserPOWER)
}

func (s *DictorsetmakerContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, i)
}

func (s *DictorsetmakerContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DictorsetmakerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *DictorsetmakerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) Testlist_comp() ITestlist_compContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_compContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDictorsetmaker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python3ParserRULE_dictorsetmaker)
	var _la int

	var _alt int

	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
			{
				p.SetState(786)
				p.Test()
			}
			{
				p.SetState(787)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(788)
				p.Test()
			}

		case Python3ParserPOWER:
			{
				p.SetState(790)
				p.Match(Python3ParserPOWER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(791)
				p.expr(0)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(794)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(801)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
					{
						p.SetState(795)
						p.Test()
					}
					{
						p.SetState(796)
						p.Match(Python3ParserCOLON)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(797)
						p.Test()
					}

				case Python3ParserPOWER:
					{
						p.SetState(799)
						p.Match(Python3ParserPOWER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(800)
						p.expr(0)
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(807)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(808)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.Test()
		}
		{
			p.SetState(812)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(813)
			p.Test()
		}
		{
			p.SetState(814)
			p.Comp_for()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(816)
			p.Testlist_comp()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	Comp_for() IComp_forContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
	return p
}

func InitEmptyTestlist_compContext(p *Testlist_compContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_compContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (s *Testlist_compContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTestlist_comp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python3ParserRULE_testlist_comp)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
		{
			p.SetState(819)
			p.Test()
		}

	case Python3ParserSTAR:
		{
			p.SetState(820)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR:
		{
			p.SetState(823)
			p.Comp_for()
		}

	case Python3ParserCOMMA, Python3ParserCLOSE_PAREN, Python3ParserCLOSE_BRACE, Python3ParserCLOSE_BRACKET:
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(824)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(827)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
					{
						p.SetState(825)
						p.Test()
					}

				case Python3ParserSTAR:
					{
						p.SetState(826)
						p.Star_expr()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(833)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(834)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
	return p
}

func InitEmptyTestlistContext(p *TestlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TestlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (s *TestlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTestlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python3ParserRULE_testlist)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Test()
	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(840)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(841)
				p.Test()
			}

		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(847)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	Dotted_name() IDotted_nameContext
	DOT() antlr.TerminalNode

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
	return p
}

func InitEmptyDotted_nameContext(p *Dotted_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_nameContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, 0)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (s *Dotted_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitDotted_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_name() (localctx IDotted_nameContext) {
	return p.dotted_name(0)
}

func (p *Python3Parser) dotted_name(_p int) (localctx IDotted_nameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDotted_nameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 88
	p.EnterRecursionRule(localctx, 88, Python3ParserRULE_dotted_name, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Name()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDotted_nameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Python3ParserRULE_dotted_name)
			p.SetState(853)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(854)
				p.Match(Python3ParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(855)
				p.Name()
			}

		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *NameContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *NameContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python3ParserRULE_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-39)) & ^0x3f) == 0 && ((int64(1)<<(_la-39))&144115188075855875) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Integer() IIntegerContext
	IMAG_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer() IIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *NumberContext) IMAG_NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMAG_NUMBER, 0)
}

func (s *NumberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserFLOAT_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python3ParserRULE_number)
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.Integer()
		}

	case Python3ParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Match(Python3ParserIMAG_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(865)
			p.Match(Python3ParserFLOAT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_INTEGER() antlr.TerminalNode
	OCT_INTEGER() antlr.TerminalNode
	HEX_INTEGER() antlr.TerminalNode
	BIN_INTEGER() antlr.TerminalNode

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_integer
	return p
}

func InitEmptyIntegerContext(p *IntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_integer
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserDECIMAL_INTEGER, 0)
}

func (s *IntegerContext) OCT_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserOCT_INTEGER, 0)
}

func (s *IntegerContext) HEX_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserHEX_INTEGER, 0)
}

func (s *IntegerContext) BIN_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserBIN_INTEGER, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitInteger(s)
	}
}

func (s *IntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python3ParserRULE_integer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Yield_arg() IYield_argContext

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
	return p
}

func InitEmptyYield_exprContext(p *Yield_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Python3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (s *Yield_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitYield_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python3ParserRULE_yield_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(Python3ParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094656) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
		{
			p.SetState(871)
			p.Yield_arg()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Test() ITestContext
	Testlist() ITestlistContext

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
	return p
}

func InitEmptyYield_argContext(p *Yield_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (s *Yield_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitYield_arg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python3ParserRULE_yield_arg)
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(874)
			p.Match(Python3ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Test()
		}

	case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Testlist()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Name() INameContext
	Arguments() IArgumentsContext

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
	return p
}

func InitEmptyTrailerContext(p *TrailerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) DOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, 0)
}

func (s *TrailerContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TrailerContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (s *TrailerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitTrailer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python3ParserRULE_trailer)
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(879)
			p.Match(Python3ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)
			p.Name()
		}
		p.SetState(882)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(881)
				p.Arguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(884)
			p.Arguments()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext
	OPEN_BRACKET() antlr.TerminalNode
	Subscriptlist() ISubscriptlistContext
	CLOSE_BRACKET() antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ArgumentsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ArgumentsContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ArgumentsContext) OPEN_BRACKET() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACKET, 0)
}

func (s *ArgumentsContext) Subscriptlist() ISubscriptlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *ArgumentsContext) CLOSE_BRACKET() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACKET, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python3ParserRULE_arguments)
	var _la int

	p.SetState(896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(887)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261322287421849600) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(888)
				p.Arglist()
			}

		}
		{
			p.SetState(891)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Match(Python3ParserOPEN_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(893)
			p.Subscriptlist()
		}
		{
			p.SetState(894)
			p.Match(Python3ParserCLOSE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
	return p
}

func InitEmptyArglistContext(p *ArglistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ArglistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArglist(s)
	}
}

func (s *ArglistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitArglist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python3ParserRULE_arglist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Argument()
	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(899)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(900)
				p.Argument()
			}

		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(906)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	Comp_for() IComp_forContext
	ASSIGN() antlr.TerminalNode
	POWER() antlr.TerminalNode
	STAR() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *ArgumentContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python3ParserRULE_argument)
	var _la int

	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNONE, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserAWAIT, Python3ParserPRINT, Python3ParserEXEC, Python3ParserTRUE, Python3ParserFALSE, Python3ParserELLIPSIS, Python3ParserREVERSE_QUOTE, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserSTRING, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserIMAG_NUMBER, Python3ParserFLOAT_NUMBER, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACE, Python3ParserOPEN_BRACKET, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Test()
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR:
			{
				p.SetState(910)
				p.Comp_for()
			}

		case Python3ParserASSIGN:
			{
				p.SetState(911)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(912)
				p.Test()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_PAREN:

		default:
		}

	case Python3ParserSTAR, Python3ParserPOWER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(915)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserSTAR || _la == Python3ParserPOWER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(916)
			p.Test()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubscript() []ISubscriptContext
	Subscript(i int) ISubscriptContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
	return p
}

func InitEmptySubscriptlistContext(p *SubscriptlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubscriptContext); ok {
			len++
		}
	}

	tst := make([]ISubscriptContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubscriptContext); ok {
			tst[i] = t.(ISubscriptContext)
			i++
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *SubscriptlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSubscriptlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python3ParserRULE_subscriptlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Subscript()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(920)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(921)
				p.Subscript()
			}

		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(927)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELLIPSIS() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	COLON() antlr.TerminalNode
	Sliceop() ISliceopContext

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript
	return p
}

func InitEmptySubscriptContext(p *SubscriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, 0)
}

func (s *SubscriptContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python3ParserRULE_subscript)
	var _la int

	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(930)
			p.Match(Python3ParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(931)
			p.Test()
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOLON {
			{
				p.SetState(932)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(934)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
				{
					p.SetState(933)
					p.Test()
				}

			}
			p.SetState(937)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOLON {
				{
					p.SetState(936)
					p.Sliceop()
				}

			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(941)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
			{
				p.SetState(942)
				p.Test()
			}

		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOLON {
			{
				p.SetState(945)
				p.Sliceop()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
	return p
}

func InitEmptySliceopContext(p *SliceopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SliceopContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (s *SliceopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitSliceop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python3ParserRULE_sliceop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1261023220259094528) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&11007) != 0) {
		{
			p.SetState(951)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Exprlist() IExprlistContext
	IN() antlr.TerminalNode
	Logical_test() ILogical_testContext
	Comp_iter() IComp_iterContext

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
	return p
}

func InitEmptyComp_forContext(p *Comp_forContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_forContext) Logical_test() ILogical_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogical_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (s *Comp_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitComp_for(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python3ParserRULE_comp_for)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(Python3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(955)
		p.Exprlist()
	}
	{
		p.SetState(956)
		p.Match(Python3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(957)
		p.logical_test(0)
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserIF || _la == Python3ParserFOR {
		{
			p.SetState(958)
			p.Comp_iter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comp_for() IComp_forContext
	IF() antlr.TerminalNode
	Test() ITestContext
	Comp_iter() IComp_iterContext

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
	return p
}

func InitEmptyComp_iterContext(p *Comp_iterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *Comp_iterContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Comp_iterContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (s *Comp_iterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3ParserVisitor:
		return t.VisitComp_iter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python3ParserRULE_comp_iter)
	var _la int

	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(961)
			p.Comp_for()
		}

	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(962)
			p.Match(Python3ParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(963)
			p.Test()
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserIF || _la == Python3ParserFOR {
			{
				p.SetState(964)
				p.Comp_iter()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Python3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 12:
		var t *Except_clauseContext = nil
		if localctx != nil {
			t = localctx.(*Except_clauseContext)
		}
		return p.Except_clause_Sempred(t, predIndex)

	case 22:
		var t *Small_stmtContext = nil
		if localctx != nil {
			t = localctx.(*Small_stmtContext)
		}
		return p.Small_stmt_Sempred(t, predIndex)

	case 25:
		var t *Assign_partContext = nil
		if localctx != nil {
			t = localctx.(*Assign_partContext)
		}
		return p.Assign_part_Sempred(t, predIndex)

	case 37:
		var t *Logical_testContext = nil
		if localctx != nil {
			t = localctx.(*Logical_testContext)
		}
		return p.Logical_test_Sempred(t, predIndex)

	case 38:
		var t *ComparisonContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonContext)
		}
		return p.Comparison_Sempred(t, predIndex)

	case 39:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 44:
		var t *Dotted_nameContext = nil
		if localctx != nil {
			t = localctx.(*Dotted_nameContext)
		}
		return p.Dotted_name_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Python3Parser) Except_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.CheckVersion(2)

	case 1:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Small_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.CheckVersion(2)

	case 3:
		return p.CheckVersion(2)

	case 4:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Assign_part_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Logical_test_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Comparison_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Dotted_name_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
