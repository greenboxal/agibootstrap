// Code generated from Python3.g4 by ANTLR 4.13.0. DO NOT EDIT.

package pyparser // Python3
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Python3Parser struct {
	*antlr.BaseParser
}

var Python3ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func python3ParserInit() {
	staticData := &Python3ParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'",
		"'as'", "'global'", "'nonlocal'", "'assert'", "'if'", "'elif'", "'else'",
		"'while'", "'for'", "'in'", "'try'", "'finally'", "'with'", "'except'",
		"'lambda'", "'or'", "'and'", "'not'", "'is'", "'None'", "'True'", "'False'",
		"'class'", "'yield'", "'del'", "'pass'", "'continue'", "'break'", "'async'",
		"'await'", "", "", "", "", "", "", "", "", "", "", "'.'", "'...'", "'*'",
		"'('", "')'", "','", "':'", "';'", "'**'", "'='", "'['", "']'", "'|'",
		"'^'", "'&'", "'<<'", "'>>'", "'+'", "'-'", "'/'", "'%'", "'//'", "'~'",
		"'{'", "'}'", "'<'", "'>'", "'=='", "'>='", "'<='", "'<>'", "'!='",
		"'@'", "'->'", "'+='", "'-='", "'*='", "'@='", "'/='", "'%='", "'&='",
		"'|='", "'^='", "'<<='", "'>>='", "'**='", "'//='",
	}
	staticData.SymbolicNames = []string{
		"", "STRING", "NUMBER", "INTEGER", "DEF", "RETURN", "RAISE", "FROM",
		"IMPORT", "AS", "GLOBAL", "NONLOCAL", "ASSERT", "IF", "ELIF", "ELSE",
		"WHILE", "FOR", "IN", "TRY", "FINALLY", "WITH", "EXCEPT", "LAMBDA",
		"OR", "AND", "NOT", "IS", "NONE", "TRUE", "FALSE", "CLASS", "YIELD",
		"DEL", "PASS", "CONTINUE", "BREAK", "ASYNC", "AWAIT", "NEWLINE", "NAME",
		"STRING_LITERAL", "BYTES_LITERAL", "DECIMAL_INTEGER", "OCT_INTEGER",
		"HEX_INTEGER", "BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", "DOT",
		"ELLIPSIS", "STAR", "OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", "SEMI_COLON",
		"POWER", "ASSIGN", "OPEN_BRACK", "CLOSE_BRACK", "OR_OP", "XOR", "AND_OP",
		"LEFT_SHIFT", "RIGHT_SHIFT", "ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP",
		"OPEN_BRACE", "CLOSE_BRACE", "LESS_THAN", "GREATER_THAN", "EQUALS",
		"GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", "AT", "ARROW", "ADD_ASSIGN",
		"SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN",
		"POWER_ASSIGN", "IDIV_ASSIGN", "SKIP_", "UNKNOWN_CHAR", "INDENT", "DEDENT",
	}
	staticData.RuleNames = []string{
		"single_input", "file_input", "eval_input", "decorator", "decorators",
		"decorated", "async_funcdef", "funcdef", "parameters", "typedargslist",
		"tfpdef", "varargslist", "vfpdef", "stmt", "simple_stmt", "small_stmt",
		"expr_stmt", "annassign", "testlist_star_expr", "augassign", "del_stmt",
		"pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt",
		"yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from",
		"import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names",
		"dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt",
		"async_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt",
		"with_item", "except_clause", "suite", "test", "test_nocond", "lambdef",
		"lambdef_nocond", "or_test", "and_test", "not_test", "comparison", "comp_op",
		"star_expr", "expr", "xor_expr", "and_expr", "shift_expr", "arith_expr",
		"term", "factor", "power", "atom_expr", "atom", "testlist_comp", "trailer",
		"subscriptlist", "subscript", "sliceop", "exprlist", "testlist", "dictorsetmaker",
		"classdef", "arglist", "argument", "comp_iter", "comp_for", "comp_if",
		"encoding_decl", "yield_expr", "yield_arg",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 99, 1104, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 178, 8, 0,
		1, 1, 1, 1, 5, 1, 182, 8, 1, 10, 1, 12, 1, 185, 9, 1, 1, 1, 1, 1, 1, 2,
		1, 2, 5, 2, 191, 8, 2, 10, 2, 12, 2, 194, 9, 2, 1, 2, 1, 2, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 202, 8, 3, 1, 3, 3, 3, 205, 8, 3, 1, 3, 1, 3, 1, 4, 4,
		4, 210, 8, 4, 11, 4, 12, 4, 211, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 218, 8,
		5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 228, 8, 7, 1,
		7, 1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 235, 8, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1,
		9, 3, 9, 242, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 248, 8, 9, 5, 9, 250,
		8, 9, 10, 9, 12, 9, 253, 9, 9, 1, 9, 1, 9, 1, 9, 3, 9, 258, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 264, 8, 9, 5, 9, 266, 8, 9, 10, 9, 12, 9, 269,
		9, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 275, 8, 9, 3, 9, 277, 8, 9, 3, 9, 279,
		8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 284, 8, 9, 3, 9, 286, 8, 9, 3, 9, 288, 8,
		9, 1, 9, 1, 9, 3, 9, 292, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 298, 8, 9,
		5, 9, 300, 8, 9, 10, 9, 12, 9, 303, 9, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		309, 8, 9, 3, 9, 311, 8, 9, 3, 9, 313, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 318,
		8, 9, 3, 9, 320, 8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 325, 8, 10, 1, 11, 1,
		11, 1, 11, 3, 11, 330, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 336, 8,
		11, 5, 11, 338, 8, 11, 10, 11, 12, 11, 341, 9, 11, 1, 11, 1, 11, 1, 11,
		3, 11, 346, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 352, 8, 11, 5, 11,
		354, 8, 11, 10, 11, 12, 11, 357, 9, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3,
		11, 363, 8, 11, 3, 11, 365, 8, 11, 3, 11, 367, 8, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 372, 8, 11, 3, 11, 374, 8, 11, 3, 11, 376, 8, 11, 1, 11, 1,
		11, 3, 11, 380, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 386, 8, 11, 5,
		11, 388, 8, 11, 10, 11, 12, 11, 391, 9, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		3, 11, 397, 8, 11, 3, 11, 399, 8, 11, 3, 11, 401, 8, 11, 1, 11, 1, 11,
		1, 11, 3, 11, 406, 8, 11, 3, 11, 408, 8, 11, 1, 12, 1, 12, 1, 13, 1, 13,
		3, 13, 414, 8, 13, 1, 14, 1, 14, 1, 14, 5, 14, 419, 8, 14, 10, 14, 12,
		14, 422, 9, 14, 1, 14, 3, 14, 425, 8, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 437, 8, 15, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 3, 16, 444, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 449,
		8, 16, 5, 16, 451, 8, 16, 10, 16, 12, 16, 454, 9, 16, 3, 16, 456, 8, 16,
		1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 462, 8, 17, 1, 18, 1, 18, 3, 18, 466,
		8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 471, 8, 18, 5, 18, 473, 8, 18, 10, 18,
		12, 18, 476, 9, 18, 1, 18, 3, 18, 479, 8, 18, 1, 19, 1, 19, 1, 20, 1, 20,
		1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 493, 8,
		22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 501, 8, 25, 1, 26,
		1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 509, 8, 27, 3, 27, 511, 8, 27,
		1, 28, 1, 28, 3, 28, 515, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 5,
		30, 522, 8, 30, 10, 30, 12, 30, 525, 9, 30, 1, 30, 1, 30, 4, 30, 529, 8,
		30, 11, 30, 12, 30, 530, 3, 30, 533, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 3, 30, 542, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 547,
		8, 31, 1, 32, 1, 32, 1, 32, 3, 32, 552, 8, 32, 1, 33, 1, 33, 1, 33, 5,
		33, 557, 8, 33, 10, 33, 12, 33, 560, 9, 33, 1, 33, 3, 33, 563, 8, 33, 1,
		34, 1, 34, 1, 34, 5, 34, 568, 8, 34, 10, 34, 12, 34, 571, 9, 34, 1, 35,
		1, 35, 1, 35, 5, 35, 576, 8, 35, 10, 35, 12, 35, 579, 9, 35, 1, 36, 1,
		36, 1, 36, 1, 36, 5, 36, 585, 8, 36, 10, 36, 12, 36, 588, 9, 36, 1, 37,
		1, 37, 1, 37, 1, 37, 5, 37, 594, 8, 37, 10, 37, 12, 37, 597, 9, 37, 1,
		38, 1, 38, 1, 38, 1, 38, 3, 38, 603, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 614, 8, 39, 1, 40, 1, 40, 1,
		40, 1, 40, 3, 40, 620, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 5, 41, 631, 8, 41, 10, 41, 12, 41, 634, 9, 41, 1,
		41, 1, 41, 1, 41, 3, 41, 639, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 3, 42, 648, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 3, 43, 659, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 4, 44, 668, 8, 44, 11, 44, 12, 44, 669, 1, 44, 1,
		44, 1, 44, 3, 44, 675, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 680, 8, 44, 1,
		44, 1, 44, 1, 44, 3, 44, 685, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45,
		691, 8, 45, 10, 45, 12, 45, 694, 9, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 46, 3, 46, 702, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 708, 8,
		47, 3, 47, 710, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 4, 48, 716, 8, 48, 11,
		48, 12, 48, 717, 1, 48, 1, 48, 3, 48, 722, 8, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 3, 49, 730, 8, 49, 1, 49, 3, 49, 733, 8, 49, 1, 50,
		1, 50, 3, 50, 737, 8, 50, 1, 51, 1, 51, 3, 51, 741, 8, 51, 1, 51, 1, 51,
		1, 51, 1, 52, 1, 52, 3, 52, 748, 8, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1,
		53, 1, 53, 5, 53, 756, 8, 53, 10, 53, 12, 53, 759, 9, 53, 1, 54, 1, 54,
		1, 54, 5, 54, 764, 8, 54, 10, 54, 12, 54, 767, 9, 54, 1, 55, 1, 55, 1,
		55, 3, 55, 772, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 5, 56, 778, 8, 56, 10,
		56, 12, 56, 781, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 796, 8, 57, 1, 58, 1,
		58, 1, 58, 1, 59, 1, 59, 1, 59, 5, 59, 804, 8, 59, 10, 59, 12, 59, 807,
		9, 59, 1, 60, 1, 60, 1, 60, 5, 60, 812, 8, 60, 10, 60, 12, 60, 815, 9,
		60, 1, 61, 1, 61, 1, 61, 5, 61, 820, 8, 61, 10, 61, 12, 61, 823, 9, 61,
		1, 62, 1, 62, 1, 62, 5, 62, 828, 8, 62, 10, 62, 12, 62, 831, 9, 62, 1,
		63, 1, 63, 1, 63, 5, 63, 836, 8, 63, 10, 63, 12, 63, 839, 9, 63, 1, 64,
		1, 64, 1, 64, 5, 64, 844, 8, 64, 10, 64, 12, 64, 847, 9, 64, 1, 65, 1,
		65, 1, 65, 3, 65, 852, 8, 65, 1, 66, 1, 66, 1, 66, 3, 66, 857, 8, 66, 1,
		67, 3, 67, 860, 8, 67, 1, 67, 1, 67, 5, 67, 864, 8, 67, 10, 67, 12, 67,
		867, 9, 67, 1, 68, 1, 68, 1, 68, 3, 68, 872, 8, 68, 1, 68, 1, 68, 1, 68,
		3, 68, 877, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 882, 8, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 4, 68, 888, 8, 68, 11, 68, 12, 68, 889, 1, 68, 1, 68, 1,
		68, 1, 68, 3, 68, 896, 8, 68, 1, 69, 1, 69, 3, 69, 900, 8, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 906, 8, 69, 5, 69, 908, 8, 69, 10, 69, 12, 69,
		911, 9, 69, 1, 69, 3, 69, 914, 8, 69, 3, 69, 916, 8, 69, 1, 70, 1, 70,
		3, 70, 920, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3,
		70, 929, 8, 70, 1, 71, 1, 71, 1, 71, 5, 71, 934, 8, 71, 10, 71, 12, 71,
		937, 9, 71, 1, 71, 3, 71, 940, 8, 71, 1, 72, 1, 72, 3, 72, 944, 8, 72,
		1, 72, 1, 72, 3, 72, 948, 8, 72, 1, 72, 3, 72, 951, 8, 72, 3, 72, 953,
		8, 72, 1, 73, 1, 73, 3, 73, 957, 8, 73, 1, 74, 1, 74, 3, 74, 961, 8, 74,
		1, 74, 1, 74, 1, 74, 3, 74, 966, 8, 74, 5, 74, 968, 8, 74, 10, 74, 12,
		74, 971, 9, 74, 1, 74, 3, 74, 974, 8, 74, 1, 75, 1, 75, 1, 75, 5, 75, 979,
		8, 75, 10, 75, 12, 75, 982, 9, 75, 1, 75, 3, 75, 985, 8, 75, 1, 76, 1,
		76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 993, 8, 76, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1003, 8, 76, 5, 76, 1005, 8,
		76, 10, 76, 12, 76, 1008, 9, 76, 1, 76, 3, 76, 1011, 8, 76, 3, 76, 1013,
		8, 76, 1, 76, 1, 76, 3, 76, 1017, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3,
		76, 1023, 8, 76, 5, 76, 1025, 8, 76, 10, 76, 12, 76, 1028, 9, 76, 1, 76,
		3, 76, 1031, 8, 76, 3, 76, 1033, 8, 76, 3, 76, 1035, 8, 76, 1, 77, 1, 77,
		1, 77, 1, 77, 3, 77, 1041, 8, 77, 1, 77, 3, 77, 1044, 8, 77, 1, 77, 1,
		77, 1, 77, 1, 78, 1, 78, 1, 78, 5, 78, 1052, 8, 78, 10, 78, 12, 78, 1055,
		9, 78, 1, 78, 3, 78, 1058, 8, 78, 1, 79, 1, 79, 3, 79, 1062, 8, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1072, 8, 79,
		1, 80, 1, 80, 3, 80, 1076, 8, 80, 1, 81, 3, 81, 1079, 8, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 1, 81, 3, 81, 1086, 8, 81, 1, 82, 1, 82, 1, 82, 3, 82,
		1091, 8, 82, 1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 1097, 8, 84, 1, 85, 1,
		85, 1, 85, 3, 85, 1102, 8, 85, 1, 85, 0, 0, 86, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
		148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 0, 6, 1, 0,
		83, 95, 1, 0, 49, 50, 1, 0, 64, 65, 1, 0, 66, 67, 3, 0, 51, 51, 68, 70,
		81, 81, 2, 0, 66, 67, 71, 71, 1229, 0, 177, 1, 0, 0, 0, 2, 183, 1, 0, 0,
		0, 4, 188, 1, 0, 0, 0, 6, 197, 1, 0, 0, 0, 8, 209, 1, 0, 0, 0, 10, 213,
		1, 0, 0, 0, 12, 219, 1, 0, 0, 0, 14, 222, 1, 0, 0, 0, 16, 232, 1, 0, 0,
		0, 18, 319, 1, 0, 0, 0, 20, 321, 1, 0, 0, 0, 22, 407, 1, 0, 0, 0, 24, 409,
		1, 0, 0, 0, 26, 413, 1, 0, 0, 0, 28, 415, 1, 0, 0, 0, 30, 436, 1, 0, 0,
		0, 32, 438, 1, 0, 0, 0, 34, 457, 1, 0, 0, 0, 36, 465, 1, 0, 0, 0, 38, 480,
		1, 0, 0, 0, 40, 482, 1, 0, 0, 0, 42, 485, 1, 0, 0, 0, 44, 492, 1, 0, 0,
		0, 46, 494, 1, 0, 0, 0, 48, 496, 1, 0, 0, 0, 50, 498, 1, 0, 0, 0, 52, 502,
		1, 0, 0, 0, 54, 504, 1, 0, 0, 0, 56, 514, 1, 0, 0, 0, 58, 516, 1, 0, 0,
		0, 60, 519, 1, 0, 0, 0, 62, 543, 1, 0, 0, 0, 64, 548, 1, 0, 0, 0, 66, 553,
		1, 0, 0, 0, 68, 564, 1, 0, 0, 0, 70, 572, 1, 0, 0, 0, 72, 580, 1, 0, 0,
		0, 74, 589, 1, 0, 0, 0, 76, 598, 1, 0, 0, 0, 78, 613, 1, 0, 0, 0, 80, 615,
		1, 0, 0, 0, 82, 621, 1, 0, 0, 0, 84, 640, 1, 0, 0, 0, 86, 649, 1, 0, 0,
		0, 88, 660, 1, 0, 0, 0, 90, 686, 1, 0, 0, 0, 92, 698, 1, 0, 0, 0, 94, 703,
		1, 0, 0, 0, 96, 721, 1, 0, 0, 0, 98, 732, 1, 0, 0, 0, 100, 736, 1, 0, 0,
		0, 102, 738, 1, 0, 0, 0, 104, 745, 1, 0, 0, 0, 106, 752, 1, 0, 0, 0, 108,
		760, 1, 0, 0, 0, 110, 771, 1, 0, 0, 0, 112, 773, 1, 0, 0, 0, 114, 795,
		1, 0, 0, 0, 116, 797, 1, 0, 0, 0, 118, 800, 1, 0, 0, 0, 120, 808, 1, 0,
		0, 0, 122, 816, 1, 0, 0, 0, 124, 824, 1, 0, 0, 0, 126, 832, 1, 0, 0, 0,
		128, 840, 1, 0, 0, 0, 130, 851, 1, 0, 0, 0, 132, 853, 1, 0, 0, 0, 134,
		859, 1, 0, 0, 0, 136, 895, 1, 0, 0, 0, 138, 899, 1, 0, 0, 0, 140, 928,
		1, 0, 0, 0, 142, 930, 1, 0, 0, 0, 144, 952, 1, 0, 0, 0, 146, 954, 1, 0,
		0, 0, 148, 960, 1, 0, 0, 0, 150, 975, 1, 0, 0, 0, 152, 1034, 1, 0, 0, 0,
		154, 1036, 1, 0, 0, 0, 156, 1048, 1, 0, 0, 0, 158, 1071, 1, 0, 0, 0, 160,
		1075, 1, 0, 0, 0, 162, 1078, 1, 0, 0, 0, 164, 1087, 1, 0, 0, 0, 166, 1092,
		1, 0, 0, 0, 168, 1094, 1, 0, 0, 0, 170, 1101, 1, 0, 0, 0, 172, 178, 5,
		39, 0, 0, 173, 178, 3, 28, 14, 0, 174, 175, 3, 78, 39, 0, 175, 176, 5,
		39, 0, 0, 176, 178, 1, 0, 0, 0, 177, 172, 1, 0, 0, 0, 177, 173, 1, 0, 0,
		0, 177, 174, 1, 0, 0, 0, 178, 1, 1, 0, 0, 0, 179, 182, 5, 39, 0, 0, 180,
		182, 3, 26, 13, 0, 181, 179, 1, 0, 0, 0, 181, 180, 1, 0, 0, 0, 182, 185,
		1, 0, 0, 0, 183, 181, 1, 0, 0, 0, 183, 184, 1, 0, 0, 0, 184, 186, 1, 0,
		0, 0, 185, 183, 1, 0, 0, 0, 186, 187, 5, 0, 0, 1, 187, 3, 1, 0, 0, 0, 188,
		192, 3, 150, 75, 0, 189, 191, 5, 39, 0, 0, 190, 189, 1, 0, 0, 0, 191, 194,
		1, 0, 0, 0, 192, 190, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 195, 1, 0,
		0, 0, 194, 192, 1, 0, 0, 0, 195, 196, 5, 0, 0, 1, 196, 5, 1, 0, 0, 0, 197,
		198, 5, 81, 0, 0, 198, 204, 3, 70, 35, 0, 199, 201, 5, 52, 0, 0, 200, 202,
		3, 156, 78, 0, 201, 200, 1, 0, 0, 0, 201, 202, 1, 0, 0, 0, 202, 203, 1,
		0, 0, 0, 203, 205, 5, 53, 0, 0, 204, 199, 1, 0, 0, 0, 204, 205, 1, 0, 0,
		0, 205, 206, 1, 0, 0, 0, 206, 207, 5, 39, 0, 0, 207, 7, 1, 0, 0, 0, 208,
		210, 3, 6, 3, 0, 209, 208, 1, 0, 0, 0, 210, 211, 1, 0, 0, 0, 211, 209,
		1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 9, 1, 0, 0, 0, 213, 217, 3, 8, 4,
		0, 214, 218, 3, 154, 77, 0, 215, 218, 3, 14, 7, 0, 216, 218, 3, 12, 6,
		0, 217, 214, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 217, 216, 1, 0, 0, 0, 218,
		11, 1, 0, 0, 0, 219, 220, 5, 37, 0, 0, 220, 221, 3, 14, 7, 0, 221, 13,
		1, 0, 0, 0, 222, 223, 5, 4, 0, 0, 223, 224, 5, 40, 0, 0, 224, 227, 3, 16,
		8, 0, 225, 226, 5, 82, 0, 0, 226, 228, 3, 98, 49, 0, 227, 225, 1, 0, 0,
		0, 227, 228, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 230, 5, 55, 0, 0, 230,
		231, 3, 96, 48, 0, 231, 15, 1, 0, 0, 0, 232, 234, 5, 52, 0, 0, 233, 235,
		3, 18, 9, 0, 234, 233, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 236, 1, 0,
		0, 0, 236, 237, 5, 53, 0, 0, 237, 17, 1, 0, 0, 0, 238, 241, 3, 20, 10,
		0, 239, 240, 5, 58, 0, 0, 240, 242, 3, 98, 49, 0, 241, 239, 1, 0, 0, 0,
		241, 242, 1, 0, 0, 0, 242, 251, 1, 0, 0, 0, 243, 244, 5, 54, 0, 0, 244,
		247, 3, 20, 10, 0, 245, 246, 5, 58, 0, 0, 246, 248, 3, 98, 49, 0, 247,
		245, 1, 0, 0, 0, 247, 248, 1, 0, 0, 0, 248, 250, 1, 0, 0, 0, 249, 243,
		1, 0, 0, 0, 250, 253, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 251, 252, 1, 0,
		0, 0, 252, 287, 1, 0, 0, 0, 253, 251, 1, 0, 0, 0, 254, 285, 5, 54, 0, 0,
		255, 257, 5, 51, 0, 0, 256, 258, 3, 20, 10, 0, 257, 256, 1, 0, 0, 0, 257,
		258, 1, 0, 0, 0, 258, 267, 1, 0, 0, 0, 259, 260, 5, 54, 0, 0, 260, 263,
		3, 20, 10, 0, 261, 262, 5, 58, 0, 0, 262, 264, 3, 98, 49, 0, 263, 261,
		1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 266, 1, 0, 0, 0, 265, 259, 1, 0,
		0, 0, 266, 269, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0,
		268, 278, 1, 0, 0, 0, 269, 267, 1, 0, 0, 0, 270, 276, 5, 54, 0, 0, 271,
		272, 5, 57, 0, 0, 272, 274, 3, 20, 10, 0, 273, 275, 5, 54, 0, 0, 274, 273,
		1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275, 277, 1, 0, 0, 0, 276, 271, 1, 0,
		0, 0, 276, 277, 1, 0, 0, 0, 277, 279, 1, 0, 0, 0, 278, 270, 1, 0, 0, 0,
		278, 279, 1, 0, 0, 0, 279, 286, 1, 0, 0, 0, 280, 281, 5, 57, 0, 0, 281,
		283, 3, 20, 10, 0, 282, 284, 5, 54, 0, 0, 283, 282, 1, 0, 0, 0, 283, 284,
		1, 0, 0, 0, 284, 286, 1, 0, 0, 0, 285, 255, 1, 0, 0, 0, 285, 280, 1, 0,
		0, 0, 285, 286, 1, 0, 0, 0, 286, 288, 1, 0, 0, 0, 287, 254, 1, 0, 0, 0,
		287, 288, 1, 0, 0, 0, 288, 320, 1, 0, 0, 0, 289, 291, 5, 51, 0, 0, 290,
		292, 3, 20, 10, 0, 291, 290, 1, 0, 0, 0, 291, 292, 1, 0, 0, 0, 292, 301,
		1, 0, 0, 0, 293, 294, 5, 54, 0, 0, 294, 297, 3, 20, 10, 0, 295, 296, 5,
		58, 0, 0, 296, 298, 3, 98, 49, 0, 297, 295, 1, 0, 0, 0, 297, 298, 1, 0,
		0, 0, 298, 300, 1, 0, 0, 0, 299, 293, 1, 0, 0, 0, 300, 303, 1, 0, 0, 0,
		301, 299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302, 312, 1, 0, 0, 0, 303,
		301, 1, 0, 0, 0, 304, 310, 5, 54, 0, 0, 305, 306, 5, 57, 0, 0, 306, 308,
		3, 20, 10, 0, 307, 309, 5, 54, 0, 0, 308, 307, 1, 0, 0, 0, 308, 309, 1,
		0, 0, 0, 309, 311, 1, 0, 0, 0, 310, 305, 1, 0, 0, 0, 310, 311, 1, 0, 0,
		0, 311, 313, 1, 0, 0, 0, 312, 304, 1, 0, 0, 0, 312, 313, 1, 0, 0, 0, 313,
		320, 1, 0, 0, 0, 314, 315, 5, 57, 0, 0, 315, 317, 3, 20, 10, 0, 316, 318,
		5, 54, 0, 0, 317, 316, 1, 0, 0, 0, 317, 318, 1, 0, 0, 0, 318, 320, 1, 0,
		0, 0, 319, 238, 1, 0, 0, 0, 319, 289, 1, 0, 0, 0, 319, 314, 1, 0, 0, 0,
		320, 19, 1, 0, 0, 0, 321, 324, 5, 40, 0, 0, 322, 323, 5, 55, 0, 0, 323,
		325, 3, 98, 49, 0, 324, 322, 1, 0, 0, 0, 324, 325, 1, 0, 0, 0, 325, 21,
		1, 0, 0, 0, 326, 329, 3, 24, 12, 0, 327, 328, 5, 58, 0, 0, 328, 330, 3,
		98, 49, 0, 329, 327, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 339, 1, 0,
		0, 0, 331, 332, 5, 54, 0, 0, 332, 335, 3, 24, 12, 0, 333, 334, 5, 58, 0,
		0, 334, 336, 3, 98, 49, 0, 335, 333, 1, 0, 0, 0, 335, 336, 1, 0, 0, 0,
		336, 338, 1, 0, 0, 0, 337, 331, 1, 0, 0, 0, 338, 341, 1, 0, 0, 0, 339,
		337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0, 340, 375, 1, 0, 0, 0, 341, 339,
		1, 0, 0, 0, 342, 373, 5, 54, 0, 0, 343, 345, 5, 51, 0, 0, 344, 346, 3,
		24, 12, 0, 345, 344, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 355, 1, 0,
		0, 0, 347, 348, 5, 54, 0, 0, 348, 351, 3, 24, 12, 0, 349, 350, 5, 58, 0,
		0, 350, 352, 3, 98, 49, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0,
		352, 354, 1, 0, 0, 0, 353, 347, 1, 0, 0, 0, 354, 357, 1, 0, 0, 0, 355,
		353, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 366, 1, 0, 0, 0, 357, 355,
		1, 0, 0, 0, 358, 364, 5, 54, 0, 0, 359, 360, 5, 57, 0, 0, 360, 362, 3,
		24, 12, 0, 361, 363, 5, 54, 0, 0, 362, 361, 1, 0, 0, 0, 362, 363, 1, 0,
		0, 0, 363, 365, 1, 0, 0, 0, 364, 359, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0,
		365, 367, 1, 0, 0, 0, 366, 358, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367,
		374, 1, 0, 0, 0, 368, 369, 5, 57, 0, 0, 369, 371, 3, 24, 12, 0, 370, 372,
		5, 54, 0, 0, 371, 370, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 374, 1, 0,
		0, 0, 373, 343, 1, 0, 0, 0, 373, 368, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0,
		374, 376, 1, 0, 0, 0, 375, 342, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376,
		408, 1, 0, 0, 0, 377, 379, 5, 51, 0, 0, 378, 380, 3, 24, 12, 0, 379, 378,
		1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 389, 1, 0, 0, 0, 381, 382, 5, 54,
		0, 0, 382, 385, 3, 24, 12, 0, 383, 384, 5, 58, 0, 0, 384, 386, 3, 98, 49,
		0, 385, 383, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 388, 1, 0, 0, 0, 387,
		381, 1, 0, 0, 0, 388, 391, 1, 0, 0, 0, 389, 387, 1, 0, 0, 0, 389, 390,
		1, 0, 0, 0, 390, 400, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 392, 398, 5, 54,
		0, 0, 393, 394, 5, 57, 0, 0, 394, 396, 3, 24, 12, 0, 395, 397, 5, 54, 0,
		0, 396, 395, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 399, 1, 0, 0, 0, 398,
		393, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 401, 1, 0, 0, 0, 400, 392,
		1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 408, 1, 0, 0, 0, 402, 403, 5, 57,
		0, 0, 403, 405, 3, 24, 12, 0, 404, 406, 5, 54, 0, 0, 405, 404, 1, 0, 0,
		0, 405, 406, 1, 0, 0, 0, 406, 408, 1, 0, 0, 0, 407, 326, 1, 0, 0, 0, 407,
		377, 1, 0, 0, 0, 407, 402, 1, 0, 0, 0, 408, 23, 1, 0, 0, 0, 409, 410, 5,
		40, 0, 0, 410, 25, 1, 0, 0, 0, 411, 414, 3, 28, 14, 0, 412, 414, 3, 78,
		39, 0, 413, 411, 1, 0, 0, 0, 413, 412, 1, 0, 0, 0, 414, 27, 1, 0, 0, 0,
		415, 420, 3, 30, 15, 0, 416, 417, 5, 56, 0, 0, 417, 419, 3, 30, 15, 0,
		418, 416, 1, 0, 0, 0, 419, 422, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 420,
		421, 1, 0, 0, 0, 421, 424, 1, 0, 0, 0, 422, 420, 1, 0, 0, 0, 423, 425,
		5, 56, 0, 0, 424, 423, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 426, 1, 0,
		0, 0, 426, 427, 5, 39, 0, 0, 427, 29, 1, 0, 0, 0, 428, 437, 3, 32, 16,
		0, 429, 437, 3, 40, 20, 0, 430, 437, 3, 42, 21, 0, 431, 437, 3, 44, 22,
		0, 432, 437, 3, 56, 28, 0, 433, 437, 3, 72, 36, 0, 434, 437, 3, 74, 37,
		0, 435, 437, 3, 76, 38, 0, 436, 428, 1, 0, 0, 0, 436, 429, 1, 0, 0, 0,
		436, 430, 1, 0, 0, 0, 436, 431, 1, 0, 0, 0, 436, 432, 1, 0, 0, 0, 436,
		433, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 436, 435, 1, 0, 0, 0, 437, 31, 1,
		0, 0, 0, 438, 455, 3, 36, 18, 0, 439, 456, 3, 34, 17, 0, 440, 443, 3, 38,
		19, 0, 441, 444, 3, 168, 84, 0, 442, 444, 3, 150, 75, 0, 443, 441, 1, 0,
		0, 0, 443, 442, 1, 0, 0, 0, 444, 456, 1, 0, 0, 0, 445, 448, 5, 58, 0, 0,
		446, 449, 3, 168, 84, 0, 447, 449, 3, 36, 18, 0, 448, 446, 1, 0, 0, 0,
		448, 447, 1, 0, 0, 0, 449, 451, 1, 0, 0, 0, 450, 445, 1, 0, 0, 0, 451,
		454, 1, 0, 0, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 456,
		1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 455, 439, 1, 0, 0, 0, 455, 440, 1, 0,
		0, 0, 455, 452, 1, 0, 0, 0, 456, 33, 1, 0, 0, 0, 457, 458, 5, 55, 0, 0,
		458, 461, 3, 98, 49, 0, 459, 460, 5, 58, 0, 0, 460, 462, 3, 98, 49, 0,
		461, 459, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 35, 1, 0, 0, 0, 463, 466,
		3, 98, 49, 0, 464, 466, 3, 116, 58, 0, 465, 463, 1, 0, 0, 0, 465, 464,
		1, 0, 0, 0, 466, 474, 1, 0, 0, 0, 467, 470, 5, 54, 0, 0, 468, 471, 3, 98,
		49, 0, 469, 471, 3, 116, 58, 0, 470, 468, 1, 0, 0, 0, 470, 469, 1, 0, 0,
		0, 471, 473, 1, 0, 0, 0, 472, 467, 1, 0, 0, 0, 473, 476, 1, 0, 0, 0, 474,
		472, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 478, 1, 0, 0, 0, 476, 474,
		1, 0, 0, 0, 477, 479, 5, 54, 0, 0, 478, 477, 1, 0, 0, 0, 478, 479, 1, 0,
		0, 0, 479, 37, 1, 0, 0, 0, 480, 481, 7, 0, 0, 0, 481, 39, 1, 0, 0, 0, 482,
		483, 5, 33, 0, 0, 483, 484, 3, 148, 74, 0, 484, 41, 1, 0, 0, 0, 485, 486,
		5, 34, 0, 0, 486, 43, 1, 0, 0, 0, 487, 493, 3, 46, 23, 0, 488, 493, 3,
		48, 24, 0, 489, 493, 3, 50, 25, 0, 490, 493, 3, 54, 27, 0, 491, 493, 3,
		52, 26, 0, 492, 487, 1, 0, 0, 0, 492, 488, 1, 0, 0, 0, 492, 489, 1, 0,
		0, 0, 492, 490, 1, 0, 0, 0, 492, 491, 1, 0, 0, 0, 493, 45, 1, 0, 0, 0,
		494, 495, 5, 36, 0, 0, 495, 47, 1, 0, 0, 0, 496, 497, 5, 35, 0, 0, 497,
		49, 1, 0, 0, 0, 498, 500, 5, 5, 0, 0, 499, 501, 3, 150, 75, 0, 500, 499,
		1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 51, 1, 0, 0, 0, 502, 503, 3, 168,
		84, 0, 503, 53, 1, 0, 0, 0, 504, 510, 5, 6, 0, 0, 505, 508, 3, 98, 49,
		0, 506, 507, 5, 7, 0, 0, 507, 509, 3, 98, 49, 0, 508, 506, 1, 0, 0, 0,
		508, 509, 1, 0, 0, 0, 509, 511, 1, 0, 0, 0, 510, 505, 1, 0, 0, 0, 510,
		511, 1, 0, 0, 0, 511, 55, 1, 0, 0, 0, 512, 515, 3, 58, 29, 0, 513, 515,
		3, 60, 30, 0, 514, 512, 1, 0, 0, 0, 514, 513, 1, 0, 0, 0, 515, 57, 1, 0,
		0, 0, 516, 517, 5, 8, 0, 0, 517, 518, 3, 68, 34, 0, 518, 59, 1, 0, 0, 0,
		519, 532, 5, 7, 0, 0, 520, 522, 7, 1, 0, 0, 521, 520, 1, 0, 0, 0, 522,
		525, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 526,
		1, 0, 0, 0, 525, 523, 1, 0, 0, 0, 526, 533, 3, 70, 35, 0, 527, 529, 7,
		1, 0, 0, 528, 527, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 528, 1, 0, 0,
		0, 530, 531, 1, 0, 0, 0, 531, 533, 1, 0, 0, 0, 532, 523, 1, 0, 0, 0, 532,
		528, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 541, 5, 8, 0, 0, 535, 542,
		5, 51, 0, 0, 536, 537, 5, 52, 0, 0, 537, 538, 3, 66, 33, 0, 538, 539, 5,
		53, 0, 0, 539, 542, 1, 0, 0, 0, 540, 542, 3, 66, 33, 0, 541, 535, 1, 0,
		0, 0, 541, 536, 1, 0, 0, 0, 541, 540, 1, 0, 0, 0, 542, 61, 1, 0, 0, 0,
		543, 546, 5, 40, 0, 0, 544, 545, 5, 9, 0, 0, 545, 547, 5, 40, 0, 0, 546,
		544, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 63, 1, 0, 0, 0, 548, 551, 3,
		70, 35, 0, 549, 550, 5, 9, 0, 0, 550, 552, 5, 40, 0, 0, 551, 549, 1, 0,
		0, 0, 551, 552, 1, 0, 0, 0, 552, 65, 1, 0, 0, 0, 553, 558, 3, 62, 31, 0,
		554, 555, 5, 54, 0, 0, 555, 557, 3, 62, 31, 0, 556, 554, 1, 0, 0, 0, 557,
		560, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 562,
		1, 0, 0, 0, 560, 558, 1, 0, 0, 0, 561, 563, 5, 54, 0, 0, 562, 561, 1, 0,
		0, 0, 562, 563, 1, 0, 0, 0, 563, 67, 1, 0, 0, 0, 564, 569, 3, 64, 32, 0,
		565, 566, 5, 54, 0, 0, 566, 568, 3, 64, 32, 0, 567, 565, 1, 0, 0, 0, 568,
		571, 1, 0, 0, 0, 569, 567, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 69, 1,
		0, 0, 0, 571, 569, 1, 0, 0, 0, 572, 577, 5, 40, 0, 0, 573, 574, 5, 49,
		0, 0, 574, 576, 5, 40, 0, 0, 575, 573, 1, 0, 0, 0, 576, 579, 1, 0, 0, 0,
		577, 575, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 71, 1, 0, 0, 0, 579, 577,
		1, 0, 0, 0, 580, 581, 5, 10, 0, 0, 581, 586, 5, 40, 0, 0, 582, 583, 5,
		54, 0, 0, 583, 585, 5, 40, 0, 0, 584, 582, 1, 0, 0, 0, 585, 588, 1, 0,
		0, 0, 586, 584, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 73, 1, 0, 0, 0,
		588, 586, 1, 0, 0, 0, 589, 590, 5, 11, 0, 0, 590, 595, 5, 40, 0, 0, 591,
		592, 5, 54, 0, 0, 592, 594, 5, 40, 0, 0, 593, 591, 1, 0, 0, 0, 594, 597,
		1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 75, 1, 0,
		0, 0, 597, 595, 1, 0, 0, 0, 598, 599, 5, 12, 0, 0, 599, 602, 3, 98, 49,
		0, 600, 601, 5, 54, 0, 0, 601, 603, 3, 98, 49, 0, 602, 600, 1, 0, 0, 0,
		602, 603, 1, 0, 0, 0, 603, 77, 1, 0, 0, 0, 604, 614, 3, 82, 41, 0, 605,
		614, 3, 84, 42, 0, 606, 614, 3, 86, 43, 0, 607, 614, 3, 88, 44, 0, 608,
		614, 3, 90, 45, 0, 609, 614, 3, 14, 7, 0, 610, 614, 3, 154, 77, 0, 611,
		614, 3, 10, 5, 0, 612, 614, 3, 80, 40, 0, 613, 604, 1, 0, 0, 0, 613, 605,
		1, 0, 0, 0, 613, 606, 1, 0, 0, 0, 613, 607, 1, 0, 0, 0, 613, 608, 1, 0,
		0, 0, 613, 609, 1, 0, 0, 0, 613, 610, 1, 0, 0, 0, 613, 611, 1, 0, 0, 0,
		613, 612, 1, 0, 0, 0, 614, 79, 1, 0, 0, 0, 615, 619, 5, 37, 0, 0, 616,
		620, 3, 14, 7, 0, 617, 620, 3, 90, 45, 0, 618, 620, 3, 86, 43, 0, 619,
		616, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 619, 618, 1, 0, 0, 0, 620, 81, 1,
		0, 0, 0, 621, 622, 5, 13, 0, 0, 622, 623, 3, 98, 49, 0, 623, 624, 5, 55,
		0, 0, 624, 632, 3, 96, 48, 0, 625, 626, 5, 14, 0, 0, 626, 627, 3, 98, 49,
		0, 627, 628, 5, 55, 0, 0, 628, 629, 3, 96, 48, 0, 629, 631, 1, 0, 0, 0,
		630, 625, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 632,
		633, 1, 0, 0, 0, 633, 638, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635, 636,
		5, 15, 0, 0, 636, 637, 5, 55, 0, 0, 637, 639, 3, 96, 48, 0, 638, 635, 1,
		0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 83, 1, 0, 0, 0, 640, 641, 5, 16, 0,
		0, 641, 642, 3, 98, 49, 0, 642, 643, 5, 55, 0, 0, 643, 647, 3, 96, 48,
		0, 644, 645, 5, 15, 0, 0, 645, 646, 5, 55, 0, 0, 646, 648, 3, 96, 48, 0,
		647, 644, 1, 0, 0, 0, 647, 648, 1, 0, 0, 0, 648, 85, 1, 0, 0, 0, 649, 650,
		5, 17, 0, 0, 650, 651, 3, 148, 74, 0, 651, 652, 5, 18, 0, 0, 652, 653,
		3, 150, 75, 0, 653, 654, 5, 55, 0, 0, 654, 658, 3, 96, 48, 0, 655, 656,
		5, 15, 0, 0, 656, 657, 5, 55, 0, 0, 657, 659, 3, 96, 48, 0, 658, 655, 1,
		0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 87, 1, 0, 0, 0, 660, 661, 5, 19, 0,
		0, 661, 662, 5, 55, 0, 0, 662, 684, 3, 96, 48, 0, 663, 664, 3, 94, 47,
		0, 664, 665, 5, 55, 0, 0, 665, 666, 3, 96, 48, 0, 666, 668, 1, 0, 0, 0,
		667, 663, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 669,
		670, 1, 0, 0, 0, 670, 674, 1, 0, 0, 0, 671, 672, 5, 15, 0, 0, 672, 673,
		5, 55, 0, 0, 673, 675, 3, 96, 48, 0, 674, 671, 1, 0, 0, 0, 674, 675, 1,
		0, 0, 0, 675, 679, 1, 0, 0, 0, 676, 677, 5, 20, 0, 0, 677, 678, 5, 55,
		0, 0, 678, 680, 3, 96, 48, 0, 679, 676, 1, 0, 0, 0, 679, 680, 1, 0, 0,
		0, 680, 685, 1, 0, 0, 0, 681, 682, 5, 20, 0, 0, 682, 683, 5, 55, 0, 0,
		683, 685, 3, 96, 48, 0, 684, 667, 1, 0, 0, 0, 684, 681, 1, 0, 0, 0, 685,
		89, 1, 0, 0, 0, 686, 687, 5, 21, 0, 0, 687, 692, 3, 92, 46, 0, 688, 689,
		5, 54, 0, 0, 689, 691, 3, 92, 46, 0, 690, 688, 1, 0, 0, 0, 691, 694, 1,
		0, 0, 0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 695, 1, 0, 0,
		0, 694, 692, 1, 0, 0, 0, 695, 696, 5, 55, 0, 0, 696, 697, 3, 96, 48, 0,
		697, 91, 1, 0, 0, 0, 698, 701, 3, 98, 49, 0, 699, 700, 5, 9, 0, 0, 700,
		702, 3, 118, 59, 0, 701, 699, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 93,
		1, 0, 0, 0, 703, 709, 5, 22, 0, 0, 704, 707, 3, 98, 49, 0, 705, 706, 5,
		9, 0, 0, 706, 708, 5, 40, 0, 0, 707, 705, 1, 0, 0, 0, 707, 708, 1, 0, 0,
		0, 708, 710, 1, 0, 0, 0, 709, 704, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710,
		95, 1, 0, 0, 0, 711, 722, 3, 28, 14, 0, 712, 713, 5, 39, 0, 0, 713, 715,
		5, 98, 0, 0, 714, 716, 3, 26, 13, 0, 715, 714, 1, 0, 0, 0, 716, 717, 1,
		0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 719, 1, 0, 0,
		0, 719, 720, 5, 99, 0, 0, 720, 722, 1, 0, 0, 0, 721, 711, 1, 0, 0, 0, 721,
		712, 1, 0, 0, 0, 722, 97, 1, 0, 0, 0, 723, 729, 3, 106, 53, 0, 724, 725,
		5, 13, 0, 0, 725, 726, 3, 106, 53, 0, 726, 727, 5, 15, 0, 0, 727, 728,
		3, 98, 49, 0, 728, 730, 1, 0, 0, 0, 729, 724, 1, 0, 0, 0, 729, 730, 1,
		0, 0, 0, 730, 733, 1, 0, 0, 0, 731, 733, 3, 102, 51, 0, 732, 723, 1, 0,
		0, 0, 732, 731, 1, 0, 0, 0, 733, 99, 1, 0, 0, 0, 734, 737, 3, 106, 53,
		0, 735, 737, 3, 104, 52, 0, 736, 734, 1, 0, 0, 0, 736, 735, 1, 0, 0, 0,
		737, 101, 1, 0, 0, 0, 738, 740, 5, 23, 0, 0, 739, 741, 3, 22, 11, 0, 740,
		739, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 743,
		5, 55, 0, 0, 743, 744, 3, 98, 49, 0, 744, 103, 1, 0, 0, 0, 745, 747, 5,
		23, 0, 0, 746, 748, 3, 22, 11, 0, 747, 746, 1, 0, 0, 0, 747, 748, 1, 0,
		0, 0, 748, 749, 1, 0, 0, 0, 749, 750, 5, 55, 0, 0, 750, 751, 3, 100, 50,
		0, 751, 105, 1, 0, 0, 0, 752, 757, 3, 108, 54, 0, 753, 754, 5, 24, 0, 0,
		754, 756, 3, 108, 54, 0, 755, 753, 1, 0, 0, 0, 756, 759, 1, 0, 0, 0, 757,
		755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 107, 1, 0, 0, 0, 759, 757,
		1, 0, 0, 0, 760, 765, 3, 110, 55, 0, 761, 762, 5, 25, 0, 0, 762, 764, 3,
		110, 55, 0, 763, 761, 1, 0, 0, 0, 764, 767, 1, 0, 0, 0, 765, 763, 1, 0,
		0, 0, 765, 766, 1, 0, 0, 0, 766, 109, 1, 0, 0, 0, 767, 765, 1, 0, 0, 0,
		768, 769, 5, 26, 0, 0, 769, 772, 3, 110, 55, 0, 770, 772, 3, 112, 56, 0,
		771, 768, 1, 0, 0, 0, 771, 770, 1, 0, 0, 0, 772, 111, 1, 0, 0, 0, 773,
		779, 3, 118, 59, 0, 774, 775, 3, 114, 57, 0, 775, 776, 3, 118, 59, 0, 776,
		778, 1, 0, 0, 0, 777, 774, 1, 0, 0, 0, 778, 781, 1, 0, 0, 0, 779, 777,
		1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 113, 1, 0, 0, 0, 781, 779, 1, 0,
		0, 0, 782, 796, 5, 74, 0, 0, 783, 796, 5, 75, 0, 0, 784, 796, 5, 76, 0,
		0, 785, 796, 5, 77, 0, 0, 786, 796, 5, 78, 0, 0, 787, 796, 5, 79, 0, 0,
		788, 796, 5, 80, 0, 0, 789, 796, 5, 18, 0, 0, 790, 791, 5, 26, 0, 0, 791,
		796, 5, 18, 0, 0, 792, 796, 5, 27, 0, 0, 793, 794, 5, 27, 0, 0, 794, 796,
		5, 26, 0, 0, 795, 782, 1, 0, 0, 0, 795, 783, 1, 0, 0, 0, 795, 784, 1, 0,
		0, 0, 795, 785, 1, 0, 0, 0, 795, 786, 1, 0, 0, 0, 795, 787, 1, 0, 0, 0,
		795, 788, 1, 0, 0, 0, 795, 789, 1, 0, 0, 0, 795, 790, 1, 0, 0, 0, 795,
		792, 1, 0, 0, 0, 795, 793, 1, 0, 0, 0, 796, 115, 1, 0, 0, 0, 797, 798,
		5, 51, 0, 0, 798, 799, 3, 118, 59, 0, 799, 117, 1, 0, 0, 0, 800, 805, 3,
		120, 60, 0, 801, 802, 5, 61, 0, 0, 802, 804, 3, 120, 60, 0, 803, 801, 1,
		0, 0, 0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0,
		0, 806, 119, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 813, 3, 122, 61, 0,
		809, 810, 5, 62, 0, 0, 810, 812, 3, 122, 61, 0, 811, 809, 1, 0, 0, 0, 812,
		815, 1, 0, 0, 0, 813, 811, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 121,
		1, 0, 0, 0, 815, 813, 1, 0, 0, 0, 816, 821, 3, 124, 62, 0, 817, 818, 5,
		63, 0, 0, 818, 820, 3, 124, 62, 0, 819, 817, 1, 0, 0, 0, 820, 823, 1, 0,
		0, 0, 821, 819, 1, 0, 0, 0, 821, 822, 1, 0, 0, 0, 822, 123, 1, 0, 0, 0,
		823, 821, 1, 0, 0, 0, 824, 829, 3, 126, 63, 0, 825, 826, 7, 2, 0, 0, 826,
		828, 3, 126, 63, 0, 827, 825, 1, 0, 0, 0, 828, 831, 1, 0, 0, 0, 829, 827,
		1, 0, 0, 0, 829, 830, 1, 0, 0, 0, 830, 125, 1, 0, 0, 0, 831, 829, 1, 0,
		0, 0, 832, 837, 3, 128, 64, 0, 833, 834, 7, 3, 0, 0, 834, 836, 3, 128,
		64, 0, 835, 833, 1, 0, 0, 0, 836, 839, 1, 0, 0, 0, 837, 835, 1, 0, 0, 0,
		837, 838, 1, 0, 0, 0, 838, 127, 1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 840,
		845, 3, 130, 65, 0, 841, 842, 7, 4, 0, 0, 842, 844, 3, 130, 65, 0, 843,
		841, 1, 0, 0, 0, 844, 847, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 845, 846,
		1, 0, 0, 0, 846, 129, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 848, 849, 7, 5,
		0, 0, 849, 852, 3, 130, 65, 0, 850, 852, 3, 132, 66, 0, 851, 848, 1, 0,
		0, 0, 851, 850, 1, 0, 0, 0, 852, 131, 1, 0, 0, 0, 853, 856, 3, 134, 67,
		0, 854, 855, 5, 57, 0, 0, 855, 857, 3, 130, 65, 0, 856, 854, 1, 0, 0, 0,
		856, 857, 1, 0, 0, 0, 857, 133, 1, 0, 0, 0, 858, 860, 5, 38, 0, 0, 859,
		858, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 865,
		3, 136, 68, 0, 862, 864, 3, 140, 70, 0, 863, 862, 1, 0, 0, 0, 864, 867,
		1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 135, 1, 0,
		0, 0, 867, 865, 1, 0, 0, 0, 868, 871, 5, 52, 0, 0, 869, 872, 3, 168, 84,
		0, 870, 872, 3, 138, 69, 0, 871, 869, 1, 0, 0, 0, 871, 870, 1, 0, 0, 0,
		871, 872, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 896, 5, 53, 0, 0, 874,
		876, 5, 59, 0, 0, 875, 877, 3, 138, 69, 0, 876, 875, 1, 0, 0, 0, 876, 877,
		1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 896, 5, 60, 0, 0, 879, 881, 5, 72,
		0, 0, 880, 882, 3, 152, 76, 0, 881, 880, 1, 0, 0, 0, 881, 882, 1, 0, 0,
		0, 882, 883, 1, 0, 0, 0, 883, 896, 5, 73, 0, 0, 884, 896, 5, 40, 0, 0,
		885, 896, 5, 2, 0, 0, 886, 888, 5, 1, 0, 0, 887, 886, 1, 0, 0, 0, 888,
		889, 1, 0, 0, 0, 889, 887, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 896,
		1, 0, 0, 0, 891, 896, 5, 50, 0, 0, 892, 896, 5, 28, 0, 0, 893, 896, 5,
		29, 0, 0, 894, 896, 5, 30, 0, 0, 895, 868, 1, 0, 0, 0, 895, 874, 1, 0,
		0, 0, 895, 879, 1, 0, 0, 0, 895, 884, 1, 0, 0, 0, 895, 885, 1, 0, 0, 0,
		895, 887, 1, 0, 0, 0, 895, 891, 1, 0, 0, 0, 895, 892, 1, 0, 0, 0, 895,
		893, 1, 0, 0, 0, 895, 894, 1, 0, 0, 0, 896, 137, 1, 0, 0, 0, 897, 900,
		3, 98, 49, 0, 898, 900, 3, 116, 58, 0, 899, 897, 1, 0, 0, 0, 899, 898,
		1, 0, 0, 0, 900, 915, 1, 0, 0, 0, 901, 916, 3, 162, 81, 0, 902, 905, 5,
		54, 0, 0, 903, 906, 3, 98, 49, 0, 904, 906, 3, 116, 58, 0, 905, 903, 1,
		0, 0, 0, 905, 904, 1, 0, 0, 0, 906, 908, 1, 0, 0, 0, 907, 902, 1, 0, 0,
		0, 908, 911, 1, 0, 0, 0, 909, 907, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910,
		913, 1, 0, 0, 0, 911, 909, 1, 0, 0, 0, 912, 914, 5, 54, 0, 0, 913, 912,
		1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 916, 1, 0, 0, 0, 915, 901, 1, 0,
		0, 0, 915, 909, 1, 0, 0, 0, 916, 139, 1, 0, 0, 0, 917, 919, 5, 52, 0, 0,
		918, 920, 3, 156, 78, 0, 919, 918, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920,
		921, 1, 0, 0, 0, 921, 929, 5, 53, 0, 0, 922, 923, 5, 59, 0, 0, 923, 924,
		3, 142, 71, 0, 924, 925, 5, 60, 0, 0, 925, 929, 1, 0, 0, 0, 926, 927, 5,
		49, 0, 0, 927, 929, 5, 40, 0, 0, 928, 917, 1, 0, 0, 0, 928, 922, 1, 0,
		0, 0, 928, 926, 1, 0, 0, 0, 929, 141, 1, 0, 0, 0, 930, 935, 3, 144, 72,
		0, 931, 932, 5, 54, 0, 0, 932, 934, 3, 144, 72, 0, 933, 931, 1, 0, 0, 0,
		934, 937, 1, 0, 0, 0, 935, 933, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936,
		939, 1, 0, 0, 0, 937, 935, 1, 0, 0, 0, 938, 940, 5, 54, 0, 0, 939, 938,
		1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 143, 1, 0, 0, 0, 941, 953, 3, 98,
		49, 0, 942, 944, 3, 98, 49, 0, 943, 942, 1, 0, 0, 0, 943, 944, 1, 0, 0,
		0, 944, 945, 1, 0, 0, 0, 945, 947, 5, 55, 0, 0, 946, 948, 3, 98, 49, 0,
		947, 946, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 950, 1, 0, 0, 0, 949,
		951, 3, 146, 73, 0, 950, 949, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 953,
		1, 0, 0, 0, 952, 941, 1, 0, 0, 0, 952, 943, 1, 0, 0, 0, 953, 145, 1, 0,
		0, 0, 954, 956, 5, 55, 0, 0, 955, 957, 3, 98, 49, 0, 956, 955, 1, 0, 0,
		0, 956, 957, 1, 0, 0, 0, 957, 147, 1, 0, 0, 0, 958, 961, 3, 118, 59, 0,
		959, 961, 3, 116, 58, 0, 960, 958, 1, 0, 0, 0, 960, 959, 1, 0, 0, 0, 961,
		969, 1, 0, 0, 0, 962, 965, 5, 54, 0, 0, 963, 966, 3, 118, 59, 0, 964, 966,
		3, 116, 58, 0, 965, 963, 1, 0, 0, 0, 965, 964, 1, 0, 0, 0, 966, 968, 1,
		0, 0, 0, 967, 962, 1, 0, 0, 0, 968, 971, 1, 0, 0, 0, 969, 967, 1, 0, 0,
		0, 969, 970, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1, 0, 0, 0, 972,
		974, 5, 54, 0, 0, 973, 972, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 149,
		1, 0, 0, 0, 975, 980, 3, 98, 49, 0, 976, 977, 5, 54, 0, 0, 977, 979, 3,
		98, 49, 0, 978, 976, 1, 0, 0, 0, 979, 982, 1, 0, 0, 0, 980, 978, 1, 0,
		0, 0, 980, 981, 1, 0, 0, 0, 981, 984, 1, 0, 0, 0, 982, 980, 1, 0, 0, 0,
		983, 985, 5, 54, 0, 0, 984, 983, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985,
		151, 1, 0, 0, 0, 986, 987, 3, 98, 49, 0, 987, 988, 5, 55, 0, 0, 988, 989,
		3, 98, 49, 0, 989, 993, 1, 0, 0, 0, 990, 991, 5, 57, 0, 0, 991, 993, 3,
		118, 59, 0, 992, 986, 1, 0, 0, 0, 992, 990, 1, 0, 0, 0, 993, 1012, 1, 0,
		0, 0, 994, 1013, 3, 162, 81, 0, 995, 1002, 5, 54, 0, 0, 996, 997, 3, 98,
		49, 0, 997, 998, 5, 55, 0, 0, 998, 999, 3, 98, 49, 0, 999, 1003, 1, 0,
		0, 0, 1000, 1001, 5, 57, 0, 0, 1001, 1003, 3, 118, 59, 0, 1002, 996, 1,
		0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1003, 1005, 1, 0, 0, 0, 1004, 995, 1,
		0, 0, 0, 1005, 1008, 1, 0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 1,
		0, 0, 0, 1007, 1010, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1011, 5,
		54, 0, 0, 1010, 1009, 1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1,
		0, 0, 0, 1012, 994, 1, 0, 0, 0, 1012, 1006, 1, 0, 0, 0, 1013, 1035, 1,
		0, 0, 0, 1014, 1017, 3, 98, 49, 0, 1015, 1017, 3, 116, 58, 0, 1016, 1014,
		1, 0, 0, 0, 1016, 1015, 1, 0, 0, 0, 1017, 1032, 1, 0, 0, 0, 1018, 1033,
		3, 162, 81, 0, 1019, 1022, 5, 54, 0, 0, 1020, 1023, 3, 98, 49, 0, 1021,
		1023, 3, 116, 58, 0, 1022, 1020, 1, 0, 0, 0, 1022, 1021, 1, 0, 0, 0, 1023,
		1025, 1, 0, 0, 0, 1024, 1019, 1, 0, 0, 0, 1025, 1028, 1, 0, 0, 0, 1026,
		1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1030, 1, 0, 0, 0, 1028,
		1026, 1, 0, 0, 0, 1029, 1031, 5, 54, 0, 0, 1030, 1029, 1, 0, 0, 0, 1030,
		1031, 1, 0, 0, 0, 1031, 1033, 1, 0, 0, 0, 1032, 1018, 1, 0, 0, 0, 1032,
		1026, 1, 0, 0, 0, 1033, 1035, 1, 0, 0, 0, 1034, 992, 1, 0, 0, 0, 1034,
		1016, 1, 0, 0, 0, 1035, 153, 1, 0, 0, 0, 1036, 1037, 5, 31, 0, 0, 1037,
		1043, 5, 40, 0, 0, 1038, 1040, 5, 52, 0, 0, 1039, 1041, 3, 156, 78, 0,
		1040, 1039, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0,
		1042, 1044, 5, 53, 0, 0, 1043, 1038, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0,
		1044, 1045, 1, 0, 0, 0, 1045, 1046, 5, 55, 0, 0, 1046, 1047, 3, 96, 48,
		0, 1047, 155, 1, 0, 0, 0, 1048, 1053, 3, 158, 79, 0, 1049, 1050, 5, 54,
		0, 0, 1050, 1052, 3, 158, 79, 0, 1051, 1049, 1, 0, 0, 0, 1052, 1055, 1,
		0, 0, 0, 1053, 1051, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1057, 1,
		0, 0, 0, 1055, 1053, 1, 0, 0, 0, 1056, 1058, 5, 54, 0, 0, 1057, 1056, 1,
		0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 157, 1, 0, 0, 0, 1059, 1061, 3,
		98, 49, 0, 1060, 1062, 3, 162, 81, 0, 1061, 1060, 1, 0, 0, 0, 1061, 1062,
		1, 0, 0, 0, 1062, 1072, 1, 0, 0, 0, 1063, 1064, 3, 98, 49, 0, 1064, 1065,
		5, 58, 0, 0, 1065, 1066, 3, 98, 49, 0, 1066, 1072, 1, 0, 0, 0, 1067, 1068,
		5, 57, 0, 0, 1068, 1072, 3, 98, 49, 0, 1069, 1070, 5, 51, 0, 0, 1070, 1072,
		3, 98, 49, 0, 1071, 1059, 1, 0, 0, 0, 1071, 1063, 1, 0, 0, 0, 1071, 1067,
		1, 0, 0, 0, 1071, 1069, 1, 0, 0, 0, 1072, 159, 1, 0, 0, 0, 1073, 1076,
		3, 162, 81, 0, 1074, 1076, 3, 164, 82, 0, 1075, 1073, 1, 0, 0, 0, 1075,
		1074, 1, 0, 0, 0, 1076, 161, 1, 0, 0, 0, 1077, 1079, 5, 37, 0, 0, 1078,
		1077, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080,
		1081, 5, 17, 0, 0, 1081, 1082, 3, 148, 74, 0, 1082, 1083, 5, 18, 0, 0,
		1083, 1085, 3, 106, 53, 0, 1084, 1086, 3, 160, 80, 0, 1085, 1084, 1, 0,
		0, 0, 1085, 1086, 1, 0, 0, 0, 1086, 163, 1, 0, 0, 0, 1087, 1088, 5, 13,
		0, 0, 1088, 1090, 3, 100, 50, 0, 1089, 1091, 3, 160, 80, 0, 1090, 1089,
		1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 165, 1, 0, 0, 0, 1092, 1093,
		5, 40, 0, 0, 1093, 167, 1, 0, 0, 0, 1094, 1096, 5, 32, 0, 0, 1095, 1097,
		3, 170, 85, 0, 1096, 1095, 1, 0, 0, 0, 1096, 1097, 1, 0, 0, 0, 1097, 169,
		1, 0, 0, 0, 1098, 1099, 5, 7, 0, 0, 1099, 1102, 3, 98, 49, 0, 1100, 1102,
		3, 150, 75, 0, 1101, 1098, 1, 0, 0, 0, 1101, 1100, 1, 0, 0, 0, 1102, 171,
		1, 0, 0, 0, 166, 177, 181, 183, 192, 201, 204, 211, 217, 227, 234, 241,
		247, 251, 257, 263, 267, 274, 276, 278, 283, 285, 287, 291, 297, 301, 308,
		310, 312, 317, 319, 324, 329, 335, 339, 345, 351, 355, 362, 364, 366, 371,
		373, 375, 379, 385, 389, 396, 398, 400, 405, 407, 413, 420, 424, 436, 443,
		448, 452, 455, 461, 465, 470, 474, 478, 492, 500, 508, 510, 514, 523, 530,
		532, 541, 546, 551, 558, 562, 569, 577, 586, 595, 602, 613, 619, 632, 638,
		647, 658, 669, 674, 679, 684, 692, 701, 707, 709, 717, 721, 729, 732, 736,
		740, 747, 757, 765, 771, 779, 795, 805, 813, 821, 829, 837, 845, 851, 856,
		859, 865, 871, 876, 881, 889, 895, 899, 905, 909, 913, 915, 919, 928, 935,
		939, 943, 947, 950, 952, 956, 960, 965, 969, 973, 980, 984, 992, 1002,
		1006, 1010, 1012, 1016, 1022, 1026, 1030, 1032, 1034, 1040, 1043, 1053,
		1057, 1061, 1071, 1075, 1078, 1085, 1090, 1096, 1101,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Python3ParserInit initializes any static state used to implement Python3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPython3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Python3ParserInit() {
	staticData := &Python3ParserStaticData
	staticData.once.Do(python3ParserInit)
}

// NewPython3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewPython3Parser(input antlr.TokenStream) *Python3Parser {
	Python3ParserInit()
	this := new(Python3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Python3ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Python3.g4"

	return this
}

// Python3Parser tokens.
const (
	Python3ParserEOF                = antlr.TokenEOF
	Python3ParserSTRING             = 1
	Python3ParserNUMBER             = 2
	Python3ParserINTEGER            = 3
	Python3ParserDEF                = 4
	Python3ParserRETURN             = 5
	Python3ParserRAISE              = 6
	Python3ParserFROM               = 7
	Python3ParserIMPORT             = 8
	Python3ParserAS                 = 9
	Python3ParserGLOBAL             = 10
	Python3ParserNONLOCAL           = 11
	Python3ParserASSERT             = 12
	Python3ParserIF                 = 13
	Python3ParserELIF               = 14
	Python3ParserELSE               = 15
	Python3ParserWHILE              = 16
	Python3ParserFOR                = 17
	Python3ParserIN                 = 18
	Python3ParserTRY                = 19
	Python3ParserFINALLY            = 20
	Python3ParserWITH               = 21
	Python3ParserEXCEPT             = 22
	Python3ParserLAMBDA             = 23
	Python3ParserOR                 = 24
	Python3ParserAND                = 25
	Python3ParserNOT                = 26
	Python3ParserIS                 = 27
	Python3ParserNONE               = 28
	Python3ParserTRUE               = 29
	Python3ParserFALSE              = 30
	Python3ParserCLASS              = 31
	Python3ParserYIELD              = 32
	Python3ParserDEL                = 33
	Python3ParserPASS               = 34
	Python3ParserCONTINUE           = 35
	Python3ParserBREAK              = 36
	Python3ParserASYNC              = 37
	Python3ParserAWAIT              = 38
	Python3ParserNEWLINE            = 39
	Python3ParserNAME               = 40
	Python3ParserSTRING_LITERAL     = 41
	Python3ParserBYTES_LITERAL      = 42
	Python3ParserDECIMAL_INTEGER    = 43
	Python3ParserOCT_INTEGER        = 44
	Python3ParserHEX_INTEGER        = 45
	Python3ParserBIN_INTEGER        = 46
	Python3ParserFLOAT_NUMBER       = 47
	Python3ParserIMAG_NUMBER        = 48
	Python3ParserDOT                = 49
	Python3ParserELLIPSIS           = 50
	Python3ParserSTAR               = 51
	Python3ParserOPEN_PAREN         = 52
	Python3ParserCLOSE_PAREN        = 53
	Python3ParserCOMMA              = 54
	Python3ParserCOLON              = 55
	Python3ParserSEMI_COLON         = 56
	Python3ParserPOWER              = 57
	Python3ParserASSIGN             = 58
	Python3ParserOPEN_BRACK         = 59
	Python3ParserCLOSE_BRACK        = 60
	Python3ParserOR_OP              = 61
	Python3ParserXOR                = 62
	Python3ParserAND_OP             = 63
	Python3ParserLEFT_SHIFT         = 64
	Python3ParserRIGHT_SHIFT        = 65
	Python3ParserADD                = 66
	Python3ParserMINUS              = 67
	Python3ParserDIV                = 68
	Python3ParserMOD                = 69
	Python3ParserIDIV               = 70
	Python3ParserNOT_OP             = 71
	Python3ParserOPEN_BRACE         = 72
	Python3ParserCLOSE_BRACE        = 73
	Python3ParserLESS_THAN          = 74
	Python3ParserGREATER_THAN       = 75
	Python3ParserEQUALS             = 76
	Python3ParserGT_EQ              = 77
	Python3ParserLT_EQ              = 78
	Python3ParserNOT_EQ_1           = 79
	Python3ParserNOT_EQ_2           = 80
	Python3ParserAT                 = 81
	Python3ParserARROW              = 82
	Python3ParserADD_ASSIGN         = 83
	Python3ParserSUB_ASSIGN         = 84
	Python3ParserMULT_ASSIGN        = 85
	Python3ParserAT_ASSIGN          = 86
	Python3ParserDIV_ASSIGN         = 87
	Python3ParserMOD_ASSIGN         = 88
	Python3ParserAND_ASSIGN         = 89
	Python3ParserOR_ASSIGN          = 90
	Python3ParserXOR_ASSIGN         = 91
	Python3ParserLEFT_SHIFT_ASSIGN  = 92
	Python3ParserRIGHT_SHIFT_ASSIGN = 93
	Python3ParserPOWER_ASSIGN       = 94
	Python3ParserIDIV_ASSIGN        = 95
	Python3ParserSKIP_              = 96
	Python3ParserUNKNOWN_CHAR       = 97
	Python3ParserINDENT             = 98
	Python3ParserDEDENT             = 99
)

// Python3Parser rules.
const (
	Python3ParserRULE_single_input       = 0
	Python3ParserRULE_file_input         = 1
	Python3ParserRULE_eval_input         = 2
	Python3ParserRULE_decorator          = 3
	Python3ParserRULE_decorators         = 4
	Python3ParserRULE_decorated          = 5
	Python3ParserRULE_async_funcdef      = 6
	Python3ParserRULE_funcdef            = 7
	Python3ParserRULE_parameters         = 8
	Python3ParserRULE_typedargslist      = 9
	Python3ParserRULE_tfpdef             = 10
	Python3ParserRULE_varargslist        = 11
	Python3ParserRULE_vfpdef             = 12
	Python3ParserRULE_stmt               = 13
	Python3ParserRULE_simple_stmt        = 14
	Python3ParserRULE_small_stmt         = 15
	Python3ParserRULE_expr_stmt          = 16
	Python3ParserRULE_annassign          = 17
	Python3ParserRULE_testlist_star_expr = 18
	Python3ParserRULE_augassign          = 19
	Python3ParserRULE_del_stmt           = 20
	Python3ParserRULE_pass_stmt          = 21
	Python3ParserRULE_flow_stmt          = 22
	Python3ParserRULE_break_stmt         = 23
	Python3ParserRULE_continue_stmt      = 24
	Python3ParserRULE_return_stmt        = 25
	Python3ParserRULE_yield_stmt         = 26
	Python3ParserRULE_raise_stmt         = 27
	Python3ParserRULE_import_stmt        = 28
	Python3ParserRULE_import_name        = 29
	Python3ParserRULE_import_from        = 30
	Python3ParserRULE_import_as_name     = 31
	Python3ParserRULE_dotted_as_name     = 32
	Python3ParserRULE_import_as_names    = 33
	Python3ParserRULE_dotted_as_names    = 34
	Python3ParserRULE_dotted_name        = 35
	Python3ParserRULE_global_stmt        = 36
	Python3ParserRULE_nonlocal_stmt      = 37
	Python3ParserRULE_assert_stmt        = 38
	Python3ParserRULE_compound_stmt      = 39
	Python3ParserRULE_async_stmt         = 40
	Python3ParserRULE_if_stmt            = 41
	Python3ParserRULE_while_stmt         = 42
	Python3ParserRULE_for_stmt           = 43
	Python3ParserRULE_try_stmt           = 44
	Python3ParserRULE_with_stmt          = 45
	Python3ParserRULE_with_item          = 46
	Python3ParserRULE_except_clause      = 47
	Python3ParserRULE_suite              = 48
	Python3ParserRULE_test               = 49
	Python3ParserRULE_test_nocond        = 50
	Python3ParserRULE_lambdef            = 51
	Python3ParserRULE_lambdef_nocond     = 52
	Python3ParserRULE_or_test            = 53
	Python3ParserRULE_and_test           = 54
	Python3ParserRULE_not_test           = 55
	Python3ParserRULE_comparison         = 56
	Python3ParserRULE_comp_op            = 57
	Python3ParserRULE_star_expr          = 58
	Python3ParserRULE_expr               = 59
	Python3ParserRULE_xor_expr           = 60
	Python3ParserRULE_and_expr           = 61
	Python3ParserRULE_shift_expr         = 62
	Python3ParserRULE_arith_expr         = 63
	Python3ParserRULE_term               = 64
	Python3ParserRULE_factor             = 65
	Python3ParserRULE_power              = 66
	Python3ParserRULE_atom_expr          = 67
	Python3ParserRULE_atom               = 68
	Python3ParserRULE_testlist_comp      = 69
	Python3ParserRULE_trailer            = 70
	Python3ParserRULE_subscriptlist      = 71
	Python3ParserRULE_subscript          = 72
	Python3ParserRULE_sliceop            = 73
	Python3ParserRULE_exprlist           = 74
	Python3ParserRULE_testlist           = 75
	Python3ParserRULE_dictorsetmaker     = 76
	Python3ParserRULE_classdef           = 77
	Python3ParserRULE_arglist            = 78
	Python3ParserRULE_argument           = 79
	Python3ParserRULE_comp_iter          = 80
	Python3ParserRULE_comp_for           = 81
	Python3ParserRULE_comp_if            = 82
	Python3ParserRULE_encoding_decl      = 83
	Python3ParserRULE_yield_expr         = 84
	Python3ParserRULE_yield_arg          = 85
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEWLINE() antlr.TerminalNode
	Simple_stmt() ISimple_stmtContext
	Compound_stmt() ICompound_stmtContext

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
	return p
}

func InitEmptySingle_inputContext(p *Single_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (p *Python3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python3ParserRULE_single_input)
	p.SetState(177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(172)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(173)
			p.Simple_stmt()
		}

	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserASYNC, Python3ParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(174)
			p.Compound_stmt()
		}
		{
			p.SetState(175)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
	return p
}

func InitEmptyFile_inputContext(p *File_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (p *Python3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python3ParserRULE_file_input)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&584344250484473334) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&32867) != 0) {
		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNEWLINE:
			{
				p.SetState(179)
				p.Match(Python3ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserDEF, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserCLASS, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserASYNC, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE, Python3ParserAT:
			{
				p.SetState(180)
				p.Stmt()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(186)
		p.Match(Python3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Testlist() ITestlistContext
	EOF() antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
	return p
}

func InitEmptyEval_inputContext(p *Eval_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (p *Python3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python3ParserRULE_eval_input)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.Testlist()
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserNEWLINE {
		{
			p.SetState(189)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(195)
		p.Match(Python3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	Dotted_name() IDotted_nameContext
	NEWLINE() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
	return p
}

func InitEmptyDecoratorContext(p *DecoratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) AT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, 0)
}

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *DecoratorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *DecoratorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (p *Python3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python3ParserRULE_decorator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(197)
		p.Match(Python3ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(198)
		p.Dotted_name()
	}
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(199)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&728458616071258118) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(200)
				p.Arglist()
			}

		}
		{
			p.SetState(203)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(206)
		p.Match(Python3ParserNEWLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecorator() []IDecoratorContext
	Decorator(i int) IDecoratorContext

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
	return p
}

func InitEmptyDecoratorsContext(p *DecoratorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecoratorContext); ok {
			len++
		}
	}

	tst := make([]IDecoratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecoratorContext); ok {
			tst[i] = t.(IDecoratorContext)
			i++
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorators(s)
	}
}

func (p *Python3Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python3ParserRULE_decorators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Python3ParserAT {
		{
			p.SetState(208)
			p.Decorator()
		}

		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Decorators() IDecoratorsContext
	Classdef() IClassdefContext
	Funcdef() IFuncdefContext
	Async_funcdef() IAsync_funcdefContext

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
	return p
}

func InitEmptyDecoratedContext(p *DecoratedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) Async_funcdef() IAsync_funcdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsync_funcdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsync_funcdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorated(s)
	}
}

func (p *Python3Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python3ParserRULE_decorated)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(213)
		p.Decorators()
	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCLASS:
		{
			p.SetState(214)
			p.Classdef()
		}

	case Python3ParserDEF:
		{
			p.SetState(215)
			p.Funcdef()
		}

	case Python3ParserASYNC:
		{
			p.SetState(216)
			p.Async_funcdef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsync_funcdefContext is an interface to support dynamic dispatch.
type IAsync_funcdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYNC() antlr.TerminalNode
	Funcdef() IFuncdefContext

	// IsAsync_funcdefContext differentiates from other interfaces.
	IsAsync_funcdefContext()
}

type Async_funcdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_funcdefContext() *Async_funcdefContext {
	var p = new(Async_funcdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_funcdef
	return p
}

func InitEmptyAsync_funcdefContext(p *Async_funcdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_funcdef
}

func (*Async_funcdefContext) IsAsync_funcdefContext() {}

func NewAsync_funcdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_funcdefContext {
	var p = new(Async_funcdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_funcdef

	return p
}

func (s *Async_funcdefContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_funcdefContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_funcdefContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_funcdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_funcdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Async_funcdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAsync_funcdef(s)
	}
}

func (s *Async_funcdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAsync_funcdef(s)
	}
}

func (p *Python3Parser) Async_funcdef() (localctx IAsync_funcdefContext) {
	localctx = NewAsync_funcdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python3ParserRULE_async_funcdef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(219)
		p.Match(Python3ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(220)
		p.Funcdef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEF() antlr.TerminalNode
	NAME() antlr.TerminalNode
	Parameters() IParametersContext
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	ARROW() antlr.TerminalNode
	Test() ITestContext

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
	return p
}

func InitEmptyFuncdefContext(p *FuncdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEF, 0)
}

func (s *FuncdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Python3ParserARROW, 0)
}

func (s *FuncdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (p *Python3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python3ParserRULE_funcdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(Python3ParserDEF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(223)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(224)
		p.Parameters()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserARROW {
		{
			p.SetState(225)
			p.Match(Python3ParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(226)
			p.Test()
		}

	}
	{
		p.SetState(229)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(230)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Typedargslist() ITypedargslistContext

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ParametersContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ParametersContext) Typedargslist() ITypedargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitParameters(s)
	}
}

func (p *Python3Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python3ParserRULE_parameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.Match(Python3ParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&146368087401168896) != 0 {
		{
			p.SetState(233)
			p.Typedargslist()
		}

	}
	{
		p.SetState(236)
		p.Match(Python3ParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTfpdef() []ITfpdefContext
	Tfpdef(i int) ITfpdefContext
	STAR() antlr.TerminalNode
	POWER() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
	return p
}

func InitEmptyTypedargslistContext(p *TypedargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) AllTfpdef() []ITfpdefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITfpdefContext); ok {
			len++
		}
	}

	tst := make([]ITfpdefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITfpdefContext); ok {
			tst[i] = t.(ITfpdefContext)
			i++
		}
	}

	return tst
}

func (s *TypedargslistContext) Tfpdef(i int) ITfpdefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITfpdefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITfpdefContext)
}

func (s *TypedargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *TypedargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *TypedargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *TypedargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *TypedargslistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *TypedargslistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TypedargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TypedargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (p *Python3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python3ParserRULE_typedargslist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		{
			p.SetState(238)
			p.Tfpdef()
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(239)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(240)
				p.Test()
			}

		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(243)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(244)
					p.Tfpdef()
				}
				p.SetState(247)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(245)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(246)
						p.Test()
					}

				}

			}
			p.SetState(253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(254)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(285)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(255)
					p.Match(Python3ParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(257)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNAME {
					{
						p.SetState(256)
						p.Tfpdef()
					}

				}
				p.SetState(267)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(259)
							p.Match(Python3ParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(260)
							p.Tfpdef()
						}
						p.SetState(263)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(261)
								p.Match(Python3ParserASSIGN)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}
							{
								p.SetState(262)
								p.Test()
							}

						}

					}
					p.SetState(269)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(278)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(270)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(276)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == Python3ParserPOWER {
						{
							p.SetState(271)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(272)
							p.Tfpdef()
						}
						p.SetState(274)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserCOMMA {
							{
								p.SetState(273)
								p.Match(Python3ParserCOMMA)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}

						}

					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(280)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(281)
					p.Tfpdef()
				}
				p.SetState(283)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(282)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case Python3ParserCLOSE_PAREN:

			default:
			}

		}

	case Python3ParserSTAR:
		{
			p.SetState(289)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserNAME {
			{
				p.SetState(290)
				p.Tfpdef()
			}

		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(293)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(294)
					p.Tfpdef()
				}
				p.SetState(297)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(295)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(296)
						p.Test()
					}

				}

			}
			p.SetState(303)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(304)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(310)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserPOWER {
				{
					p.SetState(305)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(306)
					p.Tfpdef()
				}
				p.SetState(308)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(307)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		}

	case Python3ParserPOWER:
		{
			p.SetState(314)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(315)
			p.Tfpdef()
		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(316)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITfpdefContext is an interface to support dynamic dispatch.
type ITfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsTfpdefContext differentiates from other interfaces.
	IsTfpdefContext()
}

type TfpdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfpdefContext() *TfpdefContext {
	var p = new(TfpdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
	return p
}

func InitEmptyTfpdefContext(p *TfpdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
}

func (*TfpdefContext) IsTfpdefContext() {}

func NewTfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TfpdefContext {
	var p = new(TfpdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_tfpdef

	return p
}

func (s *TfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *TfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TfpdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *TfpdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTfpdef(s)
	}
}

func (s *TfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTfpdef(s)
	}
}

func (p *Python3Parser) Tfpdef() (localctx ITfpdefContext) {
	localctx = NewTfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python3ParserRULE_tfpdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOLON {
		{
			p.SetState(322)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(323)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVfpdef() []IVfpdefContext
	Vfpdef(i int) IVfpdefContext
	STAR() antlr.TerminalNode
	POWER() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
	return p
}

func InitEmptyVarargslistContext(p *VarargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllVfpdef() []IVfpdefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVfpdefContext); ok {
			len++
		}
	}

	tst := make([]IVfpdefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVfpdefContext); ok {
			tst[i] = t.(IVfpdefContext)
			i++
		}
	}

	return tst
}

func (s *VarargslistContext) Vfpdef(i int) IVfpdefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVfpdefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVfpdefContext)
}

func (s *VarargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *VarargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *VarargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *VarargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *VarargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (p *Python3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python3ParserRULE_varargslist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		{
			p.SetState(326)
			p.Vfpdef()
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(327)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(328)
				p.Test()
			}

		}
		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(331)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(332)
					p.Vfpdef()
				}
				p.SetState(335)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(333)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(334)
						p.Test()
					}

				}

			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(342)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(373)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(343)
					p.Match(Python3ParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(345)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNAME {
					{
						p.SetState(344)
						p.Vfpdef()
					}

				}
				p.SetState(355)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(347)
							p.Match(Python3ParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(348)
							p.Vfpdef()
						}
						p.SetState(351)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(349)
								p.Match(Python3ParserASSIGN)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}
							{
								p.SetState(350)
								p.Test()
							}

						}

					}
					p.SetState(357)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(366)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(358)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(364)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == Python3ParserPOWER {
						{
							p.SetState(359)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(360)
							p.Vfpdef()
						}
						p.SetState(362)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserCOMMA {
							{
								p.SetState(361)
								p.Match(Python3ParserCOMMA)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}

						}

					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(368)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(369)
					p.Vfpdef()
				}
				p.SetState(371)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(370)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case Python3ParserCOLON:

			default:
			}

		}

	case Python3ParserSTAR:
		{
			p.SetState(377)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserNAME {
			{
				p.SetState(378)
				p.Vfpdef()
			}

		}
		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(381)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(382)
					p.Vfpdef()
				}
				p.SetState(385)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(383)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(384)
						p.Test()
					}

				}

			}
			p.SetState(391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(392)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(398)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserPOWER {
				{
					p.SetState(393)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(394)
					p.Vfpdef()
				}
				p.SetState(396)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(395)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		}

	case Python3ParserPOWER:
		{
			p.SetState(402)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)
			p.Vfpdef()
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(404)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVfpdefContext is an interface to support dynamic dispatch.
type IVfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode

	// IsVfpdefContext differentiates from other interfaces.
	IsVfpdefContext()
}

type VfpdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVfpdefContext() *VfpdefContext {
	var p = new(VfpdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
	return p
}

func InitEmptyVfpdefContext(p *VfpdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
}

func (*VfpdefContext) IsVfpdefContext() {}

func NewVfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VfpdefContext {
	var p = new(VfpdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vfpdef

	return p
}

func (s *VfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *VfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *VfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterVfpdef(s)
	}
}

func (s *VfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitVfpdef(s)
	}
}

func (p *Python3Parser) Vfpdef() (localctx IVfpdefContext) {
	localctx = NewVfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python3ParserRULE_vfpdef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmt() ISimple_stmtContext
	Compound_stmt() ICompound_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *Python3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python3ParserRULE_stmt)
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(411)
			p.Simple_stmt()
		}

	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserASYNC, Python3ParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(412)
			p.Compound_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSmall_stmt() []ISmall_stmtContext
	Small_stmt(i int) ISmall_stmtContext
	NEWLINE() antlr.TerminalNode
	AllSEMI_COLON() []antlr.TerminalNode
	SEMI_COLON(i int) antlr.TerminalNode

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
	return p
}

func InitEmptySimple_stmtContext(p *Simple_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISmall_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISmall_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISmall_stmtContext); ok {
			tst[i] = t.(ISmall_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISmall_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Simple_stmtContext) AllSEMI_COLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSEMI_COLON)
}

func (s *Simple_stmtContext) SEMI_COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSEMI_COLON, i)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (p *Python3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python3ParserRULE_simple_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Small_stmt()
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(416)
				p.Match(Python3ParserSEMI_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(417)
				p.Small_stmt()
			}

		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserSEMI_COLON {
		{
			p.SetState(423)
			p.Match(Python3ParserSEMI_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(426)
		p.Match(Python3ParserNEWLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_stmt() IExpr_stmtContext
	Del_stmt() IDel_stmtContext
	Pass_stmt() IPass_stmtContext
	Flow_stmt() IFlow_stmtContext
	Import_stmt() IImport_stmtContext
	Global_stmt() IGlobal_stmtContext
	Nonlocal_stmt() INonlocal_stmtContext
	Assert_stmt() IAssert_stmtContext

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
	return p
}

func InitEmptySmall_stmtContext(p *Small_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Small_stmtContext) Del_stmt() IDel_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDel_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Small_stmtContext) Pass_stmt() IPass_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPass_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Small_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlow_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Small_stmtContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Small_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Small_stmtContext) Nonlocal_stmt() INonlocal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonlocal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonlocal_stmtContext)
}

func (s *Small_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Small_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSmall_stmt(s)
	}
}

func (s *Small_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSmall_stmt(s)
	}
}

func (p *Python3Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python3ParserRULE_small_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(428)
			p.Expr_stmt()
		}

	case Python3ParserDEL:
		{
			p.SetState(429)
			p.Del_stmt()
		}

	case Python3ParserPASS:
		{
			p.SetState(430)
			p.Pass_stmt()
		}

	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserYIELD, Python3ParserCONTINUE, Python3ParserBREAK:
		{
			p.SetState(431)
			p.Flow_stmt()
		}

	case Python3ParserFROM, Python3ParserIMPORT:
		{
			p.SetState(432)
			p.Import_stmt()
		}

	case Python3ParserGLOBAL:
		{
			p.SetState(433)
			p.Global_stmt()
		}

	case Python3ParserNONLOCAL:
		{
			p.SetState(434)
			p.Nonlocal_stmt()
		}

	case Python3ParserASSERT:
		{
			p.SetState(435)
			p.Assert_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTestlist_star_expr() []ITestlist_star_exprContext
	Testlist_star_expr(i int) ITestlist_star_exprContext
	Annassign() IAnnassignContext
	Augassign() IAugassignContext
	AllYield_expr() []IYield_exprContext
	Yield_expr(i int) IYield_exprContext
	Testlist() ITestlistContext
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
	return p
}

func InitEmptyExpr_stmtContext(p *Expr_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			len++
		}
	}

	tst := make([]ITestlist_star_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestlist_star_exprContext); ok {
			tst[i] = t.(ITestlist_star_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Annassign() IAnnassignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnassignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnassignContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAugassignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYield_exprContext); ok {
			len++
		}
	}

	tst := make([]IYield_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYield_exprContext); ok {
			tst[i] = t.(IYield_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *Expr_stmtContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *Python3Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python3ParserRULE_expr_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Testlist_star_expr()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCOLON:
		{
			p.SetState(439)
			p.Annassign()
		}

	case Python3ParserADD_ASSIGN, Python3ParserSUB_ASSIGN, Python3ParserMULT_ASSIGN, Python3ParserAT_ASSIGN, Python3ParserDIV_ASSIGN, Python3ParserMOD_ASSIGN, Python3ParserAND_ASSIGN, Python3ParserOR_ASSIGN, Python3ParserXOR_ASSIGN, Python3ParserLEFT_SHIFT_ASSIGN, Python3ParserRIGHT_SHIFT_ASSIGN, Python3ParserPOWER_ASSIGN, Python3ParserIDIV_ASSIGN:
		{
			p.SetState(440)
			p.Augassign()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(441)
				p.Yield_expr()
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(442)
				p.Testlist()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case Python3ParserNEWLINE, Python3ParserSEMI_COLON, Python3ParserASSIGN:
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserASSIGN {
			{
				p.SetState(445)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(448)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserYIELD:
				{
					p.SetState(446)
					p.Yield_expr()
				}

			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(447)
					p.Testlist_star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnassignContext is an interface to support dynamic dispatch.
type IAnnassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	ASSIGN() antlr.TerminalNode

	// IsAnnassignContext differentiates from other interfaces.
	IsAnnassignContext()
}

type AnnassignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnassignContext() *AnnassignContext {
	var p = new(AnnassignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_annassign
	return p
}

func InitEmptyAnnassignContext(p *AnnassignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_annassign
}

func (*AnnassignContext) IsAnnassignContext() {}

func NewAnnassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnassignContext {
	var p = new(AnnassignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_annassign

	return p
}

func (s *AnnassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnassignContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *AnnassignContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *AnnassignContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *AnnassignContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *AnnassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAnnassign(s)
	}
}

func (s *AnnassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAnnassign(s)
	}
}

func (p *Python3Parser) Annassign() (localctx IAnnassignContext) {
	localctx = NewAnnassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python3ParserRULE_annassign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)
		p.Test()
	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserASSIGN {
		{
			p.SetState(459)
			p.Match(Python3ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(460)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
	return p
}

func InitEmptyTestlist_star_exprContext(p *Testlist_star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_star_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (p *Python3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python3ParserRULE_testlist_star_expr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(463)
			p.Test()
		}

	case Python3ParserSTAR:
		{
			p.SetState(464)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(467)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(470)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(468)
					p.Test()
				}

			case Python3ParserSTAR:
				{
					p.SetState(469)
					p.Star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(477)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	MULT_ASSIGN() antlr.TerminalNode
	AT_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	LEFT_SHIFT_ASSIGN() antlr.TerminalNode
	RIGHT_SHIFT_ASSIGN() antlr.TerminalNode
	POWER_ASSIGN() antlr.TerminalNode
	IDIV_ASSIGN() antlr.TerminalNode

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
	return p
}

func InitEmptyAugassignContext(p *AugassignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AugassignContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD_ASSIGN, 0)
}

func (s *AugassignContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserSUB_ASSIGN, 0)
}

func (s *AugassignContext) MULT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMULT_ASSIGN, 0)
}

func (s *AugassignContext) AT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT_ASSIGN, 0)
}

func (s *AugassignContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV_ASSIGN, 0)
}

func (s *AugassignContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD_ASSIGN, 0)
}

func (s *AugassignContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_ASSIGN, 0)
}

func (s *AugassignContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_ASSIGN, 0)
}

func (s *AugassignContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR_ASSIGN, 0)
}

func (s *AugassignContext) LEFT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) RIGHT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER_ASSIGN, 0)
}

func (s *AugassignContext) IDIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV_ASSIGN, 0)
}

func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAugassign(s)
	}
}

func (p *Python3Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python3ParserRULE_augassign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&8191) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEL() antlr.TerminalNode
	Exprlist() IExprlistContext

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
	return p
}

func InitEmptyDel_stmtContext(p *Del_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (p *Python3Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python3ParserRULE_del_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(Python3ParserDEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)
		p.Exprlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PASS() antlr.TerminalNode

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
	return p
}

func InitEmptyPass_stmtContext(p *Pass_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserPASS, 0)
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (p *Python3Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python3ParserRULE_pass_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(Python3ParserPASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break_stmt() IBreak_stmtContext
	Continue_stmt() IContinue_stmtContext
	Return_stmt() IReturn_stmtContext
	Raise_stmt() IRaise_stmtContext
	Yield_stmt() IYield_stmtContext

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
	return p
}

func InitEmptyFlow_stmtContext(p *Flow_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinue_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaise_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}

func (p *Python3Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python3ParserRULE_flow_stmt)
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.Break_stmt()
		}

	case Python3ParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(488)
			p.Continue_stmt()
		}

	case Python3ParserRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(489)
			p.Return_stmt()
		}

	case Python3ParserRAISE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(490)
			p.Raise_stmt()
		}

	case Python3ParserYIELD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(491)
			p.Yield_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
	return p
}

func InitEmptyBreak_stmtContext(p *Break_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserBREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (p *Python3Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python3ParserRULE_break_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Match(Python3ParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
	return p
}

func InitEmptyContinue_stmtContext(p *Continue_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (p *Python3Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python3ParserRULE_continue_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(Python3ParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Testlist() ITestlistContext

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
	return p
}

func InitEmptyReturn_stmtContext(p *Return_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (p *Python3Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python3ParserRULE_return_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(Python3ParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
		{
			p.SetState(499)
			p.Testlist()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Yield_expr() IYield_exprContext

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
	return p
}

func InitEmptyYield_stmtContext(p *Yield_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (p *Python3Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python3ParserRULE_yield_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Yield_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	FROM() antlr.TerminalNode

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
	return p
}

func InitEmptyRaise_stmtContext(p *Raise_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(Python3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (p *Python3Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python3ParserRULE_raise_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(Python3ParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
		{
			p.SetState(505)
			p.Test()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFROM {
			{
				p.SetState(506)
				p.Match(Python3ParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(507)
				p.Test()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Import_name() IImport_nameContext
	Import_from() IImport_fromContext

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
	return p
}

func InitEmptyImport_stmtContext(p *Import_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_fromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *Python3Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python3ParserRULE_import_stmt)
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.Import_name()
		}

	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(513)
			p.Import_from()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Dotted_as_names() IDotted_as_namesContext

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
	return p
}

func InitEmptyImport_nameContext(p *Import_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_name(s)
	}
}

func (p *Python3Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python3ParserRULE_import_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.Match(Python3ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(517)
		p.Dotted_as_names()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	Dotted_name() IDotted_nameContext
	STAR() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Import_as_names() IImport_as_namesContext
	CLOSE_PAREN() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllELLIPSIS() []antlr.TerminalNode
	ELLIPSIS(i int) antlr.TerminalNode

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
	return p
}

func InitEmptyImport_fromContext(p *Import_fromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Import_fromContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Import_fromContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Import_fromContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Import_fromContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Import_fromContext) AllELLIPSIS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELLIPSIS)
}

func (s *Import_fromContext) ELLIPSIS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, i)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_from(s)
	}
}

func (p *Python3Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python3ParserRULE_import_from)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.Match(Python3ParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(520)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(525)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(526)
			p.Dotted_name()
		}

	case 2:
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(527)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(530)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(534)
		p.Match(Python3ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		{
			p.SetState(535)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_PAREN:
		{
			p.SetState(536)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)
			p.Import_as_names()
		}
		{
			p.SetState(538)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserNAME:
		{
			p.SetState(540)
			p.Import_as_names()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
	return p
}

func InitEmptyImport_as_nameContext(p *Import_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Import_as_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (p *Python3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python3ParserRULE_import_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(544)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(545)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dotted_name() IDotted_nameContext
	AS() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
	return p
}

func InitEmptyDotted_as_nameContext(p *Dotted_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Dotted_as_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (p *Python3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python3ParserRULE_dotted_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.Dotted_name()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(549)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(550)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImport_as_name() []IImport_as_nameContext
	Import_as_name(i int) IImport_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
	return p
}

func InitEmptyImport_as_namesContext(p *Import_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IImport_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImport_as_nameContext); ok {
			tst[i] = t.(IImport_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Import_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (p *Python3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python3ParserRULE_import_as_names)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Import_as_name()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(554)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(555)
				p.Import_as_name()
			}

		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(561)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDotted_as_name() []IDotted_as_nameContext
	Dotted_as_name(i int) IDotted_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
	return p
}

func InitEmptyDotted_as_namesContext(p *Dotted_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IDotted_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDotted_as_nameContext); ok {
			tst[i] = t.(IDotted_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Dotted_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (p *Python3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python3ParserRULE_dotted_as_names)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Dotted_as_name()
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(565)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(566)
			p.Dotted_as_name()
		}

		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
	return p
}

func InitEmptyDotted_nameContext(p *Dotted_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Dotted_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Dotted_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Dotted_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (p *Python3Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python3ParserRULE_dotted_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserDOT {
		{
			p.SetState(573)
			p.Match(Python3ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
	return p
}

func InitEmptyGlobal_stmtContext(p *Global_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Global_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Global_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Global_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (p *Python3Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python3ParserRULE_global_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(Python3ParserGLOBAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(581)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(582)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(583)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonlocal_stmtContext is an interface to support dynamic dispatch.
type INonlocal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONLOCAL() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNonlocal_stmtContext differentiates from other interfaces.
	IsNonlocal_stmtContext()
}

type Nonlocal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonlocal_stmtContext() *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
	return p
}

func InitEmptyNonlocal_stmtContext(p *Nonlocal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
}

func (*Nonlocal_stmtContext) IsNonlocal_stmtContext() {}

func NewNonlocal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt

	return p
}

func (s *Nonlocal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Nonlocal_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Nonlocal_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Nonlocal_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

func (p *Python3Parser) Nonlocal_stmt() (localctx INonlocal_stmtContext) {
	localctx = NewNonlocal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Python3ParserRULE_nonlocal_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.Match(Python3ParserNONLOCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(590)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(591)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(592)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSERT() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	COMMA() antlr.TerminalNode

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
	return p
}

func InitEmptyAssert_stmtContext(p *Assert_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (p *Python3Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Python3ParserRULE_assert_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Match(Python3ParserASSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(599)
		p.Test()
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(600)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(601)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If_stmt() IIf_stmtContext
	While_stmt() IWhile_stmtContext
	For_stmt() IFor_stmtContext
	Try_stmt() ITry_stmtContext
	With_stmt() IWith_stmtContext
	Funcdef() IFuncdefContext
	Classdef() IClassdefContext
	Decorated() IDecoratedContext
	Async_stmt() IAsync_stmtContext

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
	return p
}

func InitEmptyCompound_stmtContext(p *Compound_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITry_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) Async_stmt() IAsync_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsync_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsync_stmtContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}

func (p *Python3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Python3ParserRULE_compound_stmt)
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.If_stmt()
		}

	case Python3ParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.While_stmt()
		}

	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(606)
			p.For_stmt()
		}

	case Python3ParserTRY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(607)
			p.Try_stmt()
		}

	case Python3ParserWITH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(608)
			p.With_stmt()
		}

	case Python3ParserDEF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(609)
			p.Funcdef()
		}

	case Python3ParserCLASS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(610)
			p.Classdef()
		}

	case Python3ParserAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(611)
			p.Decorated()
		}

	case Python3ParserASYNC:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(612)
			p.Async_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsync_stmtContext is an interface to support dynamic dispatch.
type IAsync_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYNC() antlr.TerminalNode
	Funcdef() IFuncdefContext
	With_stmt() IWith_stmtContext
	For_stmt() IFor_stmtContext

	// IsAsync_stmtContext differentiates from other interfaces.
	IsAsync_stmtContext()
}

type Async_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_stmtContext() *Async_stmtContext {
	var p = new(Async_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_stmt
	return p
}

func InitEmptyAsync_stmtContext(p *Async_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_stmt
}

func (*Async_stmtContext) IsAsync_stmtContext() {}

func NewAsync_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_stmtContext {
	var p = new(Async_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_stmt

	return p
}

func (s *Async_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_stmtContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_stmtContext) With_stmt() IWith_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Async_stmtContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Async_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Async_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAsync_stmt(s)
	}
}

func (s *Async_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAsync_stmt(s)
	}
}

func (p *Python3Parser) Async_stmt() (localctx IAsync_stmtContext) {
	localctx = NewAsync_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python3ParserRULE_async_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Match(Python3ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDEF:
		{
			p.SetState(616)
			p.Funcdef()
		}

	case Python3ParserWITH:
		{
			p.SetState(617)
			p.With_stmt()
		}

	case Python3ParserFOR:
		{
			p.SetState(618)
			p.For_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllSuite() []ISuiteContext
	Suite(i int) ISuiteContext
	AllELIF() []antlr.TerminalNode
	ELIF(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *If_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *If_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *If_stmtContext) AllSuite() []ISuiteContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISuiteContext); ok {
			len++
		}
	}

	tst := make([]ISuiteContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISuiteContext); ok {
			tst[i] = t.(ISuiteContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Suite(i int) ISuiteContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) AllELIF() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELIF)
}

func (s *If_stmtContext) ELIF(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELIF, i)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *Python3Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python3ParserRULE_if_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(Python3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Test()
	}
	{
		p.SetState(623)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(624)
		p.Suite()
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserELIF {
		{
			p.SetState(625)
			p.Match(Python3ParserELIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.Test()
		}
		{
			p.SetState(627)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.Suite()
		}

		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(635)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(636)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.Suite()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Test() ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllSuite() []ISuiteContext
	Suite(i int) ISuiteContext
	ELSE() antlr.TerminalNode

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
	return p
}

func InitEmptyWhile_stmtContext(p *While_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Python3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *While_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *While_stmtContext) AllSuite() []ISuiteContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISuiteContext); ok {
			len++
		}
	}

	tst := make([]ISuiteContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISuiteContext); ok {
			tst[i] = t.(ISuiteContext)
			i++
		}
	}

	return tst
}

func (s *While_stmtContext) Suite(i int) ISuiteContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (p *Python3Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python3ParserRULE_while_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(Python3ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.Test()
	}
	{
		p.SetState(642)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.Suite()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(644)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.Suite()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Exprlist() IExprlistContext
	IN() antlr.TerminalNode
	Testlist() ITestlistContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllSuite() []ISuiteContext
	Suite(i int) ISuiteContext
	ELSE() antlr.TerminalNode

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
	return p
}

func InitEmptyFor_stmtContext(p *For_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *For_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *For_stmtContext) AllSuite() []ISuiteContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISuiteContext); ok {
			len++
		}
	}

	tst := make([]ISuiteContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISuiteContext); ok {
			tst[i] = t.(ISuiteContext)
			i++
		}
	}

	return tst
}

func (s *For_stmtContext) Suite(i int) ISuiteContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *Python3Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python3ParserRULE_for_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(Python3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(650)
		p.Exprlist()
	}
	{
		p.SetState(651)
		p.Match(Python3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Testlist()
	}
	{
		p.SetState(653)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(654)
		p.Suite()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(655)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(656)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(657)
			p.Suite()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllSuite() []ISuiteContext
	Suite(i int) ISuiteContext
	FINALLY() antlr.TerminalNode
	AllExcept_clause() []IExcept_clauseContext
	Except_clause(i int) IExcept_clauseContext
	ELSE() antlr.TerminalNode

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
	return p
}

func InitEmptyTry_stmtContext(p *Try_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRY, 0)
}

func (s *Try_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *Try_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *Try_stmtContext) AllSuite() []ISuiteContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISuiteContext); ok {
			len++
		}
	}

	tst := make([]ISuiteContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISuiteContext); ok {
			tst[i] = t.(ISuiteContext)
			i++
		}
	}

	return tst
}

func (s *Try_stmtContext) Suite(i int) ISuiteContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Python3ParserFINALLY, 0)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			len++
		}
	}

	tst := make([]IExcept_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExcept_clauseContext); ok {
			tst[i] = t.(IExcept_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (p *Python3Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Python3ParserRULE_try_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(Python3ParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(662)
		p.Suite()
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserEXCEPT:
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserEXCEPT {
			{
				p.SetState(663)
				p.Except_clause()
			}
			{
				p.SetState(664)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(665)
				p.Suite()
			}

			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserELSE {
			{
				p.SetState(671)
				p.Match(Python3ParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(672)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(673)
				p.Suite()
			}

		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFINALLY {
			{
				p.SetState(676)
				p.Match(Python3ParserFINALLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(677)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(678)
				p.Suite()
			}

		}

	case Python3ParserFINALLY:
		{
			p.SetState(681)
			p.Match(Python3ParserFINALLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.Suite()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllWith_item() []IWith_itemContext
	With_item(i int) IWith_itemContext
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
	return p
}

func InitEmptyWith_stmtContext(p *With_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Python3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWith_itemContext); ok {
			len++
		}
	}

	tst := make([]IWith_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWith_itemContext); ok {
			tst[i] = t.(IWith_itemContext)
			i++
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *With_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (p *Python3Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python3ParserRULE_with_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(Python3ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(687)
		p.With_item()
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(688)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.With_item()
		}

		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(695)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(696)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Test() ITestContext
	AS() antlr.TerminalNode
	Expr() IExprContext

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
	return p
}

func InitEmptyWith_itemContext(p *With_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (p *Python3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python3ParserRULE_with_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Test()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(699)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(700)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	Test() ITestContext
	AS() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
	return p
}

func InitEmptyExcept_clauseContext(p *Except_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Except_clauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (p *Python3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python3ParserRULE_except_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(Python3ParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
		{
			p.SetState(704)
			p.Test()
		}
		p.SetState(707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserAS {
			{
				p.SetState(705)
				p.Match(Python3ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(706)
				p.Match(Python3ParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmt() ISimple_stmtContext
	NEWLINE() antlr.TerminalNode
	INDENT() antlr.TerminalNode
	DEDENT() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
	return p
}

func InitEmptySuiteContext(p *SuiteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSuite(s)
	}
}

func (p *Python3Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python3ParserRULE_suite)
	var _la int

	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(711)
			p.Simple_stmt()
		}

	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(713)
			p.Match(Python3ParserINDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&584343700728659446) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&32867) != 0) {
			{
				p.SetState(714)
				p.Stmt()
			}

			p.SetState(717)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(719)
			p.Match(Python3ParserDEDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOr_test() []IOr_testContext
	Or_test(i int) IOr_testContext
	IF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Test() ITestContext
	Lambdef() ILambdefContext

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
	return p
}

func InitEmptyTestContext(p *TestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOr_testContext); ok {
			len++
		}
	}

	tst := make([]IOr_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOr_testContext); ok {
			tst[i] = t.(IOr_testContext)
			i++
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTest(s)
	}
}

func (p *Python3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python3ParserRULE_test)
	var _la int

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Or_test()
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserIF {
			{
				p.SetState(724)
				p.Match(Python3ParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(725)
				p.Or_test()
			}
			{
				p.SetState(726)
				p.Match(Python3ParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(727)
				p.Test()
			}

		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(731)
			p.Lambdef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITest_nocondContext is an interface to support dynamic dispatch.
type ITest_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Or_test() IOr_testContext
	Lambdef_nocond() ILambdef_nocondContext

	// IsTest_nocondContext differentiates from other interfaces.
	IsTest_nocondContext()
}

type Test_nocondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_nocondContext() *Test_nocondContext {
	var p = new(Test_nocondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
	return p
}

func InitEmptyTest_nocondContext(p *Test_nocondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
}

func (*Test_nocondContext) IsTest_nocondContext() {}

func NewTest_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_nocondContext {
	var p = new(Test_nocondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test_nocond

	return p
}

func (s *Test_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_nocondContext) Or_test() IOr_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Test_nocondContext) Lambdef_nocond() ILambdef_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdef_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdef_nocondContext)
}

func (s *Test_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Test_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTest_nocond(s)
	}
}

func (s *Test_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTest_nocond(s)
	}
}

func (p *Python3Parser) Test_nocond() (localctx ITest_nocondContext) {
	localctx = NewTest_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python3ParserRULE_test_nocond)
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.Or_test()
		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Lambdef_nocond()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAMBDA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Test() ITestContext
	Varargslist() IVarargslistContext

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
	return p
}

func InitEmptyLambdefContext(p *LambdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *LambdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *LambdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitLambdef(s)
	}
}

func (p *Python3Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python3ParserRULE_lambdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(Python3ParserLAMBDA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&146368087401168896) != 0 {
		{
			p.SetState(739)
			p.Varargslist()
		}

	}
	{
		p.SetState(742)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(743)
		p.Test()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdef_nocondContext is an interface to support dynamic dispatch.
type ILambdef_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAMBDA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Test_nocond() ITest_nocondContext
	Varargslist() IVarargslistContext

	// IsLambdef_nocondContext differentiates from other interfaces.
	IsLambdef_nocondContext()
}

type Lambdef_nocondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdef_nocondContext() *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
	return p
}

func InitEmptyLambdef_nocondContext(p *Lambdef_nocondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
}

func (*Lambdef_nocondContext) IsLambdef_nocondContext() {}

func NewLambdef_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef_nocond

	return p
}

func (s *Lambdef_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambdef_nocondContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *Lambdef_nocondContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Lambdef_nocondContext) Test_nocond() ITest_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITest_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Lambdef_nocondContext) Varargslist() IVarargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Lambdef_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambdef_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambdef_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitLambdef_nocond(s)
	}
}

func (p *Python3Parser) Lambdef_nocond() (localctx ILambdef_nocondContext) {
	localctx = NewLambdef_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python3ParserRULE_lambdef_nocond)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(Python3ParserLAMBDA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&146368087401168896) != 0 {
		{
			p.SetState(746)
			p.Varargslist()
		}

	}
	{
		p.SetState(749)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(750)
		p.Test_nocond()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_test() []IAnd_testContext
	And_test(i int) IAnd_testContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
	return p
}

func InitEmptyOr_testContext(p *Or_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_testContext); ok {
			len++
		}
	}

	tst := make([]IAnd_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_testContext); ok {
			tst[i] = t.(IAnd_testContext)
			i++
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR)
}

func (s *Or_testContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR, i)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitOr_test(s)
	}
}

func (p *Python3Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python3ParserRULE_or_test)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.And_test()
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR {
		{
			p.SetState(753)
			p.Match(Python3ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.And_test()
		}

		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNot_test() []INot_testContext
	Not_test(i int) INot_testContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
	return p
}

func InitEmptyAnd_testContext(p *And_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INot_testContext); ok {
			len++
		}
	}

	tst := make([]INot_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INot_testContext); ok {
			tst[i] = t.(INot_testContext)
			i++
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND)
}

func (s *And_testContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND, i)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAnd_test(s)
	}
}

func (p *Python3Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python3ParserRULE_and_test)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Not_test()
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND {
		{
			p.SetState(761)
			p.Match(Python3ParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(762)
			p.Not_test()
		}

		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	Not_test() INot_testContext
	Comparison() IComparisonContext

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
	return p
}

func InitEmptyNot_testContext(p *Not_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Not_testContext) Not_test() INot_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitNot_test(s)
	}
}

func (p *Python3Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python3ParserRULE_not_test)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)
			p.Not_test()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(770)
			p.Comparison()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComp_op() []IComp_opContext
	Comp_op(i int) IComp_opContext

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
	return p
}

func InitEmptyComparisonContext(p *ComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComp_opContext); ok {
			len++
		}
	}

	tst := make([]IComp_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComp_opContext); ok {
			tst[i] = t.(IComp_opContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *Python3Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python3ParserRULE_comparison)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Expr()
	}
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-18)) & ^0x3f) == 0 && ((int64(1)<<(_la-18))&9151314442816848641) != 0 {
		{
			p.SetState(774)
			p.Comp_op()
		}
		{
			p.SetState(775)
			p.Expr()
		}

		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS_THAN() antlr.TerminalNode
	GREATER_THAN() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	GT_EQ() antlr.TerminalNode
	LT_EQ() antlr.TerminalNode
	NOT_EQ_1() antlr.TerminalNode
	NOT_EQ_2() antlr.TerminalNode
	IN() antlr.TerminalNode
	NOT() antlr.TerminalNode
	IS() antlr.TerminalNode

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
	return p
}

func InitEmptyComp_opContext(p *Comp_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_opContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLESS_THAN, 0)
}

func (s *Comp_opContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserGREATER_THAN, 0)
}

func (s *Comp_opContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(Python3ParserEQUALS, 0)
}

func (s *Comp_opContext) GT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserGT_EQ, 0)
}

func (s *Comp_opContext) LT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserLT_EQ, 0)
}

func (s *Comp_opContext) NOT_EQ_1() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_1, 0)
}

func (s *Comp_opContext) NOT_EQ_2() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_2, 0)
}

func (s *Comp_opContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Comp_opContext) IS() antlr.TerminalNode {
	return s.GetToken(Python3ParserIS, 0)
}

func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_op(s)
	}
}

func (p *Python3Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python3ParserRULE_comp_op)
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(782)
			p.Match(Python3ParserLESS_THAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)
			p.Match(Python3ParserGREATER_THAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(784)
			p.Match(Python3ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(785)
			p.Match(Python3ParserGT_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(786)
			p.Match(Python3ParserLT_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(787)
			p.Match(Python3ParserNOT_EQ_1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(788)
			p.Match(Python3ParserNOT_EQ_2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(789)
			p.Match(Python3ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(790)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(791)
			p.Match(Python3ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(792)
			p.Match(Python3ParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(793)
			p.Match(Python3ParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(794)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Expr() IExprContext

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
	return p
}

func InitEmptyStar_exprContext(p *Star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (p *Python3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python3ParserRULE_star_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.Match(Python3ParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(798)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllXor_expr() []IXor_exprContext
	Xor_expr(i int) IXor_exprContext
	AllOR_OP() []antlr.TerminalNode
	OR_OP(i int) antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXor_exprContext); ok {
			len++
		}
	}

	tst := make([]IXor_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXor_exprContext); ok {
			tst[i] = t.(IXor_exprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) AllOR_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR_OP)
}

func (s *ExprContext) OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_OP, i)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *Python3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Python3ParserRULE_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Xor_expr()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR_OP {
		{
			p.SetState(801)
			p.Match(Python3ParserOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.Xor_expr()
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_expr() []IAnd_exprContext
	And_expr(i int) IAnd_exprContext
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
	return p
}

func InitEmptyXor_exprContext(p *Xor_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_exprContext); ok {
			len++
		}
	}

	tst := make([]IAnd_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_exprContext); ok {
			tst[i] = t.(IAnd_exprContext)
			i++
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserXOR)
}

func (s *Xor_exprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR, i)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (p *Python3Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Python3ParserRULE_xor_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.And_expr()
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserXOR {
		{
			p.SetState(809)
			p.Match(Python3ParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.And_expr()
		}

		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllShift_expr() []IShift_exprContext
	Shift_expr(i int) IShift_exprContext
	AllAND_OP() []antlr.TerminalNode
	AND_OP(i int) antlr.TerminalNode

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
	return p
}

func InitEmptyAnd_exprContext(p *And_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShift_exprContext); ok {
			len++
		}
	}

	tst := make([]IShift_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShift_exprContext); ok {
			tst[i] = t.(IShift_exprContext)
			i++
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) AllAND_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND_OP)
}

func (s *And_exprContext) AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_OP, i)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (p *Python3Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Python3ParserRULE_and_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Shift_expr()
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND_OP {
		{
			p.SetState(817)
			p.Match(Python3ParserAND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(818)
			p.Shift_expr()
		}

		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArith_expr() []IArith_exprContext
	Arith_expr(i int) IArith_exprContext
	AllLEFT_SHIFT() []antlr.TerminalNode
	LEFT_SHIFT(i int) antlr.TerminalNode
	AllRIGHT_SHIFT() []antlr.TerminalNode
	RIGHT_SHIFT(i int) antlr.TerminalNode

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
	return p
}

func InitEmptyShift_exprContext(p *Shift_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArith_exprContext); ok {
			len++
		}
	}

	tst := make([]IArith_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArith_exprContext); ok {
			tst[i] = t.(IArith_exprContext)
			i++
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArith_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) AllLEFT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserLEFT_SHIFT)
}

func (s *Shift_exprContext) LEFT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT, i)
}

func (s *Shift_exprContext) AllRIGHT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserRIGHT_SHIFT)
}

func (s *Shift_exprContext) RIGHT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT, i)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (p *Python3Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Python3ParserRULE_shift_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Arith_expr()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT {
		{
			p.SetState(825)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(826)
			p.Arith_expr()
		}

		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext
	AllADD() []antlr.TerminalNode
	ADD(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
	return p
}

func InitEmptyArith_exprContext(p *Arith_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserADD)
}

func (s *Arith_exprContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, i)
}

func (s *Arith_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMINUS)
}

func (s *Arith_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, i)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArith_expr(s)
	}
}

func (p *Python3Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Python3ParserRULE_arith_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.Term()
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserADD || _la == Python3ParserMINUS {
		{
			p.SetState(833)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserADD || _la == Python3ParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(834)
			p.Term()
		}

		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFactor() []IFactorContext
	Factor(i int) IFactorContext
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllDIV() []antlr.TerminalNode
	DIV(i int) antlr.TerminalNode
	AllMOD() []antlr.TerminalNode
	MOD(i int) antlr.TerminalNode
	AllIDIV() []antlr.TerminalNode
	IDIV(i int) antlr.TerminalNode

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFactorContext); ok {
			len++
		}
	}

	tst := make([]IFactorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFactorContext); ok {
			tst[i] = t.(IFactorContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTAR)
}

func (s *TermContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, i)
}

func (s *TermContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAT)
}

func (s *TermContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, i)
}

func (s *TermContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDIV)
}

func (s *TermContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV, i)
}

func (s *TermContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMOD)
}

func (s *TermContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD, i)
}

func (s *TermContext) AllIDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserIDIV)
}

func (s *TermContext) IDIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV, i)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *Python3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Python3ParserRULE_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Factor()
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&1074659329) != 0 {
		{
			p.SetState(841)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&1074659329) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(842)
			p.Factor()
		}

		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	ADD() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT_OP() antlr.TerminalNode
	Power() IPowerContext

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) ADD() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, 0)
}

func (s *FactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *FactorContext) NOT_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_OP, 0)
}

func (s *FactorContext) Power() IPowerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFactor(s)
	}
}

func (p *Python3Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Python3ParserRULE_factor)
	var _la int

	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&35) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(849)
			p.Factor()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Power()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom_expr() IAtom_exprContext
	POWER() antlr.TerminalNode
	Factor() IFactorContext

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_power
	return p
}

func InitEmptyPowerContext(p *PowerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_power
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom_expr() IAtom_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtom_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtom_exprContext)
}

func (s *PowerContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *PowerContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *Python3Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Python3ParserRULE_power)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Atom_expr()
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserPOWER {
		{
			p.SetState(854)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(855)
			p.Factor()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtom_exprContext is an interface to support dynamic dispatch.
type IAtom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom() IAtomContext
	AWAIT() antlr.TerminalNode
	AllTrailer() []ITrailerContext
	Trailer(i int) ITrailerContext

	// IsAtom_exprContext differentiates from other interfaces.
	IsAtom_exprContext()
}

type Atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_exprContext() *Atom_exprContext {
	var p = new(Atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom_expr
	return p
}

func InitEmptyAtom_exprContext(p *Atom_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom_expr
}

func (*Atom_exprContext) IsAtom_exprContext() {}

func NewAtom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_exprContext {
	var p = new(Atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom_expr

	return p
}

func (s *Atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_exprContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Atom_exprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAWAIT, 0)
}

func (s *Atom_exprContext) AllTrailer() []ITrailerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITrailerContext); ok {
			len++
		}
	}

	tst := make([]ITrailerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITrailerContext); ok {
			tst[i] = t.(ITrailerContext)
			i++
		}
	}

	return tst
}

func (s *Atom_exprContext) Trailer(i int) ITrailerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *Atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAtom_expr(s)
	}
}

func (s *Atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAtom_expr(s)
	}
}

func (p *Python3Parser) Atom_expr() (localctx IAtom_exprContext) {
	localctx = NewAtom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Python3ParserRULE_atom_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAWAIT {
		{
			p.SetState(858)
			p.Match(Python3ParserAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(861)
		p.Atom()
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&581527301884215296) != 0 {
		{
			p.SetState(862)
			p.Trailer()
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACK() antlr.TerminalNode
	CLOSE_BRACK() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode
	NONE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	Yield_expr() IYield_exprContext
	Testlist_comp() ITestlist_compContext
	Dictorsetmaker() IDictorsetmakerContext
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *AtomContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *AtomContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *AtomContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *AtomContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACE, 0)
}

func (s *AtomContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACE, 0)
}

func (s *AtomContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *AtomContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *AtomContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *AtomContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *AtomContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_compContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictorsetmakerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING, i)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *Python3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Python3ParserRULE_atom)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		{
			p.SetState(868)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(869)
				p.Yield_expr()
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(870)
				p.Testlist_comp()
			}

		case Python3ParserCLOSE_PAREN:

		default:
		}
		{
			p.SetState(873)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACK:
		{
			p.SetState(874)
			p.Match(Python3ParserOPEN_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&584343427995402246) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(875)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(878)
			p.Match(Python3ParserCLOSE_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACE:
		{
			p.SetState(879)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&728458616071258118) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(880)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(883)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserNAME:
		{
			p.SetState(884)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserNUMBER:
		{
			p.SetState(885)
			p.Match(Python3ParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserSTRING:
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserSTRING {
			{
				p.SetState(886)
				p.Match(Python3ParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(889)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case Python3ParserELLIPSIS:
		{
			p.SetState(891)
			p.Match(Python3ParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserNONE:
		{
			p.SetState(892)
			p.Match(Python3ParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserTRUE:
		{
			p.SetState(893)
			p.Match(Python3ParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserFALSE:
		{
			p.SetState(894)
			p.Match(Python3ParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	Comp_for() IComp_forContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
	return p
}

func InitEmptyTestlist_compContext(p *Testlist_compContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_compContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (p *Python3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Python3ParserRULE_testlist_comp)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(897)
			p.Test()
		}

	case Python3ParserSTAR:
		{
			p.SetState(898)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR, Python3ParserASYNC:
		{
			p.SetState(901)
			p.Comp_for()
		}

	case Python3ParserCLOSE_PAREN, Python3ParserCOMMA, Python3ParserCLOSE_BRACK:
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(902)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(905)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
					{
						p.SetState(903)
						p.Test()
					}

				case Python3ParserSTAR:
					{
						p.SetState(904)
						p.Star_expr()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(912)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext
	OPEN_BRACK() antlr.TerminalNode
	Subscriptlist() ISubscriptlistContext
	CLOSE_BRACK() antlr.TerminalNode
	DOT() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
	return p
}

func InitEmptyTrailerContext(p *TrailerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *TrailerContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *TrailerContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *TrailerContext) DOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, 0)
}

func (s *TrailerContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (p *Python3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Python3ParserRULE_trailer)
	var _la int

	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&728458616071258118) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(918)
				p.Arglist()
			}

		}
		{
			p.SetState(921)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.Match(Python3ParserOPEN_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Subscriptlist()
		}
		{
			p.SetState(924)
			p.Match(Python3ParserCLOSE_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserDOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(926)
			p.Match(Python3ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(927)
			p.Match(Python3ParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubscript() []ISubscriptContext
	Subscript(i int) ISubscriptContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
	return p
}

func InitEmptySubscriptlistContext(p *SubscriptlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubscriptContext); ok {
			len++
		}
	}

	tst := make([]ISubscriptContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubscriptContext); ok {
			tst[i] = t.(ISubscriptContext)
			i++
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *SubscriptlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (p *Python3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Python3ParserRULE_subscriptlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Subscript()
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(931)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(932)
				p.Subscript()
			}

		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(938)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	COLON() antlr.TerminalNode
	Sliceop() ISliceopContext

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript
	return p
}

func InitEmptySubscriptContext(p *SubscriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (p *Python3Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Python3ParserRULE_subscript)
	var _la int

	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(941)
			p.Test()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(942)
				p.Test()
			}

		}
		{
			p.SetState(945)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(946)
				p.Test()
			}

		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOLON {
			{
				p.SetState(949)
				p.Sliceop()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
	return p
}

func InitEmptySliceopContext(p *SliceopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SliceopContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (p *Python3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Python3ParserRULE_sliceop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181716998) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
		{
			p.SetState(955)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
	return p
}

func InitEmptyExprlistContext(p *ExprlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (p *Python3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Python3ParserRULE_exprlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(958)
			p.Expr()
		}

	case Python3ParserSTAR:
		{
			p.SetState(959)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(962)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(963)
					p.Expr()
				}

			case Python3ParserSTAR:
				{
					p.SetState(964)
					p.Star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(972)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
	return p
}

func InitEmptyTestlistContext(p *TestlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TestlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (p *Python3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Python3ParserRULE_testlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.Test()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(976)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(977)
				p.Test()
			}

		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(983)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllPOWER() []antlr.TerminalNode
	POWER(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Comp_for() IComp_forContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
	return p
}

func InitEmptyDictorsetmakerContext(p *DictorsetmakerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *DictorsetmakerContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *DictorsetmakerContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserPOWER)
}

func (s *DictorsetmakerContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, i)
}

func (s *DictorsetmakerContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *DictorsetmakerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *DictorsetmakerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (p *Python3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Python3ParserRULE_dictorsetmaker)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.SetState(992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(986)
				p.Test()
			}
			{
				p.SetState(987)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(988)
				p.Test()
			}

		case Python3ParserPOWER:
			{
				p.SetState(990)
				p.Match(Python3ParserPOWER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(991)
				p.Expr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR, Python3ParserASYNC:
			{
				p.SetState(994)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1006)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(995)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1002)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(996)
							p.Test()
						}
						{
							p.SetState(997)
							p.Match(Python3ParserCOLON)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(998)
							p.Test()
						}

					case Python3ParserPOWER:
						{
							p.SetState(1000)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1001)
							p.Expr()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(1008)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1010)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(1009)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(1014)
				p.Test()
			}

		case Python3ParserSTAR:
			{
				p.SetState(1015)
				p.Star_expr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR, Python3ParserASYNC:
			{
				p.SetState(1018)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1019)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1022)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(1020)
							p.Test()
						}

					case Python3ParserSTAR:
						{
							p.SetState(1021)
							p.Star_expr()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(1028)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(1029)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	NAME() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Suite() ISuiteContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
	return p
}

func InitEmptyClassdefContext(p *ClassdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLASS, 0)
}

func (s *ClassdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *ClassdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuiteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ClassdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (p *Python3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Python3ParserRULE_classdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(Python3ParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1037)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(1038)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&728458616071258118) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
			{
				p.SetState(1039)
				p.Arglist()
			}

		}
		{
			p.SetState(1042)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1045)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1046)
		p.Suite()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
	return p
}

func InitEmptyArglistContext(p *ArglistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ArglistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArglist(s)
	}
}

func (p *Python3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Python3ParserRULE_arglist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Argument()
	}
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1049)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1050)
				p.Argument()
			}

		}
		p.SetState(1055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(1056)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	ASSIGN() antlr.TerminalNode
	POWER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	Comp_for() IComp_forContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *ArgumentContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *Python3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Python3ParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1059)
			p.Test()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFOR || _la == Python3ParserASYNC {
			{
				p.SetState(1060)
				p.Comp_for()
			}

		}

	case 2:
		{
			p.SetState(1063)
			p.Test()
		}
		{
			p.SetState(1064)
			p.Match(Python3ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1065)
			p.Test()
		}

	case 3:
		{
			p.SetState(1067)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1068)
			p.Test()
		}

	case 4:
		{
			p.SetState(1069)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1070)
			p.Test()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comp_for() IComp_forContext
	Comp_if() IComp_ifContext

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
	return p
}

func InitEmptyComp_iterContext(p *Comp_iterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_ifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (p *Python3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Python3ParserRULE_comp_iter)
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR, Python3ParserASYNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1073)
			p.Comp_for()
		}

	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1074)
			p.Comp_if()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Exprlist() IExprlistContext
	IN() antlr.TerminalNode
	Or_test() IOr_testContext
	ASYNC() antlr.TerminalNode
	Comp_iter() IComp_iterContext

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
	return p
}

func InitEmptyComp_forContext(p *Comp_forContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (p *Python3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Python3ParserRULE_comp_for)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserASYNC {
		{
			p.SetState(1077)
			p.Match(Python3ParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1080)
		p.Match(Python3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1081)
		p.Exprlist()
	}
	{
		p.SetState(1082)
		p.Match(Python3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1083)
		p.Or_test()
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137439092736) != 0 {
		{
			p.SetState(1084)
			p.Comp_iter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Test_nocond() ITest_nocondContext
	Comp_iter() IComp_iterContext

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
	return p
}

func InitEmptyComp_ifContext(p *Comp_ifContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *Comp_ifContext) Test_nocond() ITest_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITest_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_if(s)
	}
}

func (p *Python3Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Python3ParserRULE_comp_if)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(Python3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.Test_nocond()
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&137439092736) != 0 {
		{
			p.SetState(1089)
			p.Comp_iter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEncoding_declContext is an interface to support dynamic dispatch.
type IEncoding_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode

	// IsEncoding_declContext differentiates from other interfaces.
	IsEncoding_declContext()
}

type Encoding_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoding_declContext() *Encoding_declContext {
	var p = new(Encoding_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_encoding_decl
	return p
}

func InitEmptyEncoding_declContext(p *Encoding_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_encoding_decl
}

func (*Encoding_declContext) IsEncoding_declContext() {}

func NewEncoding_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoding_declContext {
	var p = new(Encoding_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_encoding_decl

	return p
}

func (s *Encoding_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoding_declContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Encoding_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoding_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Encoding_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterEncoding_decl(s)
	}
}

func (s *Encoding_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitEncoding_decl(s)
	}
}

func (p *Python3Parser) Encoding_decl() (localctx IEncoding_declContext) {
	localctx = NewEncoding_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Python3ParserRULE_encoding_decl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.Match(Python3ParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Yield_arg() IYield_argContext

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
	return p
}

func InitEmptyYield_exprContext(p *Yield_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Python3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (p *Python3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Python3ParserRULE_yield_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(Python3ParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&582091628181717126) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&99) != 0) {
		{
			p.SetState(1095)
			p.Yield_arg()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Test() ITestContext
	Testlist() ITestlistContext

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
	return p
}

func InitEmptyYield_argContext(p *Yield_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (p *Python3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Python3ParserRULE_yield_arg)
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1098)
			p.Match(Python3ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)
			p.Test()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserAWAIT, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1100)
			p.Testlist()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
