// Code generated from Python3Parser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package pyparser // Python3Parser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Python3Parser struct {
	Python3ParserBase
}

var Python3ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func python3parserParserInit() {
	staticData := &Python3ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "'and'", "'as'", "'assert'", "'async'", "'await'",
		"'break'", "'case'", "'class'", "'continue'", "'def'", "'del'", "'elif'",
		"'else'", "'except'", "'False'", "'finally'", "'for'", "'from'", "'global'",
		"'if'", "'import'", "'in'", "'is'", "'lambda'", "'match'", "'None'",
		"'nonlocal'", "'not'", "'or'", "'pass'", "'raise'", "'return'", "'True'",
		"'try'", "'_'", "'while'", "'with'", "'yield'", "", "", "", "", "",
		"", "", "", "", "", "'.'", "'...'", "'*'", "'('", "')'", "','", "':'",
		"';'", "'**'", "'='", "'['", "']'", "'|'", "'^'", "'&'", "'<<'", "'>>'",
		"'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'{'", "'}'", "'<'", "'>'",
		"'=='", "'>='", "'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='",
		"'*='", "'@='", "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='",
		"'**='", "'//='",
	}
	staticData.SymbolicNames = []string{
		"", "INDENT", "DEDENT", "STRING", "NUMBER", "INTEGER", "AND", "AS",
		"ASSERT", "ASYNC", "AWAIT", "BREAK", "CASE", "CLASS", "CONTINUE", "DEF",
		"DEL", "ELIF", "ELSE", "EXCEPT", "FALSE", "FINALLY", "FOR", "FROM",
		"GLOBAL", "IF", "IMPORT", "IN", "IS", "LAMBDA", "MATCH", "NONE", "NONLOCAL",
		"NOT", "OR", "PASS", "RAISE", "RETURN", "TRUE", "TRY", "UNDERSCORE",
		"WHILE", "WITH", "YIELD", "NEWLINE", "NAME", "STRING_LITERAL", "BYTES_LITERAL",
		"DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER", "BIN_INTEGER", "FLOAT_NUMBER",
		"IMAG_NUMBER", "DOT", "ELLIPSIS", "STAR", "OPEN_PAREN", "CLOSE_PAREN",
		"COMMA", "COLON", "SEMI_COLON", "POWER", "ASSIGN", "OPEN_BRACK", "CLOSE_BRACK",
		"OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT", "ADD", "MINUS",
		"DIV", "MOD", "IDIV", "NOT_OP", "OPEN_BRACE", "CLOSE_BRACE", "LESS_THAN",
		"GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2",
		"AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN",
		"DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN",
		"LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN", "IDIV_ASSIGN",
		"SKIP_", "UNKNOWN_CHAR",
	}
	staticData.RuleNames = []string{
		"single_input", "file_input", "eval_input", "decorator", "decorators",
		"decorated", "async_funcdef", "funcdef", "parameters", "typedargslist",
		"tfpdef", "varargslist", "vfpdef", "stmt", "simple_stmts", "simple_stmt",
		"expr_stmt", "annassign", "testlist_star_expr", "augassign", "del_stmt",
		"pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt",
		"yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from",
		"import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names",
		"dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt",
		"async_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt",
		"with_item", "except_clause", "block", "match_stmt", "subject_expr",
		"star_named_expressions", "star_named_expression", "case_block", "guard",
		"patterns", "pattern", "as_pattern", "or_pattern", "closed_pattern",
		"literal_pattern", "literal_expr", "complex_number", "signed_number",
		"signed_real_number", "real_number", "imaginary_number", "capture_pattern",
		"pattern_capture_target", "wildcard_pattern", "value_pattern", "attr",
		"name_or_attr", "group_pattern", "sequence_pattern", "open_sequence_pattern",
		"maybe_sequence_pattern", "maybe_star_pattern", "star_pattern", "mapping_pattern",
		"items_pattern", "key_value_pattern", "double_star_pattern", "class_pattern",
		"positional_patterns", "keyword_patterns", "keyword_pattern", "test",
		"test_nocond", "lambdef", "lambdef_nocond", "or_test", "and_test", "not_test",
		"comparison", "comp_op", "star_expr", "expr", "xor_expr", "and_expr",
		"shift_expr", "arith_expr", "term", "factor", "power", "atom_expr",
		"atom", "name", "testlist_comp", "trailer", "subscriptlist", "subscript_",
		"sliceop", "exprlist", "testlist", "dictorsetmaker", "classdef", "arglist",
		"argument", "comp_iter", "comp_for", "comp_if", "encoding_decl", "yield_expr",
		"yield_arg", "strings",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 102, 1471, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 1, 0, 1, 0,
		1, 0, 1, 0, 1, 0, 3, 0, 258, 8, 0, 1, 1, 1, 1, 5, 1, 262, 8, 1, 10, 1,
		12, 1, 265, 9, 1, 1, 1, 1, 1, 1, 2, 1, 2, 5, 2, 271, 8, 2, 10, 2, 12, 2,
		274, 9, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 282, 8, 3, 1, 3, 3,
		3, 285, 8, 3, 1, 3, 1, 3, 1, 4, 4, 4, 290, 8, 4, 11, 4, 12, 4, 291, 1,
		5, 1, 5, 1, 5, 1, 5, 3, 5, 298, 8, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 3, 7, 308, 8, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 315,
		8, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 3, 9, 322, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 328, 8, 9, 5, 9, 330, 8, 9, 10, 9, 12, 9, 333, 9, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 338, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 344, 8, 9, 5,
		9, 346, 8, 9, 10, 9, 12, 9, 349, 9, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 355,
		8, 9, 3, 9, 357, 8, 9, 3, 9, 359, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 364, 8,
		9, 3, 9, 366, 8, 9, 3, 9, 368, 8, 9, 1, 9, 1, 9, 3, 9, 372, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 378, 8, 9, 5, 9, 380, 8, 9, 10, 9, 12, 9, 383,
		9, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 389, 8, 9, 3, 9, 391, 8, 9, 3, 9, 393,
		8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 398, 8, 9, 3, 9, 400, 8, 9, 1, 10, 1, 10,
		1, 10, 3, 10, 405, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 410, 8, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 3, 11, 416, 8, 11, 5, 11, 418, 8, 11, 10, 11, 12,
		11, 421, 9, 11, 1, 11, 1, 11, 1, 11, 3, 11, 426, 8, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 3, 11, 432, 8, 11, 5, 11, 434, 8, 11, 10, 11, 12, 11, 437, 9,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 443, 8, 11, 3, 11, 445, 8, 11, 3,
		11, 447, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 452, 8, 11, 3, 11, 454, 8,
		11, 3, 11, 456, 8, 11, 1, 11, 1, 11, 3, 11, 460, 8, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 3, 11, 466, 8, 11, 5, 11, 468, 8, 11, 10, 11, 12, 11, 471, 9,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 477, 8, 11, 3, 11, 479, 8, 11, 3,
		11, 481, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 486, 8, 11, 3, 11, 488, 8,
		11, 1, 12, 1, 12, 1, 13, 1, 13, 3, 13, 494, 8, 13, 1, 14, 1, 14, 1, 14,
		5, 14, 499, 8, 14, 10, 14, 12, 14, 502, 9, 14, 1, 14, 3, 14, 505, 8, 14,
		1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 517, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 524, 8, 16, 1,
		16, 1, 16, 1, 16, 3, 16, 529, 8, 16, 5, 16, 531, 8, 16, 10, 16, 12, 16,
		534, 9, 16, 3, 16, 536, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 542,
		8, 17, 1, 18, 1, 18, 3, 18, 546, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 551,
		8, 18, 5, 18, 553, 8, 18, 10, 18, 12, 18, 556, 9, 18, 1, 18, 3, 18, 559,
		8, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 3, 22, 573, 8, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 25,
		1, 25, 3, 25, 581, 8, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3,
		27, 589, 8, 27, 3, 27, 591, 8, 27, 1, 28, 1, 28, 3, 28, 595, 8, 28, 1,
		29, 1, 29, 1, 29, 1, 30, 1, 30, 5, 30, 602, 8, 30, 10, 30, 12, 30, 605,
		9, 30, 1, 30, 1, 30, 4, 30, 609, 8, 30, 11, 30, 12, 30, 610, 3, 30, 613,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 622, 8,
		30, 1, 31, 1, 31, 1, 31, 3, 31, 627, 8, 31, 1, 32, 1, 32, 1, 32, 3, 32,
		632, 8, 32, 1, 33, 1, 33, 1, 33, 5, 33, 637, 8, 33, 10, 33, 12, 33, 640,
		9, 33, 1, 33, 3, 33, 643, 8, 33, 1, 34, 1, 34, 1, 34, 5, 34, 648, 8, 34,
		10, 34, 12, 34, 651, 9, 34, 1, 35, 1, 35, 1, 35, 5, 35, 656, 8, 35, 10,
		35, 12, 35, 659, 9, 35, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 665, 8, 36,
		10, 36, 12, 36, 668, 9, 36, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 674, 8,
		37, 10, 37, 12, 37, 677, 9, 37, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 683,
		8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 3, 39, 695, 8, 39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 701, 8, 40, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 712,
		8, 41, 10, 41, 12, 41, 715, 9, 41, 1, 41, 1, 41, 1, 41, 3, 41, 720, 8,
		41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 729, 8, 42,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 740,
		8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 4, 44, 749, 8,
		44, 11, 44, 12, 44, 750, 1, 44, 1, 44, 1, 44, 3, 44, 756, 8, 44, 1, 44,
		1, 44, 1, 44, 3, 44, 761, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 766, 8, 44,
		1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 772, 8, 45, 10, 45, 12, 45, 775, 9,
		45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 3, 46, 783, 8, 46, 1, 47,
		1, 47, 1, 47, 1, 47, 3, 47, 789, 8, 47, 3, 47, 791, 8, 47, 1, 48, 1, 48,
		1, 48, 1, 48, 4, 48, 797, 8, 48, 11, 48, 12, 48, 798, 1, 48, 1, 48, 3,
		48, 803, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 4, 49, 811, 8,
		49, 11, 49, 12, 49, 812, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 3, 50, 820,
		8, 50, 1, 50, 3, 50, 823, 8, 50, 1, 51, 1, 51, 4, 51, 827, 8, 51, 11, 51,
		12, 51, 828, 1, 51, 3, 51, 832, 8, 51, 1, 52, 1, 52, 1, 52, 3, 52, 837,
		8, 52, 1, 53, 1, 53, 1, 53, 3, 53, 842, 8, 53, 1, 53, 1, 53, 1, 53, 1,
		54, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 852, 8, 55, 1, 56, 1, 56, 3, 56,
		856, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 5, 58, 865,
		8, 58, 10, 58, 12, 58, 868, 9, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 3, 59, 878, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 3, 60, 888, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 3, 61, 898, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 908, 8, 62, 1, 63, 1, 63, 1, 63, 3,
		63, 913, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 918, 8, 64, 1, 65, 1, 65, 1,
		66, 1, 66, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70,
		1, 70, 1, 71, 1, 71, 1, 71, 4, 71, 937, 8, 71, 11, 71, 12, 71, 938, 1,
		72, 1, 72, 3, 72, 943, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74,
		3, 74, 951, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 956, 8, 74, 1, 74, 3, 74,
		959, 8, 74, 1, 75, 1, 75, 1, 75, 3, 75, 964, 8, 75, 1, 76, 1, 76, 1, 76,
		5, 76, 969, 8, 76, 10, 76, 12, 76, 972, 9, 76, 1, 76, 3, 76, 975, 8, 76,
		1, 77, 1, 77, 3, 77, 979, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 985,
		8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 992, 8, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1001, 8, 79, 1, 79, 1, 79,
		1, 79, 1, 79, 1, 79, 3, 79, 1008, 8, 79, 1, 79, 1, 79, 3, 79, 1012, 8,
		79, 1, 80, 1, 80, 1, 80, 5, 80, 1017, 8, 80, 10, 80, 12, 80, 1020, 9, 80,
		1, 81, 1, 81, 3, 81, 1024, 8, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1,
		82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1040,
		8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1048, 8, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1058, 8, 83,
		1, 83, 1, 83, 3, 83, 1062, 8, 83, 1, 84, 1, 84, 1, 84, 5, 84, 1067, 8,
		84, 10, 84, 12, 84, 1070, 9, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1075, 8, 85,
		10, 85, 12, 85, 1078, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1090, 8, 87, 1, 87, 3, 87, 1093, 8,
		87, 1, 88, 1, 88, 3, 88, 1097, 8, 88, 1, 89, 1, 89, 3, 89, 1101, 8, 89,
		1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 3, 90, 1108, 8, 90, 1, 90, 1, 90, 1,
		90, 1, 91, 1, 91, 1, 91, 5, 91, 1116, 8, 91, 10, 91, 12, 91, 1119, 9, 91,
		1, 92, 1, 92, 1, 92, 5, 92, 1124, 8, 92, 10, 92, 12, 92, 1127, 9, 92, 1,
		93, 1, 93, 1, 93, 3, 93, 1132, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 5, 94,
		1138, 8, 94, 10, 94, 12, 94, 1141, 9, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1156,
		8, 95, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1164, 8, 97, 10,
		97, 12, 97, 1167, 9, 97, 1, 98, 1, 98, 1, 98, 5, 98, 1172, 8, 98, 10, 98,
		12, 98, 1175, 9, 98, 1, 99, 1, 99, 1, 99, 5, 99, 1180, 8, 99, 10, 99, 12,
		99, 1183, 9, 99, 1, 100, 1, 100, 1, 100, 5, 100, 1188, 8, 100, 10, 100,
		12, 100, 1191, 9, 100, 1, 101, 1, 101, 1, 101, 5, 101, 1196, 8, 101, 10,
		101, 12, 101, 1199, 9, 101, 1, 102, 1, 102, 1, 102, 5, 102, 1204, 8, 102,
		10, 102, 12, 102, 1207, 9, 102, 1, 103, 1, 103, 1, 103, 3, 103, 1212, 8,
		103, 1, 104, 1, 104, 1, 104, 3, 104, 1217, 8, 104, 1, 105, 3, 105, 1220,
		8, 105, 1, 105, 1, 105, 5, 105, 1224, 8, 105, 10, 105, 12, 105, 1227, 9,
		105, 1, 106, 1, 106, 1, 106, 3, 106, 1232, 8, 106, 1, 106, 1, 106, 1, 106,
		3, 106, 1237, 8, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1242, 8, 106, 1,
		106, 1, 106, 1, 106, 1, 106, 4, 106, 1248, 8, 106, 11, 106, 12, 106, 1249,
		1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1256, 8, 106, 1, 107, 1, 107, 1,
		108, 1, 108, 3, 108, 1262, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108,
		1268, 8, 108, 5, 108, 1270, 8, 108, 10, 108, 12, 108, 1273, 9, 108, 1,
		108, 3, 108, 1276, 8, 108, 3, 108, 1278, 8, 108, 1, 109, 1, 109, 3, 109,
		1282, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3,
		109, 1291, 8, 109, 1, 110, 1, 110, 1, 110, 5, 110, 1296, 8, 110, 10, 110,
		12, 110, 1299, 9, 110, 1, 110, 3, 110, 1302, 8, 110, 1, 111, 1, 111, 3,
		111, 1306, 8, 111, 1, 111, 1, 111, 3, 111, 1310, 8, 111, 1, 111, 3, 111,
		1313, 8, 111, 3, 111, 1315, 8, 111, 1, 112, 1, 112, 3, 112, 1319, 8, 112,
		1, 113, 1, 113, 3, 113, 1323, 8, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1328,
		8, 113, 5, 113, 1330, 8, 113, 10, 113, 12, 113, 1333, 9, 113, 1, 113, 3,
		113, 1336, 8, 113, 1, 114, 1, 114, 1, 114, 5, 114, 1341, 8, 114, 10, 114,
		12, 114, 1344, 9, 114, 1, 114, 3, 114, 1347, 8, 114, 1, 115, 1, 115, 1,
		115, 1, 115, 1, 115, 1, 115, 3, 115, 1355, 8, 115, 1, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1365, 8, 115, 5, 115, 1367,
		8, 115, 10, 115, 12, 115, 1370, 9, 115, 1, 115, 3, 115, 1373, 8, 115, 3,
		115, 1375, 8, 115, 1, 115, 1, 115, 3, 115, 1379, 8, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 3, 115, 1385, 8, 115, 5, 115, 1387, 8, 115, 10, 115, 12,
		115, 1390, 9, 115, 1, 115, 3, 115, 1393, 8, 115, 3, 115, 1395, 8, 115,
		3, 115, 1397, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1403, 8,
		116, 1, 116, 3, 116, 1406, 8, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117,
		1, 117, 5, 117, 1414, 8, 117, 10, 117, 12, 117, 1417, 9, 117, 1, 117, 3,
		117, 1420, 8, 117, 1, 118, 1, 118, 3, 118, 1424, 8, 118, 1, 118, 1, 118,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1434, 8, 118, 1,
		119, 1, 119, 3, 119, 1438, 8, 119, 1, 120, 3, 120, 1441, 8, 120, 1, 120,
		1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1448, 8, 120, 1, 121, 1, 121, 1,
		121, 3, 121, 1453, 8, 121, 1, 122, 1, 122, 1, 123, 1, 123, 3, 123, 1459,
		8, 123, 1, 124, 1, 124, 1, 124, 3, 124, 1464, 8, 124, 1, 125, 4, 125, 1467,
		8, 125, 11, 125, 12, 125, 1468, 1, 125, 0, 0, 126, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
		148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
		178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206,
		208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236,
		238, 240, 242, 244, 246, 248, 250, 0, 7, 1, 0, 88, 100, 1, 0, 54, 55, 1,
		0, 69, 70, 1, 0, 71, 72, 3, 0, 56, 56, 73, 75, 86, 86, 2, 0, 71, 72, 76,
		76, 3, 0, 30, 30, 40, 40, 45, 45, 1614, 0, 257, 1, 0, 0, 0, 2, 263, 1,
		0, 0, 0, 4, 268, 1, 0, 0, 0, 6, 277, 1, 0, 0, 0, 8, 289, 1, 0, 0, 0, 10,
		293, 1, 0, 0, 0, 12, 299, 1, 0, 0, 0, 14, 302, 1, 0, 0, 0, 16, 312, 1,
		0, 0, 0, 18, 399, 1, 0, 0, 0, 20, 401, 1, 0, 0, 0, 22, 487, 1, 0, 0, 0,
		24, 489, 1, 0, 0, 0, 26, 493, 1, 0, 0, 0, 28, 495, 1, 0, 0, 0, 30, 516,
		1, 0, 0, 0, 32, 518, 1, 0, 0, 0, 34, 537, 1, 0, 0, 0, 36, 545, 1, 0, 0,
		0, 38, 560, 1, 0, 0, 0, 40, 562, 1, 0, 0, 0, 42, 565, 1, 0, 0, 0, 44, 572,
		1, 0, 0, 0, 46, 574, 1, 0, 0, 0, 48, 576, 1, 0, 0, 0, 50, 578, 1, 0, 0,
		0, 52, 582, 1, 0, 0, 0, 54, 584, 1, 0, 0, 0, 56, 594, 1, 0, 0, 0, 58, 596,
		1, 0, 0, 0, 60, 599, 1, 0, 0, 0, 62, 623, 1, 0, 0, 0, 64, 628, 1, 0, 0,
		0, 66, 633, 1, 0, 0, 0, 68, 644, 1, 0, 0, 0, 70, 652, 1, 0, 0, 0, 72, 660,
		1, 0, 0, 0, 74, 669, 1, 0, 0, 0, 76, 678, 1, 0, 0, 0, 78, 694, 1, 0, 0,
		0, 80, 696, 1, 0, 0, 0, 82, 702, 1, 0, 0, 0, 84, 721, 1, 0, 0, 0, 86, 730,
		1, 0, 0, 0, 88, 741, 1, 0, 0, 0, 90, 767, 1, 0, 0, 0, 92, 779, 1, 0, 0,
		0, 94, 784, 1, 0, 0, 0, 96, 802, 1, 0, 0, 0, 98, 804, 1, 0, 0, 0, 100,
		822, 1, 0, 0, 0, 102, 824, 1, 0, 0, 0, 104, 836, 1, 0, 0, 0, 106, 838,
		1, 0, 0, 0, 108, 846, 1, 0, 0, 0, 110, 851, 1, 0, 0, 0, 112, 855, 1, 0,
		0, 0, 114, 857, 1, 0, 0, 0, 116, 861, 1, 0, 0, 0, 118, 877, 1, 0, 0, 0,
		120, 887, 1, 0, 0, 0, 122, 897, 1, 0, 0, 0, 124, 907, 1, 0, 0, 0, 126,
		912, 1, 0, 0, 0, 128, 917, 1, 0, 0, 0, 130, 919, 1, 0, 0, 0, 132, 921,
		1, 0, 0, 0, 134, 923, 1, 0, 0, 0, 136, 925, 1, 0, 0, 0, 138, 928, 1, 0,
		0, 0, 140, 930, 1, 0, 0, 0, 142, 933, 1, 0, 0, 0, 144, 942, 1, 0, 0, 0,
		146, 944, 1, 0, 0, 0, 148, 958, 1, 0, 0, 0, 150, 960, 1, 0, 0, 0, 152,
		965, 1, 0, 0, 0, 154, 978, 1, 0, 0, 0, 156, 984, 1, 0, 0, 0, 158, 1011,
		1, 0, 0, 0, 160, 1013, 1, 0, 0, 0, 162, 1023, 1, 0, 0, 0, 164, 1028, 1,
		0, 0, 0, 166, 1061, 1, 0, 0, 0, 168, 1063, 1, 0, 0, 0, 170, 1071, 1, 0,
		0, 0, 172, 1079, 1, 0, 0, 0, 174, 1092, 1, 0, 0, 0, 176, 1096, 1, 0, 0,
		0, 178, 1098, 1, 0, 0, 0, 180, 1105, 1, 0, 0, 0, 182, 1112, 1, 0, 0, 0,
		184, 1120, 1, 0, 0, 0, 186, 1131, 1, 0, 0, 0, 188, 1133, 1, 0, 0, 0, 190,
		1155, 1, 0, 0, 0, 192, 1157, 1, 0, 0, 0, 194, 1160, 1, 0, 0, 0, 196, 1168,
		1, 0, 0, 0, 198, 1176, 1, 0, 0, 0, 200, 1184, 1, 0, 0, 0, 202, 1192, 1,
		0, 0, 0, 204, 1200, 1, 0, 0, 0, 206, 1211, 1, 0, 0, 0, 208, 1213, 1, 0,
		0, 0, 210, 1219, 1, 0, 0, 0, 212, 1255, 1, 0, 0, 0, 214, 1257, 1, 0, 0,
		0, 216, 1261, 1, 0, 0, 0, 218, 1290, 1, 0, 0, 0, 220, 1292, 1, 0, 0, 0,
		222, 1314, 1, 0, 0, 0, 224, 1316, 1, 0, 0, 0, 226, 1322, 1, 0, 0, 0, 228,
		1337, 1, 0, 0, 0, 230, 1396, 1, 0, 0, 0, 232, 1398, 1, 0, 0, 0, 234, 1410,
		1, 0, 0, 0, 236, 1433, 1, 0, 0, 0, 238, 1437, 1, 0, 0, 0, 240, 1440, 1,
		0, 0, 0, 242, 1449, 1, 0, 0, 0, 244, 1454, 1, 0, 0, 0, 246, 1456, 1, 0,
		0, 0, 248, 1463, 1, 0, 0, 0, 250, 1466, 1, 0, 0, 0, 252, 258, 5, 44, 0,
		0, 253, 258, 3, 28, 14, 0, 254, 255, 3, 78, 39, 0, 255, 256, 5, 44, 0,
		0, 256, 258, 1, 0, 0, 0, 257, 252, 1, 0, 0, 0, 257, 253, 1, 0, 0, 0, 257,
		254, 1, 0, 0, 0, 258, 1, 1, 0, 0, 0, 259, 262, 5, 44, 0, 0, 260, 262, 3,
		26, 13, 0, 261, 259, 1, 0, 0, 0, 261, 260, 1, 0, 0, 0, 262, 265, 1, 0,
		0, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 266, 1, 0, 0, 0,
		265, 263, 1, 0, 0, 0, 266, 267, 5, 0, 0, 1, 267, 3, 1, 0, 0, 0, 268, 272,
		3, 228, 114, 0, 269, 271, 5, 44, 0, 0, 270, 269, 1, 0, 0, 0, 271, 274,
		1, 0, 0, 0, 272, 270, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 275, 1, 0,
		0, 0, 274, 272, 1, 0, 0, 0, 275, 276, 5, 0, 0, 1, 276, 5, 1, 0, 0, 0, 277,
		278, 5, 86, 0, 0, 278, 284, 3, 70, 35, 0, 279, 281, 5, 57, 0, 0, 280, 282,
		3, 234, 117, 0, 281, 280, 1, 0, 0, 0, 281, 282, 1, 0, 0, 0, 282, 283, 1,
		0, 0, 0, 283, 285, 5, 58, 0, 0, 284, 279, 1, 0, 0, 0, 284, 285, 1, 0, 0,
		0, 285, 286, 1, 0, 0, 0, 286, 287, 5, 44, 0, 0, 287, 7, 1, 0, 0, 0, 288,
		290, 3, 6, 3, 0, 289, 288, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 289,
		1, 0, 0, 0, 291, 292, 1, 0, 0, 0, 292, 9, 1, 0, 0, 0, 293, 297, 3, 8, 4,
		0, 294, 298, 3, 232, 116, 0, 295, 298, 3, 14, 7, 0, 296, 298, 3, 12, 6,
		0, 297, 294, 1, 0, 0, 0, 297, 295, 1, 0, 0, 0, 297, 296, 1, 0, 0, 0, 298,
		11, 1, 0, 0, 0, 299, 300, 5, 9, 0, 0, 300, 301, 3, 14, 7, 0, 301, 13, 1,
		0, 0, 0, 302, 303, 5, 15, 0, 0, 303, 304, 3, 214, 107, 0, 304, 307, 3,
		16, 8, 0, 305, 306, 5, 87, 0, 0, 306, 308, 3, 174, 87, 0, 307, 305, 1,
		0, 0, 0, 307, 308, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309, 310, 5, 60, 0,
		0, 310, 311, 3, 96, 48, 0, 311, 15, 1, 0, 0, 0, 312, 314, 5, 57, 0, 0,
		313, 315, 3, 18, 9, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315,
		316, 1, 0, 0, 0, 316, 317, 5, 58, 0, 0, 317, 17, 1, 0, 0, 0, 318, 321,
		3, 20, 10, 0, 319, 320, 5, 63, 0, 0, 320, 322, 3, 174, 87, 0, 321, 319,
		1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 331, 1, 0, 0, 0, 323, 324, 5, 59,
		0, 0, 324, 327, 3, 20, 10, 0, 325, 326, 5, 63, 0, 0, 326, 328, 3, 174,
		87, 0, 327, 325, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 330, 1, 0, 0, 0,
		329, 323, 1, 0, 0, 0, 330, 333, 1, 0, 0, 0, 331, 329, 1, 0, 0, 0, 331,
		332, 1, 0, 0, 0, 332, 367, 1, 0, 0, 0, 333, 331, 1, 0, 0, 0, 334, 365,
		5, 59, 0, 0, 335, 337, 5, 56, 0, 0, 336, 338, 3, 20, 10, 0, 337, 336, 1,
		0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 347, 1, 0, 0, 0, 339, 340, 5, 59, 0,
		0, 340, 343, 3, 20, 10, 0, 341, 342, 5, 63, 0, 0, 342, 344, 3, 174, 87,
		0, 343, 341, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 346, 1, 0, 0, 0, 345,
		339, 1, 0, 0, 0, 346, 349, 1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 347, 348,
		1, 0, 0, 0, 348, 358, 1, 0, 0, 0, 349, 347, 1, 0, 0, 0, 350, 356, 5, 59,
		0, 0, 351, 352, 5, 62, 0, 0, 352, 354, 3, 20, 10, 0, 353, 355, 5, 59, 0,
		0, 354, 353, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355, 357, 1, 0, 0, 0, 356,
		351, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 359, 1, 0, 0, 0, 358, 350,
		1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 366, 1, 0, 0, 0, 360, 361, 5, 62,
		0, 0, 361, 363, 3, 20, 10, 0, 362, 364, 5, 59, 0, 0, 363, 362, 1, 0, 0,
		0, 363, 364, 1, 0, 0, 0, 364, 366, 1, 0, 0, 0, 365, 335, 1, 0, 0, 0, 365,
		360, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 368, 1, 0, 0, 0, 367, 334,
		1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 400, 1, 0, 0, 0, 369, 371, 5, 56,
		0, 0, 370, 372, 3, 20, 10, 0, 371, 370, 1, 0, 0, 0, 371, 372, 1, 0, 0,
		0, 372, 381, 1, 0, 0, 0, 373, 374, 5, 59, 0, 0, 374, 377, 3, 20, 10, 0,
		375, 376, 5, 63, 0, 0, 376, 378, 3, 174, 87, 0, 377, 375, 1, 0, 0, 0, 377,
		378, 1, 0, 0, 0, 378, 380, 1, 0, 0, 0, 379, 373, 1, 0, 0, 0, 380, 383,
		1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 392, 1, 0,
		0, 0, 383, 381, 1, 0, 0, 0, 384, 390, 5, 59, 0, 0, 385, 386, 5, 62, 0,
		0, 386, 388, 3, 20, 10, 0, 387, 389, 5, 59, 0, 0, 388, 387, 1, 0, 0, 0,
		388, 389, 1, 0, 0, 0, 389, 391, 1, 0, 0, 0, 390, 385, 1, 0, 0, 0, 390,
		391, 1, 0, 0, 0, 391, 393, 1, 0, 0, 0, 392, 384, 1, 0, 0, 0, 392, 393,
		1, 0, 0, 0, 393, 400, 1, 0, 0, 0, 394, 395, 5, 62, 0, 0, 395, 397, 3, 20,
		10, 0, 396, 398, 5, 59, 0, 0, 397, 396, 1, 0, 0, 0, 397, 398, 1, 0, 0,
		0, 398, 400, 1, 0, 0, 0, 399, 318, 1, 0, 0, 0, 399, 369, 1, 0, 0, 0, 399,
		394, 1, 0, 0, 0, 400, 19, 1, 0, 0, 0, 401, 404, 3, 214, 107, 0, 402, 403,
		5, 60, 0, 0, 403, 405, 3, 174, 87, 0, 404, 402, 1, 0, 0, 0, 404, 405, 1,
		0, 0, 0, 405, 21, 1, 0, 0, 0, 406, 409, 3, 24, 12, 0, 407, 408, 5, 63,
		0, 0, 408, 410, 3, 174, 87, 0, 409, 407, 1, 0, 0, 0, 409, 410, 1, 0, 0,
		0, 410, 419, 1, 0, 0, 0, 411, 412, 5, 59, 0, 0, 412, 415, 3, 24, 12, 0,
		413, 414, 5, 63, 0, 0, 414, 416, 3, 174, 87, 0, 415, 413, 1, 0, 0, 0, 415,
		416, 1, 0, 0, 0, 416, 418, 1, 0, 0, 0, 417, 411, 1, 0, 0, 0, 418, 421,
		1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 455, 1, 0,
		0, 0, 421, 419, 1, 0, 0, 0, 422, 453, 5, 59, 0, 0, 423, 425, 5, 56, 0,
		0, 424, 426, 3, 24, 12, 0, 425, 424, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0,
		426, 435, 1, 0, 0, 0, 427, 428, 5, 59, 0, 0, 428, 431, 3, 24, 12, 0, 429,
		430, 5, 63, 0, 0, 430, 432, 3, 174, 87, 0, 431, 429, 1, 0, 0, 0, 431, 432,
		1, 0, 0, 0, 432, 434, 1, 0, 0, 0, 433, 427, 1, 0, 0, 0, 434, 437, 1, 0,
		0, 0, 435, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 446, 1, 0, 0, 0,
		437, 435, 1, 0, 0, 0, 438, 444, 5, 59, 0, 0, 439, 440, 5, 62, 0, 0, 440,
		442, 3, 24, 12, 0, 441, 443, 5, 59, 0, 0, 442, 441, 1, 0, 0, 0, 442, 443,
		1, 0, 0, 0, 443, 445, 1, 0, 0, 0, 444, 439, 1, 0, 0, 0, 444, 445, 1, 0,
		0, 0, 445, 447, 1, 0, 0, 0, 446, 438, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0,
		447, 454, 1, 0, 0, 0, 448, 449, 5, 62, 0, 0, 449, 451, 3, 24, 12, 0, 450,
		452, 5, 59, 0, 0, 451, 450, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 454,
		1, 0, 0, 0, 453, 423, 1, 0, 0, 0, 453, 448, 1, 0, 0, 0, 453, 454, 1, 0,
		0, 0, 454, 456, 1, 0, 0, 0, 455, 422, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0,
		456, 488, 1, 0, 0, 0, 457, 459, 5, 56, 0, 0, 458, 460, 3, 24, 12, 0, 459,
		458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 469, 1, 0, 0, 0, 461, 462,
		5, 59, 0, 0, 462, 465, 3, 24, 12, 0, 463, 464, 5, 63, 0, 0, 464, 466, 3,
		174, 87, 0, 465, 463, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 468, 1, 0,
		0, 0, 467, 461, 1, 0, 0, 0, 468, 471, 1, 0, 0, 0, 469, 467, 1, 0, 0, 0,
		469, 470, 1, 0, 0, 0, 470, 480, 1, 0, 0, 0, 471, 469, 1, 0, 0, 0, 472,
		478, 5, 59, 0, 0, 473, 474, 5, 62, 0, 0, 474, 476, 3, 24, 12, 0, 475, 477,
		5, 59, 0, 0, 476, 475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 479, 1, 0,
		0, 0, 478, 473, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 481, 1, 0, 0, 0,
		480, 472, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 488, 1, 0, 0, 0, 482,
		483, 5, 62, 0, 0, 483, 485, 3, 24, 12, 0, 484, 486, 5, 59, 0, 0, 485, 484,
		1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 488, 1, 0, 0, 0, 487, 406, 1, 0,
		0, 0, 487, 457, 1, 0, 0, 0, 487, 482, 1, 0, 0, 0, 488, 23, 1, 0, 0, 0,
		489, 490, 3, 214, 107, 0, 490, 25, 1, 0, 0, 0, 491, 494, 3, 28, 14, 0,
		492, 494, 3, 78, 39, 0, 493, 491, 1, 0, 0, 0, 493, 492, 1, 0, 0, 0, 494,
		27, 1, 0, 0, 0, 495, 500, 3, 30, 15, 0, 496, 497, 5, 61, 0, 0, 497, 499,
		3, 30, 15, 0, 498, 496, 1, 0, 0, 0, 499, 502, 1, 0, 0, 0, 500, 498, 1,
		0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 504, 1, 0, 0, 0, 502, 500, 1, 0, 0,
		0, 503, 505, 5, 61, 0, 0, 504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505,
		506, 1, 0, 0, 0, 506, 507, 5, 44, 0, 0, 507, 29, 1, 0, 0, 0, 508, 517,
		3, 32, 16, 0, 509, 517, 3, 40, 20, 0, 510, 517, 3, 42, 21, 0, 511, 517,
		3, 44, 22, 0, 512, 517, 3, 56, 28, 0, 513, 517, 3, 72, 36, 0, 514, 517,
		3, 74, 37, 0, 515, 517, 3, 76, 38, 0, 516, 508, 1, 0, 0, 0, 516, 509, 1,
		0, 0, 0, 516, 510, 1, 0, 0, 0, 516, 511, 1, 0, 0, 0, 516, 512, 1, 0, 0,
		0, 516, 513, 1, 0, 0, 0, 516, 514, 1, 0, 0, 0, 516, 515, 1, 0, 0, 0, 517,
		31, 1, 0, 0, 0, 518, 535, 3, 36, 18, 0, 519, 536, 3, 34, 17, 0, 520, 523,
		3, 38, 19, 0, 521, 524, 3, 246, 123, 0, 522, 524, 3, 228, 114, 0, 523,
		521, 1, 0, 0, 0, 523, 522, 1, 0, 0, 0, 524, 536, 1, 0, 0, 0, 525, 528,
		5, 63, 0, 0, 526, 529, 3, 246, 123, 0, 527, 529, 3, 36, 18, 0, 528, 526,
		1, 0, 0, 0, 528, 527, 1, 0, 0, 0, 529, 531, 1, 0, 0, 0, 530, 525, 1, 0,
		0, 0, 531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0,
		533, 536, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 519, 1, 0, 0, 0, 535,
		520, 1, 0, 0, 0, 535, 532, 1, 0, 0, 0, 536, 33, 1, 0, 0, 0, 537, 538, 5,
		60, 0, 0, 538, 541, 3, 174, 87, 0, 539, 540, 5, 63, 0, 0, 540, 542, 3,
		174, 87, 0, 541, 539, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 35, 1, 0,
		0, 0, 543, 546, 3, 174, 87, 0, 544, 546, 3, 192, 96, 0, 545, 543, 1, 0,
		0, 0, 545, 544, 1, 0, 0, 0, 546, 554, 1, 0, 0, 0, 547, 550, 5, 59, 0, 0,
		548, 551, 3, 174, 87, 0, 549, 551, 3, 192, 96, 0, 550, 548, 1, 0, 0, 0,
		550, 549, 1, 0, 0, 0, 551, 553, 1, 0, 0, 0, 552, 547, 1, 0, 0, 0, 553,
		556, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 558,
		1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 557, 559, 5, 59, 0, 0, 558, 557, 1, 0,
		0, 0, 558, 559, 1, 0, 0, 0, 559, 37, 1, 0, 0, 0, 560, 561, 7, 0, 0, 0,
		561, 39, 1, 0, 0, 0, 562, 563, 5, 16, 0, 0, 563, 564, 3, 226, 113, 0, 564,
		41, 1, 0, 0, 0, 565, 566, 5, 35, 0, 0, 566, 43, 1, 0, 0, 0, 567, 573, 3,
		46, 23, 0, 568, 573, 3, 48, 24, 0, 569, 573, 3, 50, 25, 0, 570, 573, 3,
		54, 27, 0, 571, 573, 3, 52, 26, 0, 572, 567, 1, 0, 0, 0, 572, 568, 1, 0,
		0, 0, 572, 569, 1, 0, 0, 0, 572, 570, 1, 0, 0, 0, 572, 571, 1, 0, 0, 0,
		573, 45, 1, 0, 0, 0, 574, 575, 5, 11, 0, 0, 575, 47, 1, 0, 0, 0, 576, 577,
		5, 14, 0, 0, 577, 49, 1, 0, 0, 0, 578, 580, 5, 37, 0, 0, 579, 581, 3, 228,
		114, 0, 580, 579, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 51, 1, 0, 0, 0,
		582, 583, 3, 246, 123, 0, 583, 53, 1, 0, 0, 0, 584, 590, 5, 36, 0, 0, 585,
		588, 3, 174, 87, 0, 586, 587, 5, 23, 0, 0, 587, 589, 3, 174, 87, 0, 588,
		586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 591, 1, 0, 0, 0, 590, 585,
		1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 55, 1, 0, 0, 0, 592, 595, 3, 58,
		29, 0, 593, 595, 3, 60, 30, 0, 594, 592, 1, 0, 0, 0, 594, 593, 1, 0, 0,
		0, 595, 57, 1, 0, 0, 0, 596, 597, 5, 26, 0, 0, 597, 598, 3, 68, 34, 0,
		598, 59, 1, 0, 0, 0, 599, 612, 5, 23, 0, 0, 600, 602, 7, 1, 0, 0, 601,
		600, 1, 0, 0, 0, 602, 605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604,
		1, 0, 0, 0, 604, 606, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 613, 3, 70,
		35, 0, 607, 609, 7, 1, 0, 0, 608, 607, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0,
		610, 608, 1, 0, 0, 0, 610, 611, 1, 0, 0, 0, 611, 613, 1, 0, 0, 0, 612,
		603, 1, 0, 0, 0, 612, 608, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 621,
		5, 26, 0, 0, 615, 622, 5, 56, 0, 0, 616, 617, 5, 57, 0, 0, 617, 618, 3,
		66, 33, 0, 618, 619, 5, 58, 0, 0, 619, 622, 1, 0, 0, 0, 620, 622, 3, 66,
		33, 0, 621, 615, 1, 0, 0, 0, 621, 616, 1, 0, 0, 0, 621, 620, 1, 0, 0, 0,
		622, 61, 1, 0, 0, 0, 623, 626, 3, 214, 107, 0, 624, 625, 5, 7, 0, 0, 625,
		627, 3, 214, 107, 0, 626, 624, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 63,
		1, 0, 0, 0, 628, 631, 3, 70, 35, 0, 629, 630, 5, 7, 0, 0, 630, 632, 3,
		214, 107, 0, 631, 629, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 65, 1, 0,
		0, 0, 633, 638, 3, 62, 31, 0, 634, 635, 5, 59, 0, 0, 635, 637, 3, 62, 31,
		0, 636, 634, 1, 0, 0, 0, 637, 640, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 638,
		639, 1, 0, 0, 0, 639, 642, 1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 641, 643,
		5, 59, 0, 0, 642, 641, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 67, 1, 0,
		0, 0, 644, 649, 3, 64, 32, 0, 645, 646, 5, 59, 0, 0, 646, 648, 3, 64, 32,
		0, 647, 645, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 649,
		650, 1, 0, 0, 0, 650, 69, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 657, 3,
		214, 107, 0, 653, 654, 5, 54, 0, 0, 654, 656, 3, 214, 107, 0, 655, 653,
		1, 0, 0, 0, 656, 659, 1, 0, 0, 0, 657, 655, 1, 0, 0, 0, 657, 658, 1, 0,
		0, 0, 658, 71, 1, 0, 0, 0, 659, 657, 1, 0, 0, 0, 660, 661, 5, 24, 0, 0,
		661, 666, 3, 214, 107, 0, 662, 663, 5, 59, 0, 0, 663, 665, 3, 214, 107,
		0, 664, 662, 1, 0, 0, 0, 665, 668, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666,
		667, 1, 0, 0, 0, 667, 73, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 669, 670, 5,
		32, 0, 0, 670, 675, 3, 214, 107, 0, 671, 672, 5, 59, 0, 0, 672, 674, 3,
		214, 107, 0, 673, 671, 1, 0, 0, 0, 674, 677, 1, 0, 0, 0, 675, 673, 1, 0,
		0, 0, 675, 676, 1, 0, 0, 0, 676, 75, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0,
		678, 679, 5, 8, 0, 0, 679, 682, 3, 174, 87, 0, 680, 681, 5, 59, 0, 0, 681,
		683, 3, 174, 87, 0, 682, 680, 1, 0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 77,
		1, 0, 0, 0, 684, 695, 3, 82, 41, 0, 685, 695, 3, 84, 42, 0, 686, 695, 3,
		86, 43, 0, 687, 695, 3, 88, 44, 0, 688, 695, 3, 90, 45, 0, 689, 695, 3,
		14, 7, 0, 690, 695, 3, 232, 116, 0, 691, 695, 3, 10, 5, 0, 692, 695, 3,
		80, 40, 0, 693, 695, 3, 98, 49, 0, 694, 684, 1, 0, 0, 0, 694, 685, 1, 0,
		0, 0, 694, 686, 1, 0, 0, 0, 694, 687, 1, 0, 0, 0, 694, 688, 1, 0, 0, 0,
		694, 689, 1, 0, 0, 0, 694, 690, 1, 0, 0, 0, 694, 691, 1, 0, 0, 0, 694,
		692, 1, 0, 0, 0, 694, 693, 1, 0, 0, 0, 695, 79, 1, 0, 0, 0, 696, 700, 5,
		9, 0, 0, 697, 701, 3, 14, 7, 0, 698, 701, 3, 90, 45, 0, 699, 701, 3, 86,
		43, 0, 700, 697, 1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 700, 699, 1, 0, 0, 0,
		701, 81, 1, 0, 0, 0, 702, 703, 5, 25, 0, 0, 703, 704, 3, 174, 87, 0, 704,
		705, 5, 60, 0, 0, 705, 713, 3, 96, 48, 0, 706, 707, 5, 17, 0, 0, 707, 708,
		3, 174, 87, 0, 708, 709, 5, 60, 0, 0, 709, 710, 3, 96, 48, 0, 710, 712,
		1, 0, 0, 0, 711, 706, 1, 0, 0, 0, 712, 715, 1, 0, 0, 0, 713, 711, 1, 0,
		0, 0, 713, 714, 1, 0, 0, 0, 714, 719, 1, 0, 0, 0, 715, 713, 1, 0, 0, 0,
		716, 717, 5, 18, 0, 0, 717, 718, 5, 60, 0, 0, 718, 720, 3, 96, 48, 0, 719,
		716, 1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720, 83, 1, 0, 0, 0, 721, 722, 5,
		41, 0, 0, 722, 723, 3, 174, 87, 0, 723, 724, 5, 60, 0, 0, 724, 728, 3,
		96, 48, 0, 725, 726, 5, 18, 0, 0, 726, 727, 5, 60, 0, 0, 727, 729, 3, 96,
		48, 0, 728, 725, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 85, 1, 0, 0, 0,
		730, 731, 5, 22, 0, 0, 731, 732, 3, 226, 113, 0, 732, 733, 5, 27, 0, 0,
		733, 734, 3, 228, 114, 0, 734, 735, 5, 60, 0, 0, 735, 739, 3, 96, 48, 0,
		736, 737, 5, 18, 0, 0, 737, 738, 5, 60, 0, 0, 738, 740, 3, 96, 48, 0, 739,
		736, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 87, 1, 0, 0, 0, 741, 742, 5,
		39, 0, 0, 742, 743, 5, 60, 0, 0, 743, 765, 3, 96, 48, 0, 744, 745, 3, 94,
		47, 0, 745, 746, 5, 60, 0, 0, 746, 747, 3, 96, 48, 0, 747, 749, 1, 0, 0,
		0, 748, 744, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 748, 1, 0, 0, 0, 750,
		751, 1, 0, 0, 0, 751, 755, 1, 0, 0, 0, 752, 753, 5, 18, 0, 0, 753, 754,
		5, 60, 0, 0, 754, 756, 3, 96, 48, 0, 755, 752, 1, 0, 0, 0, 755, 756, 1,
		0, 0, 0, 756, 760, 1, 0, 0, 0, 757, 758, 5, 21, 0, 0, 758, 759, 5, 60,
		0, 0, 759, 761, 3, 96, 48, 0, 760, 757, 1, 0, 0, 0, 760, 761, 1, 0, 0,
		0, 761, 766, 1, 0, 0, 0, 762, 763, 5, 21, 0, 0, 763, 764, 5, 60, 0, 0,
		764, 766, 3, 96, 48, 0, 765, 748, 1, 0, 0, 0, 765, 762, 1, 0, 0, 0, 766,
		89, 1, 0, 0, 0, 767, 768, 5, 42, 0, 0, 768, 773, 3, 92, 46, 0, 769, 770,
		5, 59, 0, 0, 770, 772, 3, 92, 46, 0, 771, 769, 1, 0, 0, 0, 772, 775, 1,
		0, 0, 0, 773, 771, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 776, 1, 0, 0,
		0, 775, 773, 1, 0, 0, 0, 776, 777, 5, 60, 0, 0, 777, 778, 3, 96, 48, 0,
		778, 91, 1, 0, 0, 0, 779, 782, 3, 174, 87, 0, 780, 781, 5, 7, 0, 0, 781,
		783, 3, 194, 97, 0, 782, 780, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 93,
		1, 0, 0, 0, 784, 790, 5, 19, 0, 0, 785, 788, 3, 174, 87, 0, 786, 787, 5,
		7, 0, 0, 787, 789, 3, 214, 107, 0, 788, 786, 1, 0, 0, 0, 788, 789, 1, 0,
		0, 0, 789, 791, 1, 0, 0, 0, 790, 785, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0,
		791, 95, 1, 0, 0, 0, 792, 803, 3, 28, 14, 0, 793, 794, 5, 44, 0, 0, 794,
		796, 5, 1, 0, 0, 795, 797, 3, 26, 13, 0, 796, 795, 1, 0, 0, 0, 797, 798,
		1, 0, 0, 0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 800, 1, 0,
		0, 0, 800, 801, 5, 2, 0, 0, 801, 803, 1, 0, 0, 0, 802, 792, 1, 0, 0, 0,
		802, 793, 1, 0, 0, 0, 803, 97, 1, 0, 0, 0, 804, 805, 5, 30, 0, 0, 805,
		806, 3, 100, 50, 0, 806, 807, 5, 60, 0, 0, 807, 808, 5, 44, 0, 0, 808,
		810, 5, 1, 0, 0, 809, 811, 3, 106, 53, 0, 810, 809, 1, 0, 0, 0, 811, 812,
		1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 814, 1, 0,
		0, 0, 814, 815, 5, 2, 0, 0, 815, 99, 1, 0, 0, 0, 816, 817, 3, 104, 52,
		0, 817, 819, 5, 59, 0, 0, 818, 820, 3, 102, 51, 0, 819, 818, 1, 0, 0, 0,
		819, 820, 1, 0, 0, 0, 820, 823, 1, 0, 0, 0, 821, 823, 3, 174, 87, 0, 822,
		816, 1, 0, 0, 0, 822, 821, 1, 0, 0, 0, 823, 101, 1, 0, 0, 0, 824, 826,
		5, 59, 0, 0, 825, 827, 3, 104, 52, 0, 826, 825, 1, 0, 0, 0, 827, 828, 1,
		0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0,
		0, 830, 832, 5, 59, 0, 0, 831, 830, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832,
		103, 1, 0, 0, 0, 833, 834, 5, 56, 0, 0, 834, 837, 3, 194, 97, 0, 835, 837,
		3, 174, 87, 0, 836, 833, 1, 0, 0, 0, 836, 835, 1, 0, 0, 0, 837, 105, 1,
		0, 0, 0, 838, 839, 5, 12, 0, 0, 839, 841, 3, 110, 55, 0, 840, 842, 3, 108,
		54, 0, 841, 840, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0,
		843, 844, 5, 60, 0, 0, 844, 845, 3, 96, 48, 0, 845, 107, 1, 0, 0, 0, 846,
		847, 5, 25, 0, 0, 847, 848, 3, 174, 87, 0, 848, 109, 1, 0, 0, 0, 849, 852,
		3, 150, 75, 0, 850, 852, 3, 112, 56, 0, 851, 849, 1, 0, 0, 0, 851, 850,
		1, 0, 0, 0, 852, 111, 1, 0, 0, 0, 853, 856, 3, 114, 57, 0, 854, 856, 3,
		116, 58, 0, 855, 853, 1, 0, 0, 0, 855, 854, 1, 0, 0, 0, 856, 113, 1, 0,
		0, 0, 857, 858, 3, 116, 58, 0, 858, 859, 5, 7, 0, 0, 859, 860, 3, 136,
		68, 0, 860, 115, 1, 0, 0, 0, 861, 866, 3, 118, 59, 0, 862, 863, 5, 66,
		0, 0, 863, 865, 3, 118, 59, 0, 864, 862, 1, 0, 0, 0, 865, 868, 1, 0, 0,
		0, 866, 864, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 117, 1, 0, 0, 0, 868,
		866, 1, 0, 0, 0, 869, 878, 3, 120, 60, 0, 870, 878, 3, 134, 67, 0, 871,
		878, 3, 138, 69, 0, 872, 878, 3, 140, 70, 0, 873, 878, 3, 146, 73, 0, 874,
		878, 3, 148, 74, 0, 875, 878, 3, 158, 79, 0, 876, 878, 3, 166, 83, 0, 877,
		869, 1, 0, 0, 0, 877, 870, 1, 0, 0, 0, 877, 871, 1, 0, 0, 0, 877, 872,
		1, 0, 0, 0, 877, 873, 1, 0, 0, 0, 877, 874, 1, 0, 0, 0, 877, 875, 1, 0,
		0, 0, 877, 876, 1, 0, 0, 0, 878, 119, 1, 0, 0, 0, 879, 880, 3, 126, 63,
		0, 880, 881, 4, 60, 0, 0, 881, 888, 1, 0, 0, 0, 882, 888, 3, 124, 62, 0,
		883, 888, 3, 250, 125, 0, 884, 888, 5, 31, 0, 0, 885, 888, 5, 38, 0, 0,
		886, 888, 5, 20, 0, 0, 887, 879, 1, 0, 0, 0, 887, 882, 1, 0, 0, 0, 887,
		883, 1, 0, 0, 0, 887, 884, 1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 887, 886,
		1, 0, 0, 0, 888, 121, 1, 0, 0, 0, 889, 890, 3, 126, 63, 0, 890, 891, 4,
		61, 1, 0, 891, 898, 1, 0, 0, 0, 892, 898, 3, 124, 62, 0, 893, 898, 3, 250,
		125, 0, 894, 898, 5, 31, 0, 0, 895, 898, 5, 38, 0, 0, 896, 898, 5, 20,
		0, 0, 897, 889, 1, 0, 0, 0, 897, 892, 1, 0, 0, 0, 897, 893, 1, 0, 0, 0,
		897, 894, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 896, 1, 0, 0, 0, 898,
		123, 1, 0, 0, 0, 899, 900, 3, 128, 64, 0, 900, 901, 5, 71, 0, 0, 901, 902,
		3, 132, 66, 0, 902, 908, 1, 0, 0, 0, 903, 904, 3, 128, 64, 0, 904, 905,
		5, 72, 0, 0, 905, 906, 3, 132, 66, 0, 906, 908, 1, 0, 0, 0, 907, 899, 1,
		0, 0, 0, 907, 903, 1, 0, 0, 0, 908, 125, 1, 0, 0, 0, 909, 913, 5, 4, 0,
		0, 910, 911, 5, 72, 0, 0, 911, 913, 5, 4, 0, 0, 912, 909, 1, 0, 0, 0, 912,
		910, 1, 0, 0, 0, 913, 127, 1, 0, 0, 0, 914, 918, 3, 130, 65, 0, 915, 916,
		5, 72, 0, 0, 916, 918, 3, 130, 65, 0, 917, 914, 1, 0, 0, 0, 917, 915, 1,
		0, 0, 0, 918, 129, 1, 0, 0, 0, 919, 920, 5, 4, 0, 0, 920, 131, 1, 0, 0,
		0, 921, 922, 5, 4, 0, 0, 922, 133, 1, 0, 0, 0, 923, 924, 3, 136, 68, 0,
		924, 135, 1, 0, 0, 0, 925, 926, 3, 214, 107, 0, 926, 927, 4, 68, 2, 0,
		927, 137, 1, 0, 0, 0, 928, 929, 5, 40, 0, 0, 929, 139, 1, 0, 0, 0, 930,
		931, 3, 142, 71, 0, 931, 932, 4, 70, 3, 0, 932, 141, 1, 0, 0, 0, 933, 936,
		3, 214, 107, 0, 934, 935, 5, 54, 0, 0, 935, 937, 3, 214, 107, 0, 936, 934,
		1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0, 938, 939, 1, 0,
		0, 0, 939, 143, 1, 0, 0, 0, 940, 943, 3, 142, 71, 0, 941, 943, 3, 214,
		107, 0, 942, 940, 1, 0, 0, 0, 942, 941, 1, 0, 0, 0, 943, 145, 1, 0, 0,
		0, 944, 945, 5, 57, 0, 0, 945, 946, 3, 112, 56, 0, 946, 947, 5, 58, 0,
		0, 947, 147, 1, 0, 0, 0, 948, 950, 5, 64, 0, 0, 949, 951, 3, 152, 76, 0,
		950, 949, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952,
		959, 5, 65, 0, 0, 953, 955, 5, 57, 0, 0, 954, 956, 3, 150, 75, 0, 955,
		954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 959,
		5, 58, 0, 0, 958, 948, 1, 0, 0, 0, 958, 953, 1, 0, 0, 0, 959, 149, 1, 0,
		0, 0, 960, 961, 3, 154, 77, 0, 961, 963, 5, 59, 0, 0, 962, 964, 3, 152,
		76, 0, 963, 962, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 151, 1, 0, 0, 0,
		965, 970, 3, 154, 77, 0, 966, 967, 5, 59, 0, 0, 967, 969, 3, 154, 77, 0,
		968, 966, 1, 0, 0, 0, 969, 972, 1, 0, 0, 0, 970, 968, 1, 0, 0, 0, 970,
		971, 1, 0, 0, 0, 971, 974, 1, 0, 0, 0, 972, 970, 1, 0, 0, 0, 973, 975,
		5, 59, 0, 0, 974, 973, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 153, 1, 0,
		0, 0, 976, 979, 3, 156, 78, 0, 977, 979, 3, 112, 56, 0, 978, 976, 1, 0,
		0, 0, 978, 977, 1, 0, 0, 0, 979, 155, 1, 0, 0, 0, 980, 981, 5, 56, 0, 0,
		981, 985, 3, 136, 68, 0, 982, 983, 5, 56, 0, 0, 983, 985, 3, 138, 69, 0,
		984, 980, 1, 0, 0, 0, 984, 982, 1, 0, 0, 0, 985, 157, 1, 0, 0, 0, 986,
		987, 5, 77, 0, 0, 987, 1012, 5, 78, 0, 0, 988, 989, 5, 77, 0, 0, 989, 991,
		3, 164, 82, 0, 990, 992, 5, 59, 0, 0, 991, 990, 1, 0, 0, 0, 991, 992, 1,
		0, 0, 0, 992, 993, 1, 0, 0, 0, 993, 994, 5, 78, 0, 0, 994, 1012, 1, 0,
		0, 0, 995, 996, 5, 77, 0, 0, 996, 997, 3, 160, 80, 0, 997, 998, 5, 59,
		0, 0, 998, 1000, 3, 164, 82, 0, 999, 1001, 5, 59, 0, 0, 1000, 999, 1, 0,
		0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1003, 5, 78,
		0, 0, 1003, 1012, 1, 0, 0, 0, 1004, 1005, 5, 77, 0, 0, 1005, 1007, 3, 160,
		80, 0, 1006, 1008, 5, 59, 0, 0, 1007, 1006, 1, 0, 0, 0, 1007, 1008, 1,
		0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1010, 5, 78, 0, 0, 1010, 1012, 1,
		0, 0, 0, 1011, 986, 1, 0, 0, 0, 1011, 988, 1, 0, 0, 0, 1011, 995, 1, 0,
		0, 0, 1011, 1004, 1, 0, 0, 0, 1012, 159, 1, 0, 0, 0, 1013, 1018, 3, 162,
		81, 0, 1014, 1015, 5, 59, 0, 0, 1015, 1017, 3, 162, 81, 0, 1016, 1014,
		1, 0, 0, 0, 1017, 1020, 1, 0, 0, 0, 1018, 1016, 1, 0, 0, 0, 1018, 1019,
		1, 0, 0, 0, 1019, 161, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1021, 1024,
		3, 122, 61, 0, 1022, 1024, 3, 142, 71, 0, 1023, 1021, 1, 0, 0, 0, 1023,
		1022, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1026, 5, 60, 0, 0, 1026,
		1027, 3, 112, 56, 0, 1027, 163, 1, 0, 0, 0, 1028, 1029, 5, 62, 0, 0, 1029,
		1030, 3, 136, 68, 0, 1030, 165, 1, 0, 0, 0, 1031, 1032, 3, 144, 72, 0,
		1032, 1033, 5, 57, 0, 0, 1033, 1034, 5, 58, 0, 0, 1034, 1062, 1, 0, 0,
		0, 1035, 1036, 3, 144, 72, 0, 1036, 1037, 5, 57, 0, 0, 1037, 1039, 3, 168,
		84, 0, 1038, 1040, 5, 59, 0, 0, 1039, 1038, 1, 0, 0, 0, 1039, 1040, 1,
		0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 5, 58, 0, 0, 1042, 1062, 1,
		0, 0, 0, 1043, 1044, 3, 144, 72, 0, 1044, 1045, 5, 57, 0, 0, 1045, 1047,
		3, 170, 85, 0, 1046, 1048, 5, 59, 0, 0, 1047, 1046, 1, 0, 0, 0, 1047, 1048,
		1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 1050, 5, 58, 0, 0, 1050, 1062,
		1, 0, 0, 0, 1051, 1052, 3, 144, 72, 0, 1052, 1053, 5, 57, 0, 0, 1053, 1054,
		3, 168, 84, 0, 1054, 1055, 5, 59, 0, 0, 1055, 1057, 3, 170, 85, 0, 1056,
		1058, 5, 59, 0, 0, 1057, 1056, 1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058,
		1059, 1, 0, 0, 0, 1059, 1060, 5, 58, 0, 0, 1060, 1062, 1, 0, 0, 0, 1061,
		1031, 1, 0, 0, 0, 1061, 1035, 1, 0, 0, 0, 1061, 1043, 1, 0, 0, 0, 1061,
		1051, 1, 0, 0, 0, 1062, 167, 1, 0, 0, 0, 1063, 1068, 3, 112, 56, 0, 1064,
		1065, 5, 59, 0, 0, 1065, 1067, 3, 112, 56, 0, 1066, 1064, 1, 0, 0, 0, 1067,
		1070, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069,
		169, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1076, 3, 172, 86, 0, 1072,
		1073, 5, 59, 0, 0, 1073, 1075, 3, 172, 86, 0, 1074, 1072, 1, 0, 0, 0, 1075,
		1078, 1, 0, 0, 0, 1076, 1074, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077,
		171, 1, 0, 0, 0, 1078, 1076, 1, 0, 0, 0, 1079, 1080, 3, 214, 107, 0, 1080,
		1081, 5, 63, 0, 0, 1081, 1082, 3, 112, 56, 0, 1082, 173, 1, 0, 0, 0, 1083,
		1089, 3, 182, 91, 0, 1084, 1085, 5, 25, 0, 0, 1085, 1086, 3, 182, 91, 0,
		1086, 1087, 5, 18, 0, 0, 1087, 1088, 3, 174, 87, 0, 1088, 1090, 1, 0, 0,
		0, 1089, 1084, 1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1093, 1, 0, 0,
		0, 1091, 1093, 3, 178, 89, 0, 1092, 1083, 1, 0, 0, 0, 1092, 1091, 1, 0,
		0, 0, 1093, 175, 1, 0, 0, 0, 1094, 1097, 3, 182, 91, 0, 1095, 1097, 3,
		180, 90, 0, 1096, 1094, 1, 0, 0, 0, 1096, 1095, 1, 0, 0, 0, 1097, 177,
		1, 0, 0, 0, 1098, 1100, 5, 29, 0, 0, 1099, 1101, 3, 22, 11, 0, 1100, 1099,
		1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1103,
		5, 60, 0, 0, 1103, 1104, 3, 174, 87, 0, 1104, 179, 1, 0, 0, 0, 1105, 1107,
		5, 29, 0, 0, 1106, 1108, 3, 22, 11, 0, 1107, 1106, 1, 0, 0, 0, 1107, 1108,
		1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1110, 5, 60, 0, 0, 1110, 1111,
		3, 176, 88, 0, 1111, 181, 1, 0, 0, 0, 1112, 1117, 3, 184, 92, 0, 1113,
		1114, 5, 34, 0, 0, 1114, 1116, 3, 184, 92, 0, 1115, 1113, 1, 0, 0, 0, 1116,
		1119, 1, 0, 0, 0, 1117, 1115, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118,
		183, 1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1120, 1125, 3, 186, 93, 0, 1121,
		1122, 5, 6, 0, 0, 1122, 1124, 3, 186, 93, 0, 1123, 1121, 1, 0, 0, 0, 1124,
		1127, 1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126,
		185, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1128, 1129, 5, 33, 0, 0, 1129,
		1132, 3, 186, 93, 0, 1130, 1132, 3, 188, 94, 0, 1131, 1128, 1, 0, 0, 0,
		1131, 1130, 1, 0, 0, 0, 1132, 187, 1, 0, 0, 0, 1133, 1139, 3, 194, 97,
		0, 1134, 1135, 3, 190, 95, 0, 1135, 1136, 3, 194, 97, 0, 1136, 1138, 1,
		0, 0, 0, 1137, 1134, 1, 0, 0, 0, 1138, 1141, 1, 0, 0, 0, 1139, 1137, 1,
		0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 189, 1, 0, 0, 0, 1141, 1139, 1,
		0, 0, 0, 1142, 1156, 5, 79, 0, 0, 1143, 1156, 5, 80, 0, 0, 1144, 1156,
		5, 81, 0, 0, 1145, 1156, 5, 82, 0, 0, 1146, 1156, 5, 83, 0, 0, 1147, 1156,
		5, 84, 0, 0, 1148, 1156, 5, 85, 0, 0, 1149, 1156, 5, 27, 0, 0, 1150, 1151,
		5, 33, 0, 0, 1151, 1156, 5, 27, 0, 0, 1152, 1156, 5, 28, 0, 0, 1153, 1154,
		5, 28, 0, 0, 1154, 1156, 5, 33, 0, 0, 1155, 1142, 1, 0, 0, 0, 1155, 1143,
		1, 0, 0, 0, 1155, 1144, 1, 0, 0, 0, 1155, 1145, 1, 0, 0, 0, 1155, 1146,
		1, 0, 0, 0, 1155, 1147, 1, 0, 0, 0, 1155, 1148, 1, 0, 0, 0, 1155, 1149,
		1, 0, 0, 0, 1155, 1150, 1, 0, 0, 0, 1155, 1152, 1, 0, 0, 0, 1155, 1153,
		1, 0, 0, 0, 1156, 191, 1, 0, 0, 0, 1157, 1158, 5, 56, 0, 0, 1158, 1159,
		3, 194, 97, 0, 1159, 193, 1, 0, 0, 0, 1160, 1165, 3, 196, 98, 0, 1161,
		1162, 5, 66, 0, 0, 1162, 1164, 3, 196, 98, 0, 1163, 1161, 1, 0, 0, 0, 1164,
		1167, 1, 0, 0, 0, 1165, 1163, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166,
		195, 1, 0, 0, 0, 1167, 1165, 1, 0, 0, 0, 1168, 1173, 3, 198, 99, 0, 1169,
		1170, 5, 67, 0, 0, 1170, 1172, 3, 198, 99, 0, 1171, 1169, 1, 0, 0, 0, 1172,
		1175, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174,
		197, 1, 0, 0, 0, 1175, 1173, 1, 0, 0, 0, 1176, 1181, 3, 200, 100, 0, 1177,
		1178, 5, 68, 0, 0, 1178, 1180, 3, 200, 100, 0, 1179, 1177, 1, 0, 0, 0,
		1180, 1183, 1, 0, 0, 0, 1181, 1179, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0,
		1182, 199, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1184, 1189, 3, 202, 101,
		0, 1185, 1186, 7, 2, 0, 0, 1186, 1188, 3, 202, 101, 0, 1187, 1185, 1, 0,
		0, 0, 1188, 1191, 1, 0, 0, 0, 1189, 1187, 1, 0, 0, 0, 1189, 1190, 1, 0,
		0, 0, 1190, 201, 1, 0, 0, 0, 1191, 1189, 1, 0, 0, 0, 1192, 1197, 3, 204,
		102, 0, 1193, 1194, 7, 3, 0, 0, 1194, 1196, 3, 204, 102, 0, 1195, 1193,
		1, 0, 0, 0, 1196, 1199, 1, 0, 0, 0, 1197, 1195, 1, 0, 0, 0, 1197, 1198,
		1, 0, 0, 0, 1198, 203, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200, 1205,
		3, 206, 103, 0, 1201, 1202, 7, 4, 0, 0, 1202, 1204, 3, 206, 103, 0, 1203,
		1201, 1, 0, 0, 0, 1204, 1207, 1, 0, 0, 0, 1205, 1203, 1, 0, 0, 0, 1205,
		1206, 1, 0, 0, 0, 1206, 205, 1, 0, 0, 0, 1207, 1205, 1, 0, 0, 0, 1208,
		1209, 7, 5, 0, 0, 1209, 1212, 3, 206, 103, 0, 1210, 1212, 3, 208, 104,
		0, 1211, 1208, 1, 0, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 207, 1, 0, 0,
		0, 1213, 1216, 3, 210, 105, 0, 1214, 1215, 5, 62, 0, 0, 1215, 1217, 3,
		206, 103, 0, 1216, 1214, 1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 209,
		1, 0, 0, 0, 1218, 1220, 5, 10, 0, 0, 1219, 1218, 1, 0, 0, 0, 1219, 1220,
		1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1225, 3, 212, 106, 0, 1222, 1224,
		3, 218, 109, 0, 1223, 1222, 1, 0, 0, 0, 1224, 1227, 1, 0, 0, 0, 1225, 1223,
		1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 211, 1, 0, 0, 0, 1227, 1225,
		1, 0, 0, 0, 1228, 1231, 5, 57, 0, 0, 1229, 1232, 3, 246, 123, 0, 1230,
		1232, 3, 216, 108, 0, 1231, 1229, 1, 0, 0, 0, 1231, 1230, 1, 0, 0, 0, 1231,
		1232, 1, 0, 0, 0, 1232, 1233, 1, 0, 0, 0, 1233, 1256, 5, 58, 0, 0, 1234,
		1236, 5, 64, 0, 0, 1235, 1237, 3, 216, 108, 0, 1236, 1235, 1, 0, 0, 0,
		1236, 1237, 1, 0, 0, 0, 1237, 1238, 1, 0, 0, 0, 1238, 1256, 5, 65, 0, 0,
		1239, 1241, 5, 77, 0, 0, 1240, 1242, 3, 230, 115, 0, 1241, 1240, 1, 0,
		0, 0, 1241, 1242, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1256, 5, 78,
		0, 0, 1244, 1256, 3, 214, 107, 0, 1245, 1256, 5, 4, 0, 0, 1246, 1248, 5,
		3, 0, 0, 1247, 1246, 1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 1247, 1,
		0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 1256, 1, 0, 0, 0, 1251, 1256, 5,
		55, 0, 0, 1252, 1256, 5, 31, 0, 0, 1253, 1256, 5, 38, 0, 0, 1254, 1256,
		5, 20, 0, 0, 1255, 1228, 1, 0, 0, 0, 1255, 1234, 1, 0, 0, 0, 1255, 1239,
		1, 0, 0, 0, 1255, 1244, 1, 0, 0, 0, 1255, 1245, 1, 0, 0, 0, 1255, 1247,
		1, 0, 0, 0, 1255, 1251, 1, 0, 0, 0, 1255, 1252, 1, 0, 0, 0, 1255, 1253,
		1, 0, 0, 0, 1255, 1254, 1, 0, 0, 0, 1256, 213, 1, 0, 0, 0, 1257, 1258,
		7, 6, 0, 0, 1258, 215, 1, 0, 0, 0, 1259, 1262, 3, 174, 87, 0, 1260, 1262,
		3, 192, 96, 0, 1261, 1259, 1, 0, 0, 0, 1261, 1260, 1, 0, 0, 0, 1262, 1277,
		1, 0, 0, 0, 1263, 1278, 3, 240, 120, 0, 1264, 1267, 5, 59, 0, 0, 1265,
		1268, 3, 174, 87, 0, 1266, 1268, 3, 192, 96, 0, 1267, 1265, 1, 0, 0, 0,
		1267, 1266, 1, 0, 0, 0, 1268, 1270, 1, 0, 0, 0, 1269, 1264, 1, 0, 0, 0,
		1270, 1273, 1, 0, 0, 0, 1271, 1269, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0,
		1272, 1275, 1, 0, 0, 0, 1273, 1271, 1, 0, 0, 0, 1274, 1276, 5, 59, 0, 0,
		1275, 1274, 1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1278, 1, 0, 0, 0,
		1277, 1263, 1, 0, 0, 0, 1277, 1271, 1, 0, 0, 0, 1278, 217, 1, 0, 0, 0,
		1279, 1281, 5, 57, 0, 0, 1280, 1282, 3, 234, 117, 0, 1281, 1280, 1, 0,
		0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1291, 5, 58,
		0, 0, 1284, 1285, 5, 64, 0, 0, 1285, 1286, 3, 220, 110, 0, 1286, 1287,
		5, 65, 0, 0, 1287, 1291, 1, 0, 0, 0, 1288, 1289, 5, 54, 0, 0, 1289, 1291,
		3, 214, 107, 0, 1290, 1279, 1, 0, 0, 0, 1290, 1284, 1, 0, 0, 0, 1290, 1288,
		1, 0, 0, 0, 1291, 219, 1, 0, 0, 0, 1292, 1297, 3, 222, 111, 0, 1293, 1294,
		5, 59, 0, 0, 1294, 1296, 3, 222, 111, 0, 1295, 1293, 1, 0, 0, 0, 1296,
		1299, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298,
		1301, 1, 0, 0, 0, 1299, 1297, 1, 0, 0, 0, 1300, 1302, 5, 59, 0, 0, 1301,
		1300, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 221, 1, 0, 0, 0, 1303,
		1315, 3, 174, 87, 0, 1304, 1306, 3, 174, 87, 0, 1305, 1304, 1, 0, 0, 0,
		1305, 1306, 1, 0, 0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1309, 5, 60, 0, 0,
		1308, 1310, 3, 174, 87, 0, 1309, 1308, 1, 0, 0, 0, 1309, 1310, 1, 0, 0,
		0, 1310, 1312, 1, 0, 0, 0, 1311, 1313, 3, 224, 112, 0, 1312, 1311, 1, 0,
		0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1315, 1, 0, 0, 0, 1314, 1303, 1, 0,
		0, 0, 1314, 1305, 1, 0, 0, 0, 1315, 223, 1, 0, 0, 0, 1316, 1318, 5, 60,
		0, 0, 1317, 1319, 3, 174, 87, 0, 1318, 1317, 1, 0, 0, 0, 1318, 1319, 1,
		0, 0, 0, 1319, 225, 1, 0, 0, 0, 1320, 1323, 3, 194, 97, 0, 1321, 1323,
		3, 192, 96, 0, 1322, 1320, 1, 0, 0, 0, 1322, 1321, 1, 0, 0, 0, 1323, 1331,
		1, 0, 0, 0, 1324, 1327, 5, 59, 0, 0, 1325, 1328, 3, 194, 97, 0, 1326, 1328,
		3, 192, 96, 0, 1327, 1325, 1, 0, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 1330,
		1, 0, 0, 0, 1329, 1324, 1, 0, 0, 0, 1330, 1333, 1, 0, 0, 0, 1331, 1329,
		1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1335, 1, 0, 0, 0, 1333, 1331,
		1, 0, 0, 0, 1334, 1336, 5, 59, 0, 0, 1335, 1334, 1, 0, 0, 0, 1335, 1336,
		1, 0, 0, 0, 1336, 227, 1, 0, 0, 0, 1337, 1342, 3, 174, 87, 0, 1338, 1339,
		5, 59, 0, 0, 1339, 1341, 3, 174, 87, 0, 1340, 1338, 1, 0, 0, 0, 1341, 1344,
		1, 0, 0, 0, 1342, 1340, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1346,
		1, 0, 0, 0, 1344, 1342, 1, 0, 0, 0, 1345, 1347, 5, 59, 0, 0, 1346, 1345,
		1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 229, 1, 0, 0, 0, 1348, 1349,
		3, 174, 87, 0, 1349, 1350, 5, 60, 0, 0, 1350, 1351, 3, 174, 87, 0, 1351,
		1355, 1, 0, 0, 0, 1352, 1353, 5, 62, 0, 0, 1353, 1355, 3, 194, 97, 0, 1354,
		1348, 1, 0, 0, 0, 1354, 1352, 1, 0, 0, 0, 1355, 1374, 1, 0, 0, 0, 1356,
		1375, 3, 240, 120, 0, 1357, 1364, 5, 59, 0, 0, 1358, 1359, 3, 174, 87,
		0, 1359, 1360, 5, 60, 0, 0, 1360, 1361, 3, 174, 87, 0, 1361, 1365, 1, 0,
		0, 0, 1362, 1363, 5, 62, 0, 0, 1363, 1365, 3, 194, 97, 0, 1364, 1358, 1,
		0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1365, 1367, 1, 0, 0, 0, 1366, 1357, 1,
		0, 0, 0, 1367, 1370, 1, 0, 0, 0, 1368, 1366, 1, 0, 0, 0, 1368, 1369, 1,
		0, 0, 0, 1369, 1372, 1, 0, 0, 0, 1370, 1368, 1, 0, 0, 0, 1371, 1373, 5,
		59, 0, 0, 1372, 1371, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 1375, 1,
		0, 0, 0, 1374, 1356, 1, 0, 0, 0, 1374, 1368, 1, 0, 0, 0, 1375, 1397, 1,
		0, 0, 0, 1376, 1379, 3, 174, 87, 0, 1377, 1379, 3, 192, 96, 0, 1378, 1376,
		1, 0, 0, 0, 1378, 1377, 1, 0, 0, 0, 1379, 1394, 1, 0, 0, 0, 1380, 1395,
		3, 240, 120, 0, 1381, 1384, 5, 59, 0, 0, 1382, 1385, 3, 174, 87, 0, 1383,
		1385, 3, 192, 96, 0, 1384, 1382, 1, 0, 0, 0, 1384, 1383, 1, 0, 0, 0, 1385,
		1387, 1, 0, 0, 0, 1386, 1381, 1, 0, 0, 0, 1387, 1390, 1, 0, 0, 0, 1388,
		1386, 1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1392, 1, 0, 0, 0, 1390,
		1388, 1, 0, 0, 0, 1391, 1393, 5, 59, 0, 0, 1392, 1391, 1, 0, 0, 0, 1392,
		1393, 1, 0, 0, 0, 1393, 1395, 1, 0, 0, 0, 1394, 1380, 1, 0, 0, 0, 1394,
		1388, 1, 0, 0, 0, 1395, 1397, 1, 0, 0, 0, 1396, 1354, 1, 0, 0, 0, 1396,
		1378, 1, 0, 0, 0, 1397, 231, 1, 0, 0, 0, 1398, 1399, 5, 13, 0, 0, 1399,
		1405, 3, 214, 107, 0, 1400, 1402, 5, 57, 0, 0, 1401, 1403, 3, 234, 117,
		0, 1402, 1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1404, 1, 0, 0,
		0, 1404, 1406, 5, 58, 0, 0, 1405, 1400, 1, 0, 0, 0, 1405, 1406, 1, 0, 0,
		0, 1406, 1407, 1, 0, 0, 0, 1407, 1408, 5, 60, 0, 0, 1408, 1409, 3, 96,
		48, 0, 1409, 233, 1, 0, 0, 0, 1410, 1415, 3, 236, 118, 0, 1411, 1412, 5,
		59, 0, 0, 1412, 1414, 3, 236, 118, 0, 1413, 1411, 1, 0, 0, 0, 1414, 1417,
		1, 0, 0, 0, 1415, 1413, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1419,
		1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1418, 1420, 5, 59, 0, 0, 1419, 1418,
		1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 235, 1, 0, 0, 0, 1421, 1423,
		3, 174, 87, 0, 1422, 1424, 3, 240, 120, 0, 1423, 1422, 1, 0, 0, 0, 1423,
		1424, 1, 0, 0, 0, 1424, 1434, 1, 0, 0, 0, 1425, 1426, 3, 174, 87, 0, 1426,
		1427, 5, 63, 0, 0, 1427, 1428, 3, 174, 87, 0, 1428, 1434, 1, 0, 0, 0, 1429,
		1430, 5, 62, 0, 0, 1430, 1434, 3, 174, 87, 0, 1431, 1432, 5, 56, 0, 0,
		1432, 1434, 3, 174, 87, 0, 1433, 1421, 1, 0, 0, 0, 1433, 1425, 1, 0, 0,
		0, 1433, 1429, 1, 0, 0, 0, 1433, 1431, 1, 0, 0, 0, 1434, 237, 1, 0, 0,
		0, 1435, 1438, 3, 240, 120, 0, 1436, 1438, 3, 242, 121, 0, 1437, 1435,
		1, 0, 0, 0, 1437, 1436, 1, 0, 0, 0, 1438, 239, 1, 0, 0, 0, 1439, 1441,
		5, 9, 0, 0, 1440, 1439, 1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441, 1442,
		1, 0, 0, 0, 1442, 1443, 5, 22, 0, 0, 1443, 1444, 3, 226, 113, 0, 1444,
		1445, 5, 27, 0, 0, 1445, 1447, 3, 182, 91, 0, 1446, 1448, 3, 238, 119,
		0, 1447, 1446, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448, 241, 1, 0, 0,
		0, 1449, 1450, 5, 25, 0, 0, 1450, 1452, 3, 176, 88, 0, 1451, 1453, 3, 238,
		119, 0, 1452, 1451, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 243, 1, 0,
		0, 0, 1454, 1455, 3, 214, 107, 0, 1455, 245, 1, 0, 0, 0, 1456, 1458, 5,
		43, 0, 0, 1457, 1459, 3, 248, 124, 0, 1458, 1457, 1, 0, 0, 0, 1458, 1459,
		1, 0, 0, 0, 1459, 247, 1, 0, 0, 0, 1460, 1461, 5, 23, 0, 0, 1461, 1464,
		3, 174, 87, 0, 1462, 1464, 3, 228, 114, 0, 1463, 1460, 1, 0, 0, 0, 1463,
		1462, 1, 0, 0, 0, 1464, 249, 1, 0, 0, 0, 1465, 1467, 5, 3, 0, 0, 1466,
		1465, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1466, 1, 0, 0, 0, 1468,
		1469, 1, 0, 0, 0, 1469, 251, 1, 0, 0, 0, 205, 257, 261, 263, 272, 281,
		284, 291, 297, 307, 314, 321, 327, 331, 337, 343, 347, 354, 356, 358, 363,
		365, 367, 371, 377, 381, 388, 390, 392, 397, 399, 404, 409, 415, 419, 425,
		431, 435, 442, 444, 446, 451, 453, 455, 459, 465, 469, 476, 478, 480, 485,
		487, 493, 500, 504, 516, 523, 528, 532, 535, 541, 545, 550, 554, 558, 572,
		580, 588, 590, 594, 603, 610, 612, 621, 626, 631, 638, 642, 649, 657, 666,
		675, 682, 694, 700, 713, 719, 728, 739, 750, 755, 760, 765, 773, 782, 788,
		790, 798, 802, 812, 819, 822, 828, 831, 836, 841, 851, 855, 866, 877, 887,
		897, 907, 912, 917, 938, 942, 950, 955, 958, 963, 970, 974, 978, 984, 991,
		1000, 1007, 1011, 1018, 1023, 1039, 1047, 1057, 1061, 1068, 1076, 1089,
		1092, 1096, 1100, 1107, 1117, 1125, 1131, 1139, 1155, 1165, 1173, 1181,
		1189, 1197, 1205, 1211, 1216, 1219, 1225, 1231, 1236, 1241, 1249, 1255,
		1261, 1267, 1271, 1275, 1277, 1281, 1290, 1297, 1301, 1305, 1309, 1312,
		1314, 1318, 1322, 1327, 1331, 1335, 1342, 1346, 1354, 1364, 1368, 1372,
		1374, 1378, 1384, 1388, 1392, 1394, 1396, 1402, 1405, 1415, 1419, 1423,
		1433, 1437, 1440, 1447, 1452, 1458, 1463, 1468,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Python3ParserInit initializes any static state used to implement Python3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPython3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Python3ParserInit() {
	staticData := &Python3ParserParserStaticData
	staticData.once.Do(python3parserParserInit)
}

// NewPython3Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewPython3Parser(input antlr.TokenStream) *Python3Parser {
	Python3ParserInit()
	this := new(Python3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Python3ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Python3Parser.g4"

	return this
}

// Python3Parser tokens.
const (
	Python3ParserEOF                = antlr.TokenEOF
	Python3ParserINDENT             = 1
	Python3ParserDEDENT             = 2
	Python3ParserSTRING             = 3
	Python3ParserNUMBER             = 4
	Python3ParserINTEGER            = 5
	Python3ParserAND                = 6
	Python3ParserAS                 = 7
	Python3ParserASSERT             = 8
	Python3ParserASYNC              = 9
	Python3ParserAWAIT              = 10
	Python3ParserBREAK              = 11
	Python3ParserCASE               = 12
	Python3ParserCLASS              = 13
	Python3ParserCONTINUE           = 14
	Python3ParserDEF                = 15
	Python3ParserDEL                = 16
	Python3ParserELIF               = 17
	Python3ParserELSE               = 18
	Python3ParserEXCEPT             = 19
	Python3ParserFALSE              = 20
	Python3ParserFINALLY            = 21
	Python3ParserFOR                = 22
	Python3ParserFROM               = 23
	Python3ParserGLOBAL             = 24
	Python3ParserIF                 = 25
	Python3ParserIMPORT             = 26
	Python3ParserIN                 = 27
	Python3ParserIS                 = 28
	Python3ParserLAMBDA             = 29
	Python3ParserMATCH              = 30
	Python3ParserNONE               = 31
	Python3ParserNONLOCAL           = 32
	Python3ParserNOT                = 33
	Python3ParserOR                 = 34
	Python3ParserPASS               = 35
	Python3ParserRAISE              = 36
	Python3ParserRETURN             = 37
	Python3ParserTRUE               = 38
	Python3ParserTRY                = 39
	Python3ParserUNDERSCORE         = 40
	Python3ParserWHILE              = 41
	Python3ParserWITH               = 42
	Python3ParserYIELD              = 43
	Python3ParserNEWLINE            = 44
	Python3ParserNAME               = 45
	Python3ParserSTRING_LITERAL     = 46
	Python3ParserBYTES_LITERAL      = 47
	Python3ParserDECIMAL_INTEGER    = 48
	Python3ParserOCT_INTEGER        = 49
	Python3ParserHEX_INTEGER        = 50
	Python3ParserBIN_INTEGER        = 51
	Python3ParserFLOAT_NUMBER       = 52
	Python3ParserIMAG_NUMBER        = 53
	Python3ParserDOT                = 54
	Python3ParserELLIPSIS           = 55
	Python3ParserSTAR               = 56
	Python3ParserOPEN_PAREN         = 57
	Python3ParserCLOSE_PAREN        = 58
	Python3ParserCOMMA              = 59
	Python3ParserCOLON              = 60
	Python3ParserSEMI_COLON         = 61
	Python3ParserPOWER              = 62
	Python3ParserASSIGN             = 63
	Python3ParserOPEN_BRACK         = 64
	Python3ParserCLOSE_BRACK        = 65
	Python3ParserOR_OP              = 66
	Python3ParserXOR                = 67
	Python3ParserAND_OP             = 68
	Python3ParserLEFT_SHIFT         = 69
	Python3ParserRIGHT_SHIFT        = 70
	Python3ParserADD                = 71
	Python3ParserMINUS              = 72
	Python3ParserDIV                = 73
	Python3ParserMOD                = 74
	Python3ParserIDIV               = 75
	Python3ParserNOT_OP             = 76
	Python3ParserOPEN_BRACE         = 77
	Python3ParserCLOSE_BRACE        = 78
	Python3ParserLESS_THAN          = 79
	Python3ParserGREATER_THAN       = 80
	Python3ParserEQUALS             = 81
	Python3ParserGT_EQ              = 82
	Python3ParserLT_EQ              = 83
	Python3ParserNOT_EQ_1           = 84
	Python3ParserNOT_EQ_2           = 85
	Python3ParserAT                 = 86
	Python3ParserARROW              = 87
	Python3ParserADD_ASSIGN         = 88
	Python3ParserSUB_ASSIGN         = 89
	Python3ParserMULT_ASSIGN        = 90
	Python3ParserAT_ASSIGN          = 91
	Python3ParserDIV_ASSIGN         = 92
	Python3ParserMOD_ASSIGN         = 93
	Python3ParserAND_ASSIGN         = 94
	Python3ParserOR_ASSIGN          = 95
	Python3ParserXOR_ASSIGN         = 96
	Python3ParserLEFT_SHIFT_ASSIGN  = 97
	Python3ParserRIGHT_SHIFT_ASSIGN = 98
	Python3ParserPOWER_ASSIGN       = 99
	Python3ParserIDIV_ASSIGN        = 100
	Python3ParserSKIP_              = 101
	Python3ParserUNKNOWN_CHAR       = 102
)

// Python3Parser rules.
const (
	Python3ParserRULE_single_input           = 0
	Python3ParserRULE_file_input             = 1
	Python3ParserRULE_eval_input             = 2
	Python3ParserRULE_decorator              = 3
	Python3ParserRULE_decorators             = 4
	Python3ParserRULE_decorated              = 5
	Python3ParserRULE_async_funcdef          = 6
	Python3ParserRULE_funcdef                = 7
	Python3ParserRULE_parameters             = 8
	Python3ParserRULE_typedargslist          = 9
	Python3ParserRULE_tfpdef                 = 10
	Python3ParserRULE_varargslist            = 11
	Python3ParserRULE_vfpdef                 = 12
	Python3ParserRULE_stmt                   = 13
	Python3ParserRULE_simple_stmts           = 14
	Python3ParserRULE_simple_stmt            = 15
	Python3ParserRULE_expr_stmt              = 16
	Python3ParserRULE_annassign              = 17
	Python3ParserRULE_testlist_star_expr     = 18
	Python3ParserRULE_augassign              = 19
	Python3ParserRULE_del_stmt               = 20
	Python3ParserRULE_pass_stmt              = 21
	Python3ParserRULE_flow_stmt              = 22
	Python3ParserRULE_break_stmt             = 23
	Python3ParserRULE_continue_stmt          = 24
	Python3ParserRULE_return_stmt            = 25
	Python3ParserRULE_yield_stmt             = 26
	Python3ParserRULE_raise_stmt             = 27
	Python3ParserRULE_import_stmt            = 28
	Python3ParserRULE_import_name            = 29
	Python3ParserRULE_import_from            = 30
	Python3ParserRULE_import_as_name         = 31
	Python3ParserRULE_dotted_as_name         = 32
	Python3ParserRULE_import_as_names        = 33
	Python3ParserRULE_dotted_as_names        = 34
	Python3ParserRULE_dotted_name            = 35
	Python3ParserRULE_global_stmt            = 36
	Python3ParserRULE_nonlocal_stmt          = 37
	Python3ParserRULE_assert_stmt            = 38
	Python3ParserRULE_compound_stmt          = 39
	Python3ParserRULE_async_stmt             = 40
	Python3ParserRULE_if_stmt                = 41
	Python3ParserRULE_while_stmt             = 42
	Python3ParserRULE_for_stmt               = 43
	Python3ParserRULE_try_stmt               = 44
	Python3ParserRULE_with_stmt              = 45
	Python3ParserRULE_with_item              = 46
	Python3ParserRULE_except_clause          = 47
	Python3ParserRULE_block                  = 48
	Python3ParserRULE_match_stmt             = 49
	Python3ParserRULE_subject_expr           = 50
	Python3ParserRULE_star_named_expressions = 51
	Python3ParserRULE_star_named_expression  = 52
	Python3ParserRULE_case_block             = 53
	Python3ParserRULE_guard                  = 54
	Python3ParserRULE_patterns               = 55
	Python3ParserRULE_pattern                = 56
	Python3ParserRULE_as_pattern             = 57
	Python3ParserRULE_or_pattern             = 58
	Python3ParserRULE_closed_pattern         = 59
	Python3ParserRULE_literal_pattern        = 60
	Python3ParserRULE_literal_expr           = 61
	Python3ParserRULE_complex_number         = 62
	Python3ParserRULE_signed_number          = 63
	Python3ParserRULE_signed_real_number     = 64
	Python3ParserRULE_real_number            = 65
	Python3ParserRULE_imaginary_number       = 66
	Python3ParserRULE_capture_pattern        = 67
	Python3ParserRULE_pattern_capture_target = 68
	Python3ParserRULE_wildcard_pattern       = 69
	Python3ParserRULE_value_pattern          = 70
	Python3ParserRULE_attr                   = 71
	Python3ParserRULE_name_or_attr           = 72
	Python3ParserRULE_group_pattern          = 73
	Python3ParserRULE_sequence_pattern       = 74
	Python3ParserRULE_open_sequence_pattern  = 75
	Python3ParserRULE_maybe_sequence_pattern = 76
	Python3ParserRULE_maybe_star_pattern     = 77
	Python3ParserRULE_star_pattern           = 78
	Python3ParserRULE_mapping_pattern        = 79
	Python3ParserRULE_items_pattern          = 80
	Python3ParserRULE_key_value_pattern      = 81
	Python3ParserRULE_double_star_pattern    = 82
	Python3ParserRULE_class_pattern          = 83
	Python3ParserRULE_positional_patterns    = 84
	Python3ParserRULE_keyword_patterns       = 85
	Python3ParserRULE_keyword_pattern        = 86
	Python3ParserRULE_test                   = 87
	Python3ParserRULE_test_nocond            = 88
	Python3ParserRULE_lambdef                = 89
	Python3ParserRULE_lambdef_nocond         = 90
	Python3ParserRULE_or_test                = 91
	Python3ParserRULE_and_test               = 92
	Python3ParserRULE_not_test               = 93
	Python3ParserRULE_comparison             = 94
	Python3ParserRULE_comp_op                = 95
	Python3ParserRULE_star_expr              = 96
	Python3ParserRULE_expr                   = 97
	Python3ParserRULE_xor_expr               = 98
	Python3ParserRULE_and_expr               = 99
	Python3ParserRULE_shift_expr             = 100
	Python3ParserRULE_arith_expr             = 101
	Python3ParserRULE_term                   = 102
	Python3ParserRULE_factor                 = 103
	Python3ParserRULE_power                  = 104
	Python3ParserRULE_atom_expr              = 105
	Python3ParserRULE_atom                   = 106
	Python3ParserRULE_name                   = 107
	Python3ParserRULE_testlist_comp          = 108
	Python3ParserRULE_trailer                = 109
	Python3ParserRULE_subscriptlist          = 110
	Python3ParserRULE_subscript_             = 111
	Python3ParserRULE_sliceop                = 112
	Python3ParserRULE_exprlist               = 113
	Python3ParserRULE_testlist               = 114
	Python3ParserRULE_dictorsetmaker         = 115
	Python3ParserRULE_classdef               = 116
	Python3ParserRULE_arglist                = 117
	Python3ParserRULE_argument               = 118
	Python3ParserRULE_comp_iter              = 119
	Python3ParserRULE_comp_for               = 120
	Python3ParserRULE_comp_if                = 121
	Python3ParserRULE_encoding_decl          = 122
	Python3ParserRULE_yield_expr             = 123
	Python3ParserRULE_yield_arg              = 124
	Python3ParserRULE_strings                = 125
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEWLINE() antlr.TerminalNode
	Simple_stmts() ISimple_stmtsContext
	Compound_stmt() ICompound_stmtContext

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
	return p
}

func InitEmptySingle_inputContext(p *Single_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmts() ISimple_stmtsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtsContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (p *Python3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python3ParserRULE_single_input)
	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(252)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(253)
			p.Simple_stmts()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(254)
			p.Compound_stmt()
		}
		{
			p.SetState(255)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
	return p
}

func InitEmptyFile_inputContext(p *File_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (p *Python3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python3ParserRULE_file_input)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&252271930291384088) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4206977) != 0) {
		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNEWLINE:
			{
				p.SetState(259)
				p.Match(Python3ParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserASSERT, Python3ParserASYNC, Python3ParserAWAIT, Python3ParserBREAK, Python3ParserCLASS, Python3ParserCONTINUE, Python3ParserDEF, Python3ParserDEL, Python3ParserFALSE, Python3ParserFOR, Python3ParserFROM, Python3ParserGLOBAL, Python3ParserIF, Python3ParserIMPORT, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNONLOCAL, Python3ParserNOT, Python3ParserPASS, Python3ParserRAISE, Python3ParserRETURN, Python3ParserTRUE, Python3ParserTRY, Python3ParserUNDERSCORE, Python3ParserWHILE, Python3ParserWITH, Python3ParserYIELD, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE, Python3ParserAT:
			{
				p.SetState(260)
				p.Stmt()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(266)
		p.Match(Python3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Testlist() ITestlistContext
	EOF() antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
	return p
}

func InitEmptyEval_inputContext(p *Eval_inputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (p *Python3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python3ParserRULE_eval_input)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(268)
		p.Testlist()
	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserNEWLINE {
		{
			p.SetState(269)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(275)
		p.Match(Python3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	Dotted_name() IDotted_nameContext
	NEWLINE() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
	return p
}

func InitEmptyDecoratorContext(p *DecoratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) AT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, 0)
}

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *DecoratorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *DecoratorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (p *Python3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python3ParserRULE_decorator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(Python3ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(278)
		p.Dotted_name()
	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(279)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4863924168670839832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(280)
				p.Arglist()
			}

		}
		{
			p.SetState(283)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(286)
		p.Match(Python3ParserNEWLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecorator() []IDecoratorContext
	Decorator(i int) IDecoratorContext

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
	return p
}

func InitEmptyDecoratorsContext(p *DecoratorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecoratorContext); ok {
			len++
		}
	}

	tst := make([]IDecoratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecoratorContext); ok {
			tst[i] = t.(IDecoratorContext)
			i++
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorators(s)
	}
}

func (p *Python3Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python3ParserRULE_decorators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Python3ParserAT {
		{
			p.SetState(288)
			p.Decorator()
		}

		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Decorators() IDecoratorsContext
	Classdef() IClassdefContext
	Funcdef() IFuncdefContext
	Async_funcdef() IAsync_funcdefContext

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
	return p
}

func InitEmptyDecoratedContext(p *DecoratedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) Async_funcdef() IAsync_funcdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsync_funcdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsync_funcdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDecorated(s)
	}
}

func (p *Python3Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python3ParserRULE_decorated)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Decorators()
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCLASS:
		{
			p.SetState(294)
			p.Classdef()
		}

	case Python3ParserDEF:
		{
			p.SetState(295)
			p.Funcdef()
		}

	case Python3ParserASYNC:
		{
			p.SetState(296)
			p.Async_funcdef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsync_funcdefContext is an interface to support dynamic dispatch.
type IAsync_funcdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYNC() antlr.TerminalNode
	Funcdef() IFuncdefContext

	// IsAsync_funcdefContext differentiates from other interfaces.
	IsAsync_funcdefContext()
}

type Async_funcdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_funcdefContext() *Async_funcdefContext {
	var p = new(Async_funcdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_funcdef
	return p
}

func InitEmptyAsync_funcdefContext(p *Async_funcdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_funcdef
}

func (*Async_funcdefContext) IsAsync_funcdefContext() {}

func NewAsync_funcdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_funcdefContext {
	var p = new(Async_funcdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_funcdef

	return p
}

func (s *Async_funcdefContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_funcdefContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_funcdefContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_funcdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_funcdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Async_funcdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAsync_funcdef(s)
	}
}

func (s *Async_funcdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAsync_funcdef(s)
	}
}

func (p *Python3Parser) Async_funcdef() (localctx IAsync_funcdefContext) {
	localctx = NewAsync_funcdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python3ParserRULE_async_funcdef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.Match(Python3ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(300)
		p.Funcdef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEF() antlr.TerminalNode
	Name() INameContext
	Parameters() IParametersContext
	COLON() antlr.TerminalNode
	Block() IBlockContext
	ARROW() antlr.TerminalNode
	Test() ITestContext

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
	return p
}

func InitEmptyFuncdefContext(p *FuncdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEF, 0)
}

func (s *FuncdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *FuncdefContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FuncdefContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Python3ParserARROW, 0)
}

func (s *FuncdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (p *Python3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python3ParserRULE_funcdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(Python3ParserDEF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(303)
		p.Name()
	}
	{
		p.SetState(304)
		p.Parameters()
	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserARROW {
		{
			p.SetState(305)
			p.Match(Python3ParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(306)
			p.Test()
		}

	}
	{
		p.SetState(309)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Typedargslist() ITypedargslistContext

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ParametersContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ParametersContext) Typedargslist() ITypedargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (p *Python3Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python3ParserRULE_parameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.Match(Python3ParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4683779897422774272) != 0 {
		{
			p.SetState(313)
			p.Typedargslist()
		}

	}
	{
		p.SetState(316)
		p.Match(Python3ParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTfpdef() []ITfpdefContext
	Tfpdef(i int) ITfpdefContext
	STAR() antlr.TerminalNode
	POWER() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
	return p
}

func InitEmptyTypedargslistContext(p *TypedargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) AllTfpdef() []ITfpdefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITfpdefContext); ok {
			len++
		}
	}

	tst := make([]ITfpdefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITfpdefContext); ok {
			tst[i] = t.(ITfpdefContext)
			i++
		}
	}

	return tst
}

func (s *TypedargslistContext) Tfpdef(i int) ITfpdefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITfpdefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITfpdefContext)
}

func (s *TypedargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *TypedargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *TypedargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *TypedargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *TypedargslistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *TypedargslistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TypedargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TypedargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (p *Python3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python3ParserRULE_typedargslist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserMATCH, Python3ParserUNDERSCORE, Python3ParserNAME:
		{
			p.SetState(318)
			p.Tfpdef()
		}
		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(319)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(320)
				p.Test()
			}

		}
		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(323)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(324)
					p.Tfpdef()
				}
				p.SetState(327)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(325)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(326)
						p.Test()
					}

				}

			}
			p.SetState(333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(334)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(365)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(335)
					p.Match(Python3ParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(337)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36284957458432) != 0 {
					{
						p.SetState(336)
						p.Tfpdef()
					}

				}
				p.SetState(347)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(339)
							p.Match(Python3ParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(340)
							p.Tfpdef()
						}
						p.SetState(343)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(341)
								p.Match(Python3ParserASSIGN)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}
							{
								p.SetState(342)
								p.Test()
							}

						}

					}
					p.SetState(349)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(358)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(350)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(356)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == Python3ParserPOWER {
						{
							p.SetState(351)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(352)
							p.Tfpdef()
						}
						p.SetState(354)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserCOMMA {
							{
								p.SetState(353)
								p.Match(Python3ParserCOMMA)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}

						}

					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(360)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(361)
					p.Tfpdef()
				}
				p.SetState(363)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(362)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case Python3ParserCLOSE_PAREN:

			default:
			}

		}

	case Python3ParserSTAR:
		{
			p.SetState(369)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36284957458432) != 0 {
			{
				p.SetState(370)
				p.Tfpdef()
			}

		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(373)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(374)
					p.Tfpdef()
				}
				p.SetState(377)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(375)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(376)
						p.Test()
					}

				}

			}
			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(384)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(390)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserPOWER {
				{
					p.SetState(385)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(386)
					p.Tfpdef()
				}
				p.SetState(388)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(387)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		}

	case Python3ParserPOWER:
		{
			p.SetState(394)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)
			p.Tfpdef()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(396)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITfpdefContext is an interface to support dynamic dispatch.
type ITfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsTfpdefContext differentiates from other interfaces.
	IsTfpdefContext()
}

type TfpdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfpdefContext() *TfpdefContext {
	var p = new(TfpdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
	return p
}

func InitEmptyTfpdefContext(p *TfpdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
}

func (*TfpdefContext) IsTfpdefContext() {}

func NewTfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TfpdefContext {
	var p = new(TfpdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_tfpdef

	return p
}

func (s *TfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *TfpdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TfpdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *TfpdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTfpdef(s)
	}
}

func (s *TfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTfpdef(s)
	}
}

func (p *Python3Parser) Tfpdef() (localctx ITfpdefContext) {
	localctx = NewTfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python3ParserRULE_tfpdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Name()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOLON {
		{
			p.SetState(402)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVfpdef() []IVfpdefContext
	Vfpdef(i int) IVfpdefContext
	STAR() antlr.TerminalNode
	POWER() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
	return p
}

func InitEmptyVarargslistContext(p *VarargslistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllVfpdef() []IVfpdefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVfpdefContext); ok {
			len++
		}
	}

	tst := make([]IVfpdefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVfpdefContext); ok {
			tst[i] = t.(IVfpdefContext)
			i++
		}
	}

	return tst
}

func (s *VarargslistContext) Vfpdef(i int) IVfpdefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVfpdefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVfpdefContext)
}

func (s *VarargslistContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *VarargslistContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *VarargslistContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *VarargslistContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *VarargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (p *Python3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python3ParserRULE_varargslist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserMATCH, Python3ParserUNDERSCORE, Python3ParserNAME:
		{
			p.SetState(406)
			p.Vfpdef()
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(407)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(408)
				p.Test()
			}

		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(411)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(412)
					p.Vfpdef()
				}
				p.SetState(415)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(413)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(414)
						p.Test()
					}

				}

			}
			p.SetState(421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(422)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(453)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(423)
					p.Match(Python3ParserSTAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(425)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36284957458432) != 0 {
					{
						p.SetState(424)
						p.Vfpdef()
					}

				}
				p.SetState(435)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(427)
							p.Match(Python3ParserCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(428)
							p.Vfpdef()
						}
						p.SetState(431)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(429)
								p.Match(Python3ParserASSIGN)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}
							{
								p.SetState(430)
								p.Test()
							}

						}

					}
					p.SetState(437)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				p.SetState(446)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(438)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(444)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == Python3ParserPOWER {
						{
							p.SetState(439)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(440)
							p.Vfpdef()
						}
						p.SetState(442)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserCOMMA {
							{
								p.SetState(441)
								p.Match(Python3ParserCOMMA)
								if p.HasError() {
									// Recognition error - abort rule
									goto errorExit
								}
							}

						}

					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(448)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(449)
					p.Vfpdef()
				}
				p.SetState(451)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(450)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			case Python3ParserCOLON:

			default:
			}

		}

	case Python3ParserSTAR:
		{
			p.SetState(457)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36284957458432) != 0 {
			{
				p.SetState(458)
				p.Vfpdef()
			}

		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(461)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(462)
					p.Vfpdef()
				}
				p.SetState(465)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(463)
						p.Match(Python3ParserASSIGN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(464)
						p.Test()
					}

				}

			}
			p.SetState(471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(472)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(478)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserPOWER {
				{
					p.SetState(473)
					p.Match(Python3ParserPOWER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(474)
					p.Vfpdef()
				}
				p.SetState(476)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(475)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		}

	case Python3ParserPOWER:
		{
			p.SetState(482)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			p.Vfpdef()
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(484)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVfpdefContext is an interface to support dynamic dispatch.
type IVfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsVfpdefContext differentiates from other interfaces.
	IsVfpdefContext()
}

type VfpdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVfpdefContext() *VfpdefContext {
	var p = new(VfpdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
	return p
}

func InitEmptyVfpdefContext(p *VfpdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
}

func (*VfpdefContext) IsVfpdefContext() {}

func NewVfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VfpdefContext {
	var p = new(VfpdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vfpdef

	return p
}

func (s *VfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *VfpdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterVfpdef(s)
	}
}

func (s *VfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitVfpdef(s)
	}
}

func (p *Python3Parser) Vfpdef() (localctx IVfpdefContext) {
	localctx = NewVfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python3ParserRULE_vfpdef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmts() ISimple_stmtsContext
	Compound_stmt() ICompound_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmts() ISimple_stmtsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtsContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompound_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *Python3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python3ParserRULE_stmt)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.Simple_stmts()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(492)
			p.Compound_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_stmtsContext is an interface to support dynamic dispatch.
type ISimple_stmtsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimple_stmt() []ISimple_stmtContext
	Simple_stmt(i int) ISimple_stmtContext
	NEWLINE() antlr.TerminalNode
	AllSEMI_COLON() []antlr.TerminalNode
	SEMI_COLON(i int) antlr.TerminalNode

	// IsSimple_stmtsContext differentiates from other interfaces.
	IsSimple_stmtsContext()
}

type Simple_stmtsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtsContext() *Simple_stmtsContext {
	var p = new(Simple_stmtsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmts
	return p
}

func InitEmptySimple_stmtsContext(p *Simple_stmtsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmts
}

func (*Simple_stmtsContext) IsSimple_stmtsContext() {}

func NewSimple_stmtsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtsContext {
	var p = new(Simple_stmtsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmts

	return p
}

func (s *Simple_stmtsContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtsContext) AllSimple_stmt() []ISimple_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISimple_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimple_stmtContext); ok {
			tst[i] = t.(ISimple_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Simple_stmtsContext) Simple_stmt(i int) ISimple_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Simple_stmtsContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Simple_stmtsContext) AllSEMI_COLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSEMI_COLON)
}

func (s *Simple_stmtsContext) SEMI_COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSEMI_COLON, i)
}

func (s *Simple_stmtsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSimple_stmts(s)
	}
}

func (s *Simple_stmtsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSimple_stmts(s)
	}
}

func (p *Python3Parser) Simple_stmts() (localctx ISimple_stmtsContext) {
	localctx = NewSimple_stmtsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python3ParserRULE_simple_stmts)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Simple_stmt()
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(496)
				p.Match(Python3ParserSEMI_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(497)
				p.Simple_stmt()
			}

		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserSEMI_COLON {
		{
			p.SetState(503)
			p.Match(Python3ParserSEMI_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(506)
		p.Match(Python3ParserNEWLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_stmt() IExpr_stmtContext
	Del_stmt() IDel_stmtContext
	Pass_stmt() IPass_stmtContext
	Flow_stmt() IFlow_stmtContext
	Import_stmt() IImport_stmtContext
	Global_stmt() IGlobal_stmtContext
	Nonlocal_stmt() INonlocal_stmtContext
	Assert_stmt() IAssert_stmtContext

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
	return p
}

func InitEmptySimple_stmtContext(p *Simple_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Simple_stmtContext) Del_stmt() IDel_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDel_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Simple_stmtContext) Pass_stmt() IPass_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPass_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Simple_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlow_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Simple_stmtContext) Import_stmt() IImport_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Simple_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Simple_stmtContext) Nonlocal_stmt() INonlocal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonlocal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonlocal_stmtContext)
}

func (s *Simple_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (p *Python3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python3ParserRULE_simple_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(508)
			p.Expr_stmt()
		}

	case Python3ParserDEL:
		{
			p.SetState(509)
			p.Del_stmt()
		}

	case Python3ParserPASS:
		{
			p.SetState(510)
			p.Pass_stmt()
		}

	case Python3ParserBREAK, Python3ParserCONTINUE, Python3ParserRAISE, Python3ParserRETURN, Python3ParserYIELD:
		{
			p.SetState(511)
			p.Flow_stmt()
		}

	case Python3ParserFROM, Python3ParserIMPORT:
		{
			p.SetState(512)
			p.Import_stmt()
		}

	case Python3ParserGLOBAL:
		{
			p.SetState(513)
			p.Global_stmt()
		}

	case Python3ParserNONLOCAL:
		{
			p.SetState(514)
			p.Nonlocal_stmt()
		}

	case Python3ParserASSERT:
		{
			p.SetState(515)
			p.Assert_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTestlist_star_expr() []ITestlist_star_exprContext
	Testlist_star_expr(i int) ITestlist_star_exprContext
	Annassign() IAnnassignContext
	Augassign() IAugassignContext
	AllYield_expr() []IYield_exprContext
	Yield_expr(i int) IYield_exprContext
	Testlist() ITestlistContext
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
	return p
}

func InitEmptyExpr_stmtContext(p *Expr_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			len++
		}
	}

	tst := make([]ITestlist_star_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestlist_star_exprContext); ok {
			tst[i] = t.(ITestlist_star_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_star_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Annassign() IAnnassignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnassignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnassignContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAugassignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYield_exprContext); ok {
			len++
		}
	}

	tst := make([]IYield_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYield_exprContext); ok {
			tst[i] = t.(IYield_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserASSIGN)
}

func (s *Expr_stmtContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, i)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *Python3Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python3ParserRULE_expr_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.Testlist_star_expr()
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCOLON:
		{
			p.SetState(519)
			p.Annassign()
		}

	case Python3ParserADD_ASSIGN, Python3ParserSUB_ASSIGN, Python3ParserMULT_ASSIGN, Python3ParserAT_ASSIGN, Python3ParserDIV_ASSIGN, Python3ParserMOD_ASSIGN, Python3ParserAND_ASSIGN, Python3ParserOR_ASSIGN, Python3ParserXOR_ASSIGN, Python3ParserLEFT_SHIFT_ASSIGN, Python3ParserRIGHT_SHIFT_ASSIGN, Python3ParserPOWER_ASSIGN, Python3ParserIDIV_ASSIGN:
		{
			p.SetState(520)
			p.Augassign()
		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(521)
				p.Yield_expr()
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(522)
				p.Testlist()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case Python3ParserNEWLINE, Python3ParserSEMI_COLON, Python3ParserASSIGN:
		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserASSIGN {
			{
				p.SetState(525)
				p.Match(Python3ParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(528)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserYIELD:
				{
					p.SetState(526)
					p.Yield_expr()
				}

			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(527)
					p.Testlist_star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(534)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnassignContext is an interface to support dynamic dispatch.
type IAnnassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	ASSIGN() antlr.TerminalNode

	// IsAnnassignContext differentiates from other interfaces.
	IsAnnassignContext()
}

type AnnassignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnassignContext() *AnnassignContext {
	var p = new(AnnassignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_annassign
	return p
}

func InitEmptyAnnassignContext(p *AnnassignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_annassign
}

func (*AnnassignContext) IsAnnassignContext() {}

func NewAnnassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnassignContext {
	var p = new(AnnassignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_annassign

	return p
}

func (s *AnnassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnassignContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *AnnassignContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *AnnassignContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *AnnassignContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *AnnassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnnassign(s)
	}
}

func (s *AnnassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnnassign(s)
	}
}

func (p *Python3Parser) Annassign() (localctx IAnnassignContext) {
	localctx = NewAnnassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python3ParserRULE_annassign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(538)
		p.Test()
	}
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserASSIGN {
		{
			p.SetState(539)
			p.Match(Python3ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
	return p
}

func InitEmptyTestlist_star_exprContext(p *Testlist_star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_star_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (p *Python3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python3ParserRULE_testlist_star_expr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(543)
			p.Test()
		}

	case Python3ParserSTAR:
		{
			p.SetState(544)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(547)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(548)
					p.Test()
				}

			case Python3ParserSTAR:
				{
					p.SetState(549)
					p.Star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(557)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	MULT_ASSIGN() antlr.TerminalNode
	AT_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	LEFT_SHIFT_ASSIGN() antlr.TerminalNode
	RIGHT_SHIFT_ASSIGN() antlr.TerminalNode
	POWER_ASSIGN() antlr.TerminalNode
	IDIV_ASSIGN() antlr.TerminalNode

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
	return p
}

func InitEmptyAugassignContext(p *AugassignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }

func (s *AugassignContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD_ASSIGN, 0)
}

func (s *AugassignContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserSUB_ASSIGN, 0)
}

func (s *AugassignContext) MULT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMULT_ASSIGN, 0)
}

func (s *AugassignContext) AT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAT_ASSIGN, 0)
}

func (s *AugassignContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV_ASSIGN, 0)
}

func (s *AugassignContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD_ASSIGN, 0)
}

func (s *AugassignContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_ASSIGN, 0)
}

func (s *AugassignContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_ASSIGN, 0)
}

func (s *AugassignContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR_ASSIGN, 0)
}

func (s *AugassignContext) LEFT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) RIGHT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT_ASSIGN, 0)
}

func (s *AugassignContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER_ASSIGN, 0)
}

func (s *AugassignContext) IDIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV_ASSIGN, 0)
}

func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAugassign(s)
	}
}

func (p *Python3Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python3ParserRULE_augassign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&8191) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEL() antlr.TerminalNode
	Exprlist() IExprlistContext

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
	return p
}

func InitEmptyDel_stmtContext(p *Del_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (p *Python3Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python3ParserRULE_del_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.Match(Python3ParserDEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(563)
		p.Exprlist()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PASS() antlr.TerminalNode

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
	return p
}

func InitEmptyPass_stmtContext(p *Pass_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserPASS, 0)
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (p *Python3Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python3ParserRULE_pass_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Match(Python3ParserPASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break_stmt() IBreak_stmtContext
	Continue_stmt() IContinue_stmtContext
	Return_stmt() IReturn_stmtContext
	Raise_stmt() IRaise_stmtContext
	Yield_stmt() IYield_stmtContext

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
	return p
}

func InitEmptyFlow_stmtContext(p *Flow_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinue_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaise_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}

func (p *Python3Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python3ParserRULE_flow_stmt)
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(567)
			p.Break_stmt()
		}

	case Python3ParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(568)
			p.Continue_stmt()
		}

	case Python3ParserRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(569)
			p.Return_stmt()
		}

	case Python3ParserRAISE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(570)
			p.Raise_stmt()
		}

	case Python3ParserYIELD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(571)
			p.Yield_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
	return p
}

func InitEmptyBreak_stmtContext(p *Break_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserBREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (p *Python3Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python3ParserRULE_break_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(Python3ParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
	return p
}

func InitEmptyContinue_stmtContext(p *Continue_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (p *Python3Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python3ParserRULE_continue_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(Python3ParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Testlist() ITestlistContext

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
	return p
}

func InitEmptyReturn_stmtContext(p *Return_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (p *Python3Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python3ParserRULE_return_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)
		p.Match(Python3ParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(579)
			p.Testlist()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Yield_expr() IYield_exprContext

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
	return p
}

func InitEmptyYield_stmtContext(p *Yield_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (p *Python3Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python3ParserRULE_yield_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.Yield_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	FROM() antlr.TerminalNode

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
	return p
}

func InitEmptyRaise_stmtContext(p *Raise_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(Python3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (p *Python3Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python3ParserRULE_raise_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(Python3ParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(585)
			p.Test()
		}
		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFROM {
			{
				p.SetState(586)
				p.Match(Python3ParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(587)
				p.Test()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Import_name() IImport_nameContext
	Import_from() IImport_fromContext

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
	return p
}

func InitEmptyImport_stmtContext(p *Import_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_fromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (p *Python3Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python3ParserRULE_import_stmt)
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Import_name()
		}

	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Import_from()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Dotted_as_names() IDotted_as_namesContext

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
	return p
}

func InitEmptyImport_nameContext(p *Import_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_name(s)
	}
}

func (p *Python3Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python3ParserRULE_import_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(Python3ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(597)
		p.Dotted_as_names()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	Dotted_name() IDotted_nameContext
	STAR() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Import_as_names() IImport_as_namesContext
	CLOSE_PAREN() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllELLIPSIS() []antlr.TerminalNode
	ELLIPSIS(i int) antlr.TerminalNode

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
	return p
}

func InitEmptyImport_fromContext(p *Import_fromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Import_fromContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Import_fromContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_namesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Import_fromContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Import_fromContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Import_fromContext) AllELLIPSIS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELLIPSIS)
}

func (s *Import_fromContext) ELLIPSIS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, i)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_from(s)
	}
}

func (p *Python3Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python3ParserRULE_import_from)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(Python3ParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(600)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(606)
			p.Dotted_name()
		}

	case 2:
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			{
				p.SetState(607)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(610)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(614)
		p.Match(Python3ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		{
			p.SetState(615)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_PAREN:
		{
			p.SetState(616)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)
			p.Import_as_names()
		}
		{
			p.SetState(618)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserMATCH, Python3ParserUNDERSCORE, Python3ParserNAME:
		{
			p.SetState(620)
			p.Import_as_names()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllName() []INameContext
	Name(i int) INameContext
	AS() antlr.TerminalNode

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
	return p
}

func InitEmptyImport_as_nameContext(p *Import_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Import_as_nameContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (p *Python3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python3ParserRULE_import_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Name()
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(624)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(625)
			p.Name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dotted_name() IDotted_nameContext
	AS() antlr.TerminalNode
	Name() INameContext

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
	return p
}

func InitEmptyDotted_as_nameContext(p *Dotted_as_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Dotted_as_nameContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (p *Python3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python3ParserRULE_dotted_as_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Dotted_name()
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(629)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.Name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImport_as_name() []IImport_as_nameContext
	Import_as_name(i int) IImport_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
	return p
}

func InitEmptyImport_as_namesContext(p *Import_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IImport_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImport_as_nameContext); ok {
			tst[i] = t.(IImport_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Import_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (p *Python3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python3ParserRULE_import_as_names)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Import_as_name()
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(634)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(635)
				p.Import_as_name()
			}

		}
		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(641)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDotted_as_name() []IDotted_as_nameContext
	Dotted_as_name(i int) IDotted_as_nameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
	return p
}

func InitEmptyDotted_as_namesContext(p *Dotted_as_namesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			len++
		}
	}

	tst := make([]IDotted_as_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDotted_as_nameContext); ok {
			tst[i] = t.(IDotted_as_nameContext)
			i++
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotted_as_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Dotted_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (p *Python3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python3ParserRULE_dotted_as_names)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Dotted_as_name()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(645)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.Dotted_as_name()
		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllName() []INameContext
	Name(i int) INameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
	return p
}

func InitEmptyDotted_nameContext(p *Dotted_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Dotted_nameContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *Dotted_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (p *Python3Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python3ParserRULE_dotted_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Name()
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserDOT {
		{
			p.SetState(653)
			p.Match(Python3ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(654)
			p.Name()
		}

		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
	return p
}

func InitEmptyGlobal_stmtContext(p *Global_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Global_stmtContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Global_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Global_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (p *Python3Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python3ParserRULE_global_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(Python3ParserGLOBAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Name()
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(662)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(663)
			p.Name()
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonlocal_stmtContext is an interface to support dynamic dispatch.
type INonlocal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONLOCAL() antlr.TerminalNode
	AllName() []INameContext
	Name(i int) INameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNonlocal_stmtContext differentiates from other interfaces.
	IsNonlocal_stmtContext()
}

type Nonlocal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonlocal_stmtContext() *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
	return p
}

func InitEmptyNonlocal_stmtContext(p *Nonlocal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
}

func (*Nonlocal_stmtContext) IsNonlocal_stmtContext() {}

func NewNonlocal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt

	return p
}

func (s *Nonlocal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *Nonlocal_stmtContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Nonlocal_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Nonlocal_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

func (p *Python3Parser) Nonlocal_stmt() (localctx INonlocal_stmtContext) {
	localctx = NewNonlocal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Python3ParserRULE_nonlocal_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(Python3ParserNONLOCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(670)
		p.Name()
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(671)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(672)
			p.Name()
		}

		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSERT() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	COMMA() antlr.TerminalNode

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
	return p
}

func InitEmptyAssert_stmtContext(p *Assert_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (p *Python3Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Python3ParserRULE_assert_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(Python3ParserASSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(679)
		p.Test()
	}
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(680)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(681)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If_stmt() IIf_stmtContext
	While_stmt() IWhile_stmtContext
	For_stmt() IFor_stmtContext
	Try_stmt() ITry_stmtContext
	With_stmt() IWith_stmtContext
	Funcdef() IFuncdefContext
	Classdef() IClassdefContext
	Decorated() IDecoratedContext
	Async_stmt() IAsync_stmtContext
	Match_stmt() IMatch_stmtContext

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
	return p
}

func InitEmptyCompound_stmtContext(p *Compound_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITry_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecoratedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) Async_stmt() IAsync_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsync_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsync_stmtContext)
}

func (s *Compound_stmtContext) Match_stmt() IMatch_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_stmtContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}

func (p *Python3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Python3ParserRULE_compound_stmt)
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.If_stmt()
		}

	case Python3ParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(685)
			p.While_stmt()
		}

	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(686)
			p.For_stmt()
		}

	case Python3ParserTRY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(687)
			p.Try_stmt()
		}

	case Python3ParserWITH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(688)
			p.With_stmt()
		}

	case Python3ParserDEF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(689)
			p.Funcdef()
		}

	case Python3ParserCLASS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(690)
			p.Classdef()
		}

	case Python3ParserAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(691)
			p.Decorated()
		}

	case Python3ParserASYNC:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(692)
			p.Async_stmt()
		}

	case Python3ParserMATCH:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(693)
			p.Match_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsync_stmtContext is an interface to support dynamic dispatch.
type IAsync_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYNC() antlr.TerminalNode
	Funcdef() IFuncdefContext
	With_stmt() IWith_stmtContext
	For_stmt() IFor_stmtContext

	// IsAsync_stmtContext differentiates from other interfaces.
	IsAsync_stmtContext()
}

type Async_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsync_stmtContext() *Async_stmtContext {
	var p = new(Async_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_stmt
	return p
}

func InitEmptyAsync_stmtContext(p *Async_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_async_stmt
}

func (*Async_stmtContext) IsAsync_stmtContext() {}

func NewAsync_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Async_stmtContext {
	var p = new(Async_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_async_stmt

	return p
}

func (s *Async_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Async_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Async_stmtContext) Funcdef() IFuncdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Async_stmtContext) With_stmt() IWith_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Async_stmtContext) For_stmt() IFor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Async_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Async_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Async_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAsync_stmt(s)
	}
}

func (s *Async_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAsync_stmt(s)
	}
}

func (p *Python3Parser) Async_stmt() (localctx IAsync_stmtContext) {
	localctx = NewAsync_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python3ParserRULE_async_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(Python3ParserASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDEF:
		{
			p.SetState(697)
			p.Funcdef()
		}

	case Python3ParserWITH:
		{
			p.SetState(698)
			p.With_stmt()
		}

	case Python3ParserFOR:
		{
			p.SetState(699)
			p.For_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	AllELIF() []antlr.TerminalNode
	ELIF(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *If_stmtContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *If_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *If_stmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *If_stmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *If_stmtContext) AllELIF() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELIF)
}

func (s *If_stmtContext) ELIF(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELIF, i)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *Python3Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python3ParserRULE_if_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(Python3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.Test()
	}
	{
		p.SetState(704)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Block()
	}
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserELIF {
		{
			p.SetState(706)
			p.Match(Python3ParserELIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)
			p.Test()
		}
		{
			p.SetState(708)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.Block()
		}

		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(716)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(718)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Test() ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	ELSE() antlr.TerminalNode

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
	return p
}

func InitEmptyWhile_stmtContext(p *While_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Python3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *While_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *While_stmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *While_stmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *While_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (p *Python3Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python3ParserRULE_while_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(Python3ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(722)
		p.Test()
	}
	{
		p.SetState(723)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(724)
		p.Block()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(725)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Exprlist() IExprlistContext
	IN() antlr.TerminalNode
	Testlist() ITestlistContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	ELSE() antlr.TerminalNode

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
	return p
}

func InitEmptyFor_stmtContext(p *For_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *For_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *For_stmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *For_stmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *Python3Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python3ParserRULE_for_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(Python3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Exprlist()
	}
	{
		p.SetState(732)
		p.Match(Python3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(733)
		p.Testlist()
	}
	{
		p.SetState(734)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(735)
		p.Block()
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(736)
			p.Match(Python3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	FINALLY() antlr.TerminalNode
	AllExcept_clause() []IExcept_clauseContext
	Except_clause(i int) IExcept_clauseContext
	ELSE() antlr.TerminalNode

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
	return p
}

func InitEmptyTry_stmtContext(p *Try_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRY, 0)
}

func (s *Try_stmtContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *Try_stmtContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *Try_stmtContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *Try_stmtContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Try_stmtContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Python3ParserFINALLY, 0)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			len++
		}
	}

	tst := make([]IExcept_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExcept_clauseContext); ok {
			tst[i] = t.(IExcept_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcept_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (p *Python3Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Python3ParserRULE_try_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Match(Python3ParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(742)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(743)
		p.Block()
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserEXCEPT:
		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserEXCEPT {
			{
				p.SetState(744)
				p.Except_clause()
			}
			{
				p.SetState(745)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(746)
				p.Block()
			}

			p.SetState(750)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserELSE {
			{
				p.SetState(752)
				p.Match(Python3ParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(753)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(754)
				p.Block()
			}

		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFINALLY {
			{
				p.SetState(757)
				p.Match(Python3ParserFINALLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(759)
				p.Block()
			}

		}

	case Python3ParserFINALLY:
		{
			p.SetState(762)
			p.Match(Python3ParserFINALLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllWith_item() []IWith_itemContext
	With_item(i int) IWith_itemContext
	COLON() antlr.TerminalNode
	Block() IBlockContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
	return p
}

func InitEmptyWith_stmtContext(p *With_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Python3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWith_itemContext); ok {
			len++
		}
	}

	tst := make([]IWith_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWith_itemContext); ok {
			tst[i] = t.(IWith_itemContext)
			i++
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWith_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *With_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *With_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *With_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (p *Python3Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python3ParserRULE_with_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(Python3ParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)
		p.With_item()
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(769)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(770)
			p.With_item()
		}

		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(776)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(777)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Test() ITestContext
	AS() antlr.TerminalNode
	Expr() IExprContext

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
	return p
}

func InitEmptyWith_itemContext(p *With_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (p *Python3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python3ParserRULE_with_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Test()
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(780)
			p.Match(Python3ParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT() antlr.TerminalNode
	Test() ITestContext
	AS() antlr.TerminalNode
	Name() INameContext

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
	return p
}

func InitEmptyExcept_clauseContext(p *Except_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Except_clauseContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (p *Python3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python3ParserRULE_except_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(Python3ParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(785)
			p.Test()
		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserAS {
			{
				p.SetState(786)
				p.Match(Python3ParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(787)
				p.Name()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_stmts() ISimple_stmtsContext
	NEWLINE() antlr.TerminalNode
	INDENT() antlr.TerminalNode
	DEDENT() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) Simple_stmts() ISimple_stmtsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_stmtsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtsContext)
}

func (s *BlockContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *BlockContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *BlockContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *BlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *Python3Parser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python3ParserRULE_block)
	var _la int

	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserASSERT, Python3ParserAWAIT, Python3ParserBREAK, Python3ParserCONTINUE, Python3ParserDEL, Python3ParserFALSE, Python3ParserFROM, Python3ParserGLOBAL, Python3ParserIMPORT, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNONLOCAL, Python3ParserNOT, Python3ParserPASS, Python3ParserRAISE, Python3ParserRETURN, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserYIELD, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.Simple_stmts()
		}

	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(793)
			p.Match(Python3ParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(794)
			p.Match(Python3ParserINDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&252254338105339672) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4206977) != 0) {
			{
				p.SetState(795)
				p.Stmt()
			}

			p.SetState(798)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(800)
			p.Match(Python3ParserDEDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_stmtContext is an interface to support dynamic dispatch.
type IMatch_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Subject_expr() ISubject_exprContext
	COLON() antlr.TerminalNode
	NEWLINE() antlr.TerminalNode
	INDENT() antlr.TerminalNode
	DEDENT() antlr.TerminalNode
	AllCase_block() []ICase_blockContext
	Case_block(i int) ICase_blockContext

	// IsMatch_stmtContext differentiates from other interfaces.
	IsMatch_stmtContext()
}

type Match_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_stmtContext() *Match_stmtContext {
	var p = new(Match_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_match_stmt
	return p
}

func InitEmptyMatch_stmtContext(p *Match_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_match_stmt
}

func (*Match_stmtContext) IsMatch_stmtContext() {}

func NewMatch_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_stmtContext {
	var p = new(Match_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_match_stmt

	return p
}

func (s *Match_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_stmtContext) MATCH() antlr.TerminalNode {
	return s.GetToken(Python3ParserMATCH, 0)
}

func (s *Match_stmtContext) Subject_expr() ISubject_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubject_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubject_exprContext)
}

func (s *Match_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Match_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Match_stmtContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *Match_stmtContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *Match_stmtContext) AllCase_block() []ICase_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICase_blockContext); ok {
			len++
		}
	}

	tst := make([]ICase_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICase_blockContext); ok {
			tst[i] = t.(ICase_blockContext)
			i++
		}
	}

	return tst
}

func (s *Match_stmtContext) Case_block(i int) ICase_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_blockContext)
}

func (s *Match_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterMatch_stmt(s)
	}
}

func (s *Match_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitMatch_stmt(s)
	}
}

func (p *Python3Parser) Match_stmt() (localctx IMatch_stmtContext) {
	localctx = NewMatch_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python3ParserRULE_match_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(Python3ParserMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(805)
		p.Subject_expr()
	}
	{
		p.SetState(806)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(807)
		p.Match(Python3ParserNEWLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(808)
		p.Match(Python3ParserINDENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Python3ParserCASE {
		{
			p.SetState(809)
			p.Case_block()
		}

		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(814)
		p.Match(Python3ParserDEDENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubject_exprContext is an interface to support dynamic dispatch.
type ISubject_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Star_named_expression() IStar_named_expressionContext
	COMMA() antlr.TerminalNode
	Star_named_expressions() IStar_named_expressionsContext
	Test() ITestContext

	// IsSubject_exprContext differentiates from other interfaces.
	IsSubject_exprContext()
}

type Subject_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubject_exprContext() *Subject_exprContext {
	var p = new(Subject_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subject_expr
	return p
}

func InitEmptySubject_exprContext(p *Subject_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subject_expr
}

func (*Subject_exprContext) IsSubject_exprContext() {}

func NewSubject_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subject_exprContext {
	var p = new(Subject_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subject_expr

	return p
}

func (s *Subject_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Subject_exprContext) Star_named_expression() IStar_named_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_named_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_named_expressionContext)
}

func (s *Subject_exprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Subject_exprContext) Star_named_expressions() IStar_named_expressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_named_expressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_named_expressionsContext)
}

func (s *Subject_exprContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Subject_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subject_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subject_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubject_expr(s)
	}
}

func (s *Subject_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubject_expr(s)
	}
}

func (p *Python3Parser) Subject_expr() (localctx ISubject_exprContext) {
	localctx = NewSubject_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python3ParserRULE_subject_expr)
	var _la int

	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(816)
			p.Star_named_expression()
		}
		{
			p.SetState(817)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(818)
				p.Star_named_expressions()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(821)
			p.Test()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_named_expressionsContext is an interface to support dynamic dispatch.
type IStar_named_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllStar_named_expression() []IStar_named_expressionContext
	Star_named_expression(i int) IStar_named_expressionContext

	// IsStar_named_expressionsContext differentiates from other interfaces.
	IsStar_named_expressionsContext()
}

type Star_named_expressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_named_expressionsContext() *Star_named_expressionsContext {
	var p = new(Star_named_expressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_named_expressions
	return p
}

func InitEmptyStar_named_expressionsContext(p *Star_named_expressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_named_expressions
}

func (*Star_named_expressionsContext) IsStar_named_expressionsContext() {}

func NewStar_named_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_named_expressionsContext {
	var p = new(Star_named_expressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_named_expressions

	return p
}

func (s *Star_named_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_named_expressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Star_named_expressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Star_named_expressionsContext) AllStar_named_expression() []IStar_named_expressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_named_expressionContext); ok {
			len++
		}
	}

	tst := make([]IStar_named_expressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_named_expressionContext); ok {
			tst[i] = t.(IStar_named_expressionContext)
			i++
		}
	}

	return tst
}

func (s *Star_named_expressionsContext) Star_named_expression(i int) IStar_named_expressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_named_expressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_named_expressionContext)
}

func (s *Star_named_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_named_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_named_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_named_expressions(s)
	}
}

func (s *Star_named_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_named_expressions(s)
	}
}

func (p *Python3Parser) Star_named_expressions() (localctx IStar_named_expressionsContext) {
	localctx = NewStar_named_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python3ParserRULE_star_named_expressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Match(Python3ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&252238150243451928) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(825)
			p.Star_named_expression()
		}

		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(830)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_named_expressionContext is an interface to support dynamic dispatch.
type IStar_named_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Expr() IExprContext
	Test() ITestContext

	// IsStar_named_expressionContext differentiates from other interfaces.
	IsStar_named_expressionContext()
}

type Star_named_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_named_expressionContext() *Star_named_expressionContext {
	var p = new(Star_named_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_named_expression
	return p
}

func InitEmptyStar_named_expressionContext(p *Star_named_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_named_expression
}

func (*Star_named_expressionContext) IsStar_named_expressionContext() {}

func NewStar_named_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_named_expressionContext {
	var p = new(Star_named_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_named_expression

	return p
}

func (s *Star_named_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_named_expressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_named_expressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_named_expressionContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Star_named_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_named_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_named_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_named_expression(s)
	}
}

func (s *Star_named_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_named_expression(s)
	}
}

func (p *Python3Parser) Star_named_expression() (localctx IStar_named_expressionContext) {
	localctx = NewStar_named_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python3ParserRULE_star_named_expression)
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(833)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(834)
			p.Expr()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			p.Test()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICase_blockContext is an interface to support dynamic dispatch.
type ICase_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Patterns() IPatternsContext
	COLON() antlr.TerminalNode
	Block() IBlockContext
	Guard() IGuardContext

	// IsCase_blockContext differentiates from other interfaces.
	IsCase_blockContext()
}

type Case_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_blockContext() *Case_blockContext {
	var p = new(Case_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_case_block
	return p
}

func InitEmptyCase_blockContext(p *Case_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_case_block
}

func (*Case_blockContext) IsCase_blockContext() {}

func NewCase_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_blockContext {
	var p = new(Case_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_case_block

	return p
}

func (s *Case_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_blockContext) CASE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCASE, 0)
}

func (s *Case_blockContext) Patterns() IPatternsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternsContext)
}

func (s *Case_blockContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Case_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Case_blockContext) Guard() IGuardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardContext)
}

func (s *Case_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterCase_block(s)
	}
}

func (s *Case_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitCase_block(s)
	}
}

func (p *Python3Parser) Case_block() (localctx ICase_blockContext) {
	localctx = NewCase_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python3ParserRULE_case_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.Match(Python3ParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(839)
		p.Patterns()
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserIF {
		{
			p.SetState(840)
			p.Guard()
		}

	}
	{
		p.SetState(843)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(844)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGuardContext is an interface to support dynamic dispatch.
type IGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Test() ITestContext

	// IsGuardContext differentiates from other interfaces.
	IsGuardContext()
}

type GuardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuardContext() *GuardContext {
	var p = new(GuardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_guard
	return p
}

func InitEmptyGuardContext(p *GuardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_guard
}

func (*GuardContext) IsGuardContext() {}

func NewGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GuardContext {
	var p = new(GuardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_guard

	return p
}

func (s *GuardContext) GetParser() antlr.Parser { return s.parser }

func (s *GuardContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *GuardContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *GuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterGuard(s)
	}
}

func (s *GuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitGuard(s)
	}
}

func (p *Python3Parser) Guard() (localctx IGuardContext) {
	localctx = NewGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python3ParserRULE_guard)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Match(Python3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(847)
		p.Test()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternsContext is an interface to support dynamic dispatch.
type IPatternsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Open_sequence_pattern() IOpen_sequence_patternContext
	Pattern() IPatternContext

	// IsPatternsContext differentiates from other interfaces.
	IsPatternsContext()
}

type PatternsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternsContext() *PatternsContext {
	var p = new(PatternsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_patterns
	return p
}

func InitEmptyPatternsContext(p *PatternsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_patterns
}

func (*PatternsContext) IsPatternsContext() {}

func NewPatternsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternsContext {
	var p = new(PatternsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_patterns

	return p
}

func (s *PatternsContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternsContext) Open_sequence_pattern() IOpen_sequence_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpen_sequence_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpen_sequence_patternContext)
}

func (s *PatternsContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPatterns(s)
	}
}

func (s *PatternsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPatterns(s)
	}
}

func (p *Python3Parser) Patterns() (localctx IPatternsContext) {
	localctx = NewPatternsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python3ParserRULE_patterns)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(849)
			p.Open_sequence_pattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Pattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	As_pattern() IAs_patternContext
	Or_pattern() IOr_patternContext

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) As_pattern() IAs_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAs_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAs_patternContext)
}

func (s *PatternContext) Or_pattern() IOr_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_patternContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *Python3Parser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python3ParserRULE_pattern)
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(853)
			p.As_pattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(854)
			p.Or_pattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAs_patternContext is an interface to support dynamic dispatch.
type IAs_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Or_pattern() IOr_patternContext
	AS() antlr.TerminalNode
	Pattern_capture_target() IPattern_capture_targetContext

	// IsAs_patternContext differentiates from other interfaces.
	IsAs_patternContext()
}

type As_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAs_patternContext() *As_patternContext {
	var p = new(As_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_as_pattern
	return p
}

func InitEmptyAs_patternContext(p *As_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_as_pattern
}

func (*As_patternContext) IsAs_patternContext() {}

func NewAs_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *As_patternContext {
	var p = new(As_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_as_pattern

	return p
}

func (s *As_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *As_patternContext) Or_pattern() IOr_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_patternContext)
}

func (s *As_patternContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *As_patternContext) Pattern_capture_target() IPattern_capture_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPattern_capture_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPattern_capture_targetContext)
}

func (s *As_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *As_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *As_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAs_pattern(s)
	}
}

func (s *As_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAs_pattern(s)
	}
}

func (p *Python3Parser) As_pattern() (localctx IAs_patternContext) {
	localctx = NewAs_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python3ParserRULE_as_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.Or_pattern()
	}
	{
		p.SetState(858)
		p.Match(Python3ParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(859)
		p.Pattern_capture_target()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOr_patternContext is an interface to support dynamic dispatch.
type IOr_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClosed_pattern() []IClosed_patternContext
	Closed_pattern(i int) IClosed_patternContext
	AllOR_OP() []antlr.TerminalNode
	OR_OP(i int) antlr.TerminalNode

	// IsOr_patternContext differentiates from other interfaces.
	IsOr_patternContext()
}

type Or_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_patternContext() *Or_patternContext {
	var p = new(Or_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_pattern
	return p
}

func InitEmptyOr_patternContext(p *Or_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_pattern
}

func (*Or_patternContext) IsOr_patternContext() {}

func NewOr_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_patternContext {
	var p = new(Or_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_or_pattern

	return p
}

func (s *Or_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_patternContext) AllClosed_pattern() []IClosed_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClosed_patternContext); ok {
			len++
		}
	}

	tst := make([]IClosed_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClosed_patternContext); ok {
			tst[i] = t.(IClosed_patternContext)
			i++
		}
	}

	return tst
}

func (s *Or_patternContext) Closed_pattern(i int) IClosed_patternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosed_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosed_patternContext)
}

func (s *Or_patternContext) AllOR_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR_OP)
}

func (s *Or_patternContext) OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_OP, i)
}

func (s *Or_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterOr_pattern(s)
	}
}

func (s *Or_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitOr_pattern(s)
	}
}

func (p *Python3Parser) Or_pattern() (localctx IOr_patternContext) {
	localctx = NewOr_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python3ParserRULE_or_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Closed_pattern()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR_OP {
		{
			p.SetState(862)
			p.Match(Python3ParserOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)
			p.Closed_pattern()
		}

		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosed_patternContext is an interface to support dynamic dispatch.
type IClosed_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal_pattern() ILiteral_patternContext
	Capture_pattern() ICapture_patternContext
	Wildcard_pattern() IWildcard_patternContext
	Value_pattern() IValue_patternContext
	Group_pattern() IGroup_patternContext
	Sequence_pattern() ISequence_patternContext
	Mapping_pattern() IMapping_patternContext
	Class_pattern() IClass_patternContext

	// IsClosed_patternContext differentiates from other interfaces.
	IsClosed_patternContext()
}

type Closed_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosed_patternContext() *Closed_patternContext {
	var p = new(Closed_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_closed_pattern
	return p
}

func InitEmptyClosed_patternContext(p *Closed_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_closed_pattern
}

func (*Closed_patternContext) IsClosed_patternContext() {}

func NewClosed_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Closed_patternContext {
	var p = new(Closed_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_closed_pattern

	return p
}

func (s *Closed_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Closed_patternContext) Literal_pattern() ILiteral_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_patternContext)
}

func (s *Closed_patternContext) Capture_pattern() ICapture_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICapture_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICapture_patternContext)
}

func (s *Closed_patternContext) Wildcard_pattern() IWildcard_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcard_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcard_patternContext)
}

func (s *Closed_patternContext) Value_pattern() IValue_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_patternContext)
}

func (s *Closed_patternContext) Group_pattern() IGroup_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_patternContext)
}

func (s *Closed_patternContext) Sequence_pattern() ISequence_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequence_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequence_patternContext)
}

func (s *Closed_patternContext) Mapping_pattern() IMapping_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapping_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapping_patternContext)
}

func (s *Closed_patternContext) Class_pattern() IClass_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_patternContext)
}

func (s *Closed_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Closed_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Closed_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClosed_pattern(s)
	}
}

func (s *Closed_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClosed_pattern(s)
	}
}

func (p *Python3Parser) Closed_pattern() (localctx IClosed_patternContext) {
	localctx = NewClosed_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Python3ParserRULE_closed_pattern)
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(869)
			p.Literal_pattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(870)
			p.Capture_pattern()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(871)
			p.Wildcard_pattern()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(872)
			p.Value_pattern()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(873)
			p.Group_pattern()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(874)
			p.Sequence_pattern()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(875)
			p.Mapping_pattern()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(876)
			p.Class_pattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteral_patternContext is an interface to support dynamic dispatch.
type ILiteral_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Signed_number() ISigned_numberContext
	Complex_number() IComplex_numberContext
	Strings() IStringsContext
	NONE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsLiteral_patternContext differentiates from other interfaces.
	IsLiteral_patternContext()
}

type Literal_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_patternContext() *Literal_patternContext {
	var p = new(Literal_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_literal_pattern
	return p
}

func InitEmptyLiteral_patternContext(p *Literal_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_literal_pattern
}

func (*Literal_patternContext) IsLiteral_patternContext() {}

func NewLiteral_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_patternContext {
	var p = new(Literal_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_literal_pattern

	return p
}

func (s *Literal_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_patternContext) Signed_number() ISigned_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_numberContext)
}

func (s *Literal_patternContext) Complex_number() IComplex_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplex_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplex_numberContext)
}

func (s *Literal_patternContext) Strings() IStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringsContext)
}

func (s *Literal_patternContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *Literal_patternContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *Literal_patternContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *Literal_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLiteral_pattern(s)
	}
}

func (s *Literal_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLiteral_pattern(s)
	}
}

func (p *Python3Parser) Literal_pattern() (localctx ILiteral_patternContext) {
	localctx = NewLiteral_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Python3ParserRULE_literal_pattern)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(879)
			p.Signed_number()
		}
		p.SetState(880)

		if !(p.CannotBePlusMinus()) {
			p.SetError(antlr.NewFailedPredicateException(p, " p.CannotBePlusMinus() ", ""))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(882)
			p.Complex_number()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(883)
			p.Strings()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(884)
			p.Match(Python3ParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(885)
			p.Match(Python3ParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(886)
			p.Match(Python3ParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteral_exprContext is an interface to support dynamic dispatch.
type ILiteral_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Signed_number() ISigned_numberContext
	Complex_number() IComplex_numberContext
	Strings() IStringsContext
	NONE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsLiteral_exprContext differentiates from other interfaces.
	IsLiteral_exprContext()
}

type Literal_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteral_exprContext() *Literal_exprContext {
	var p = new(Literal_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_literal_expr
	return p
}

func InitEmptyLiteral_exprContext(p *Literal_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_literal_expr
}

func (*Literal_exprContext) IsLiteral_exprContext() {}

func NewLiteral_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Literal_exprContext {
	var p = new(Literal_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_literal_expr

	return p
}

func (s *Literal_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Literal_exprContext) Signed_number() ISigned_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_numberContext)
}

func (s *Literal_exprContext) Complex_number() IComplex_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplex_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplex_numberContext)
}

func (s *Literal_exprContext) Strings() IStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringsContext)
}

func (s *Literal_exprContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *Literal_exprContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *Literal_exprContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *Literal_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Literal_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Literal_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLiteral_expr(s)
	}
}

func (s *Literal_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLiteral_expr(s)
	}
}

func (p *Python3Parser) Literal_expr() (localctx ILiteral_exprContext) {
	localctx = NewLiteral_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Python3ParserRULE_literal_expr)
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(889)
			p.Signed_number()
		}
		p.SetState(890)

		if !(p.CannotBePlusMinus()) {
			p.SetError(antlr.NewFailedPredicateException(p, " p.CannotBePlusMinus() ", ""))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Complex_number()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(893)
			p.Strings()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(894)
			p.Match(Python3ParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(895)
			p.Match(Python3ParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(896)
			p.Match(Python3ParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplex_numberContext is an interface to support dynamic dispatch.
type IComplex_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Signed_real_number() ISigned_real_numberContext
	ADD() antlr.TerminalNode
	Imaginary_number() IImaginary_numberContext
	MINUS() antlr.TerminalNode

	// IsComplex_numberContext differentiates from other interfaces.
	IsComplex_numberContext()
}

type Complex_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplex_numberContext() *Complex_numberContext {
	var p = new(Complex_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_complex_number
	return p
}

func InitEmptyComplex_numberContext(p *Complex_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_complex_number
}

func (*Complex_numberContext) IsComplex_numberContext() {}

func NewComplex_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Complex_numberContext {
	var p = new(Complex_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_complex_number

	return p
}

func (s *Complex_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Complex_numberContext) Signed_real_number() ISigned_real_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_real_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_real_numberContext)
}

func (s *Complex_numberContext) ADD() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, 0)
}

func (s *Complex_numberContext) Imaginary_number() IImaginary_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImaginary_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImaginary_numberContext)
}

func (s *Complex_numberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *Complex_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Complex_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Complex_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComplex_number(s)
	}
}

func (s *Complex_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComplex_number(s)
	}
}

func (p *Python3Parser) Complex_number() (localctx IComplex_numberContext) {
	localctx = NewComplex_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Python3ParserRULE_complex_number)
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.Signed_real_number()
		}
		{
			p.SetState(900)
			p.Match(Python3ParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(901)
			p.Imaginary_number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(903)
			p.Signed_real_number()
		}
		{
			p.SetState(904)
			p.Match(Python3ParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.Imaginary_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISigned_numberContext is an interface to support dynamic dispatch.
type ISigned_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSigned_numberContext differentiates from other interfaces.
	IsSigned_numberContext()
}

type Signed_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_numberContext() *Signed_numberContext {
	var p = new(Signed_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_signed_number
	return p
}

func InitEmptySigned_numberContext(p *Signed_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_signed_number
}

func (*Signed_numberContext) IsSigned_numberContext() {}

func NewSigned_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_numberContext {
	var p = new(Signed_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_signed_number

	return p
}

func (s *Signed_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_numberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *Signed_numberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *Signed_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSigned_number(s)
	}
}

func (s *Signed_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSigned_number(s)
	}
}

func (p *Python3Parser) Signed_number() (localctx ISigned_numberContext) {
	localctx = NewSigned_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Python3ParserRULE_signed_number)
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Match(Python3ParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(910)
			p.Match(Python3ParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.Match(Python3ParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISigned_real_numberContext is an interface to support dynamic dispatch.
type ISigned_real_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Real_number() IReal_numberContext
	MINUS() antlr.TerminalNode

	// IsSigned_real_numberContext differentiates from other interfaces.
	IsSigned_real_numberContext()
}

type Signed_real_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_real_numberContext() *Signed_real_numberContext {
	var p = new(Signed_real_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_signed_real_number
	return p
}

func InitEmptySigned_real_numberContext(p *Signed_real_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_signed_real_number
}

func (*Signed_real_numberContext) IsSigned_real_numberContext() {}

func NewSigned_real_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_real_numberContext {
	var p = new(Signed_real_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_signed_real_number

	return p
}

func (s *Signed_real_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_real_numberContext) Real_number() IReal_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_numberContext)
}

func (s *Signed_real_numberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *Signed_real_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_real_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_real_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSigned_real_number(s)
	}
}

func (s *Signed_real_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSigned_real_number(s)
	}
}

func (p *Python3Parser) Signed_real_number() (localctx ISigned_real_numberContext) {
	localctx = NewSigned_real_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Python3ParserRULE_signed_real_number)
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(914)
			p.Real_number()
		}

	case Python3ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(915)
			p.Match(Python3ParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.Real_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReal_numberContext is an interface to support dynamic dispatch.
type IReal_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsReal_numberContext differentiates from other interfaces.
	IsReal_numberContext()
}

type Real_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_numberContext() *Real_numberContext {
	var p = new(Real_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_real_number
	return p
}

func InitEmptyReal_numberContext(p *Real_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_real_number
}

func (*Real_numberContext) IsReal_numberContext() {}

func NewReal_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_numberContext {
	var p = new(Real_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_real_number

	return p
}

func (s *Real_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_numberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *Real_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterReal_number(s)
	}
}

func (s *Real_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitReal_number(s)
	}
}

func (p *Python3Parser) Real_number() (localctx IReal_numberContext) {
	localctx = NewReal_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Python3ParserRULE_real_number)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(Python3ParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImaginary_numberContext is an interface to support dynamic dispatch.
type IImaginary_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsImaginary_numberContext differentiates from other interfaces.
	IsImaginary_numberContext()
}

type Imaginary_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImaginary_numberContext() *Imaginary_numberContext {
	var p = new(Imaginary_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_imaginary_number
	return p
}

func InitEmptyImaginary_numberContext(p *Imaginary_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_imaginary_number
}

func (*Imaginary_numberContext) IsImaginary_numberContext() {}

func NewImaginary_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imaginary_numberContext {
	var p = new(Imaginary_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_imaginary_number

	return p
}

func (s *Imaginary_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Imaginary_numberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *Imaginary_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imaginary_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imaginary_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterImaginary_number(s)
	}
}

func (s *Imaginary_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitImaginary_number(s)
	}
}

func (p *Python3Parser) Imaginary_number() (localctx IImaginary_numberContext) {
	localctx = NewImaginary_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Python3ParserRULE_imaginary_number)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Match(Python3ParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICapture_patternContext is an interface to support dynamic dispatch.
type ICapture_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern_capture_target() IPattern_capture_targetContext

	// IsCapture_patternContext differentiates from other interfaces.
	IsCapture_patternContext()
}

type Capture_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCapture_patternContext() *Capture_patternContext {
	var p = new(Capture_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_capture_pattern
	return p
}

func InitEmptyCapture_patternContext(p *Capture_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_capture_pattern
}

func (*Capture_patternContext) IsCapture_patternContext() {}

func NewCapture_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Capture_patternContext {
	var p = new(Capture_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_capture_pattern

	return p
}

func (s *Capture_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Capture_patternContext) Pattern_capture_target() IPattern_capture_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPattern_capture_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPattern_capture_targetContext)
}

func (s *Capture_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Capture_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Capture_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterCapture_pattern(s)
	}
}

func (s *Capture_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitCapture_pattern(s)
	}
}

func (p *Python3Parser) Capture_pattern() (localctx ICapture_patternContext) {
	localctx = NewCapture_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Python3ParserRULE_capture_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Pattern_capture_target()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPattern_capture_targetContext is an interface to support dynamic dispatch.
type IPattern_capture_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsPattern_capture_targetContext differentiates from other interfaces.
	IsPattern_capture_targetContext()
}

type Pattern_capture_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPattern_capture_targetContext() *Pattern_capture_targetContext {
	var p = new(Pattern_capture_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pattern_capture_target
	return p
}

func InitEmptyPattern_capture_targetContext(p *Pattern_capture_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_pattern_capture_target
}

func (*Pattern_capture_targetContext) IsPattern_capture_targetContext() {}

func NewPattern_capture_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pattern_capture_targetContext {
	var p = new(Pattern_capture_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pattern_capture_target

	return p
}

func (s *Pattern_capture_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Pattern_capture_targetContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Pattern_capture_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pattern_capture_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pattern_capture_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPattern_capture_target(s)
	}
}

func (s *Pattern_capture_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPattern_capture_target(s)
	}
}

func (p *Python3Parser) Pattern_capture_target() (localctx IPattern_capture_targetContext) {
	localctx = NewPattern_capture_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Python3ParserRULE_pattern_capture_target)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Name()
	}
	p.SetState(926)

	if !(p.CannotBeDotLpEq()) {
		p.SetError(antlr.NewFailedPredicateException(p, " p.CannotBeDotLpEq() ", ""))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcard_patternContext is an interface to support dynamic dispatch.
type IWildcard_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDERSCORE() antlr.TerminalNode

	// IsWildcard_patternContext differentiates from other interfaces.
	IsWildcard_patternContext()
}

type Wildcard_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcard_patternContext() *Wildcard_patternContext {
	var p = new(Wildcard_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_wildcard_pattern
	return p
}

func InitEmptyWildcard_patternContext(p *Wildcard_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_wildcard_pattern
}

func (*Wildcard_patternContext) IsWildcard_patternContext() {}

func NewWildcard_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wildcard_patternContext {
	var p = new(Wildcard_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_wildcard_pattern

	return p
}

func (s *Wildcard_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Wildcard_patternContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(Python3ParserUNDERSCORE, 0)
}

func (s *Wildcard_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wildcard_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wildcard_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterWildcard_pattern(s)
	}
}

func (s *Wildcard_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitWildcard_pattern(s)
	}
}

func (p *Python3Parser) Wildcard_pattern() (localctx IWildcard_patternContext) {
	localctx = NewWildcard_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Python3ParserRULE_wildcard_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(Python3ParserUNDERSCORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValue_patternContext is an interface to support dynamic dispatch.
type IValue_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attr() IAttrContext

	// IsValue_patternContext differentiates from other interfaces.
	IsValue_patternContext()
}

type Value_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_patternContext() *Value_patternContext {
	var p = new(Value_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_value_pattern
	return p
}

func InitEmptyValue_patternContext(p *Value_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_value_pattern
}

func (*Value_patternContext) IsValue_patternContext() {}

func NewValue_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_patternContext {
	var p = new(Value_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_value_pattern

	return p
}

func (s *Value_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_patternContext) Attr() IAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttrContext)
}

func (s *Value_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterValue_pattern(s)
	}
}

func (s *Value_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitValue_pattern(s)
	}
}

func (p *Python3Parser) Value_pattern() (localctx IValue_patternContext) {
	localctx = NewValue_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Python3ParserRULE_value_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Attr()
	}
	p.SetState(931)

	if !(p.CannotBeDotLpEq()) {
		p.SetError(antlr.NewFailedPredicateException(p, " p.CannotBeDotLpEq() ", ""))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttrContext is an interface to support dynamic dispatch.
type IAttrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllName() []INameContext
	Name(i int) INameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsAttrContext differentiates from other interfaces.
	IsAttrContext()
}

type AttrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttrContext() *AttrContext {
	var p = new(AttrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_attr
	return p
}

func InitEmptyAttrContext(p *AttrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_attr
}

func (*AttrContext) IsAttrContext() {}

func NewAttrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttrContext {
	var p = new(AttrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_attr

	return p
}

func (s *AttrContext) GetParser() antlr.Parser { return s.parser }

func (s *AttrContext) AllName() []INameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INameContext); ok {
			len++
		}
	}

	tst := make([]INameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INameContext); ok {
			tst[i] = t.(INameContext)
			i++
		}
	}

	return tst
}

func (s *AttrContext) Name(i int) INameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AttrContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDOT)
}

func (s *AttrContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, i)
}

func (s *AttrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAttr(s)
	}
}

func (s *AttrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAttr(s)
	}
}

func (p *Python3Parser) Attr() (localctx IAttrContext) {
	localctx = NewAttrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Python3ParserRULE_attr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Name()
	}
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(934)
				p.Match(Python3ParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(935)
				p.Name()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IName_or_attrContext is an interface to support dynamic dispatch.
type IName_or_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attr() IAttrContext
	Name() INameContext

	// IsName_or_attrContext differentiates from other interfaces.
	IsName_or_attrContext()
}

type Name_or_attrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_or_attrContext() *Name_or_attrContext {
	var p = new(Name_or_attrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name_or_attr
	return p
}

func InitEmptyName_or_attrContext(p *Name_or_attrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name_or_attr
}

func (*Name_or_attrContext) IsName_or_attrContext() {}

func NewName_or_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_or_attrContext {
	var p = new(Name_or_attrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_name_or_attr

	return p
}

func (s *Name_or_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_or_attrContext) Attr() IAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttrContext)
}

func (s *Name_or_attrContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Name_or_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_or_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_or_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterName_or_attr(s)
	}
}

func (s *Name_or_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitName_or_attr(s)
	}
}

func (p *Python3Parser) Name_or_attr() (localctx IName_or_attrContext) {
	localctx = NewName_or_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Python3ParserRULE_name_or_attr)
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(940)
			p.Attr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(941)
			p.Name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_patternContext is an interface to support dynamic dispatch.
type IGroup_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	Pattern() IPatternContext
	CLOSE_PAREN() antlr.TerminalNode

	// IsGroup_patternContext differentiates from other interfaces.
	IsGroup_patternContext()
}

type Group_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_patternContext() *Group_patternContext {
	var p = new(Group_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_group_pattern
	return p
}

func InitEmptyGroup_patternContext(p *Group_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_group_pattern
}

func (*Group_patternContext) IsGroup_patternContext() {}

func NewGroup_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_patternContext {
	var p = new(Group_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_group_pattern

	return p
}

func (s *Group_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_patternContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Group_patternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Group_patternContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Group_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterGroup_pattern(s)
	}
}

func (s *Group_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitGroup_pattern(s)
	}
}

func (p *Python3Parser) Group_pattern() (localctx IGroup_patternContext) {
	localctx = NewGroup_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Python3ParserRULE_group_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(Python3ParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(945)
		p.Pattern()
	}
	{
		p.SetState(946)
		p.Match(Python3ParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequence_patternContext is an interface to support dynamic dispatch.
type ISequence_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACK() antlr.TerminalNode
	CLOSE_BRACK() antlr.TerminalNode
	Maybe_sequence_pattern() IMaybe_sequence_patternContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Open_sequence_pattern() IOpen_sequence_patternContext

	// IsSequence_patternContext differentiates from other interfaces.
	IsSequence_patternContext()
}

type Sequence_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_patternContext() *Sequence_patternContext {
	var p = new(Sequence_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sequence_pattern
	return p
}

func InitEmptySequence_patternContext(p *Sequence_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sequence_pattern
}

func (*Sequence_patternContext) IsSequence_patternContext() {}

func NewSequence_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_patternContext {
	var p = new(Sequence_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sequence_pattern

	return p
}

func (s *Sequence_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_patternContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *Sequence_patternContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *Sequence_patternContext) Maybe_sequence_pattern() IMaybe_sequence_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_sequence_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_sequence_patternContext)
}

func (s *Sequence_patternContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Sequence_patternContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Sequence_patternContext) Open_sequence_pattern() IOpen_sequence_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpen_sequence_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpen_sequence_patternContext)
}

func (s *Sequence_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSequence_pattern(s)
	}
}

func (s *Sequence_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSequence_pattern(s)
	}
}

func (p *Python3Parser) Sequence_pattern() (localctx ISequence_patternContext) {
	localctx = NewSequence_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Python3ParserRULE_sequence_pattern)
	var _la int

	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(948)
			p.Match(Python3ParserOPEN_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216209344097681432) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8449) != 0) {
			{
				p.SetState(949)
				p.Maybe_sequence_pattern()
			}

		}
		{
			p.SetState(952)
			p.Match(Python3ParserCLOSE_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(953)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216209344097681432) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8449) != 0) {
			{
				p.SetState(954)
				p.Open_sequence_pattern()
			}

		}
		{
			p.SetState(957)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpen_sequence_patternContext is an interface to support dynamic dispatch.
type IOpen_sequence_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Maybe_star_pattern() IMaybe_star_patternContext
	COMMA() antlr.TerminalNode
	Maybe_sequence_pattern() IMaybe_sequence_patternContext

	// IsOpen_sequence_patternContext differentiates from other interfaces.
	IsOpen_sequence_patternContext()
}

type Open_sequence_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_sequence_patternContext() *Open_sequence_patternContext {
	var p = new(Open_sequence_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_open_sequence_pattern
	return p
}

func InitEmptyOpen_sequence_patternContext(p *Open_sequence_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_open_sequence_pattern
}

func (*Open_sequence_patternContext) IsOpen_sequence_patternContext() {}

func NewOpen_sequence_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_sequence_patternContext {
	var p = new(Open_sequence_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_open_sequence_pattern

	return p
}

func (s *Open_sequence_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_sequence_patternContext) Maybe_star_pattern() IMaybe_star_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_star_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_star_patternContext)
}

func (s *Open_sequence_patternContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, 0)
}

func (s *Open_sequence_patternContext) Maybe_sequence_pattern() IMaybe_sequence_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_sequence_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_sequence_patternContext)
}

func (s *Open_sequence_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_sequence_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_sequence_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterOpen_sequence_pattern(s)
	}
}

func (s *Open_sequence_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitOpen_sequence_pattern(s)
	}
}

func (p *Python3Parser) Open_sequence_pattern() (localctx IOpen_sequence_patternContext) {
	localctx = NewOpen_sequence_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Python3ParserRULE_open_sequence_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(960)
		p.Maybe_star_pattern()
	}
	{
		p.SetState(961)
		p.Match(Python3ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216209344097681432) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8449) != 0) {
		{
			p.SetState(962)
			p.Maybe_sequence_pattern()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaybe_sequence_patternContext is an interface to support dynamic dispatch.
type IMaybe_sequence_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMaybe_star_pattern() []IMaybe_star_patternContext
	Maybe_star_pattern(i int) IMaybe_star_patternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMaybe_sequence_patternContext differentiates from other interfaces.
	IsMaybe_sequence_patternContext()
}

type Maybe_sequence_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaybe_sequence_patternContext() *Maybe_sequence_patternContext {
	var p = new(Maybe_sequence_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_maybe_sequence_pattern
	return p
}

func InitEmptyMaybe_sequence_patternContext(p *Maybe_sequence_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_maybe_sequence_pattern
}

func (*Maybe_sequence_patternContext) IsMaybe_sequence_patternContext() {}

func NewMaybe_sequence_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Maybe_sequence_patternContext {
	var p = new(Maybe_sequence_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_maybe_sequence_pattern

	return p
}

func (s *Maybe_sequence_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Maybe_sequence_patternContext) AllMaybe_star_pattern() []IMaybe_star_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMaybe_star_patternContext); ok {
			len++
		}
	}

	tst := make([]IMaybe_star_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMaybe_star_patternContext); ok {
			tst[i] = t.(IMaybe_star_patternContext)
			i++
		}
	}

	return tst
}

func (s *Maybe_sequence_patternContext) Maybe_star_pattern(i int) IMaybe_star_patternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaybe_star_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaybe_star_patternContext)
}

func (s *Maybe_sequence_patternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Maybe_sequence_patternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Maybe_sequence_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Maybe_sequence_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Maybe_sequence_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterMaybe_sequence_pattern(s)
	}
}

func (s *Maybe_sequence_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitMaybe_sequence_pattern(s)
	}
}

func (p *Python3Parser) Maybe_sequence_pattern() (localctx IMaybe_sequence_patternContext) {
	localctx = NewMaybe_sequence_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Python3ParserRULE_maybe_sequence_pattern)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Maybe_star_pattern()
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(966)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(967)
				p.Maybe_star_pattern()
			}

		}
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(973)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaybe_star_patternContext is an interface to support dynamic dispatch.
type IMaybe_star_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Star_pattern() IStar_patternContext
	Pattern() IPatternContext

	// IsMaybe_star_patternContext differentiates from other interfaces.
	IsMaybe_star_patternContext()
}

type Maybe_star_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaybe_star_patternContext() *Maybe_star_patternContext {
	var p = new(Maybe_star_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_maybe_star_pattern
	return p
}

func InitEmptyMaybe_star_patternContext(p *Maybe_star_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_maybe_star_pattern
}

func (*Maybe_star_patternContext) IsMaybe_star_patternContext() {}

func NewMaybe_star_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Maybe_star_patternContext {
	var p = new(Maybe_star_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_maybe_star_pattern

	return p
}

func (s *Maybe_star_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Maybe_star_patternContext) Star_pattern() IStar_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_patternContext)
}

func (s *Maybe_star_patternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Maybe_star_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Maybe_star_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Maybe_star_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterMaybe_star_pattern(s)
	}
}

func (s *Maybe_star_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitMaybe_star_pattern(s)
	}
}

func (p *Python3Parser) Maybe_star_pattern() (localctx IMaybe_star_patternContext) {
	localctx = NewMaybe_star_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Python3ParserRULE_maybe_star_pattern)
	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(976)
			p.Star_pattern()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserMINUS, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(977)
			p.Pattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_patternContext is an interface to support dynamic dispatch.
type IStar_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Pattern_capture_target() IPattern_capture_targetContext
	Wildcard_pattern() IWildcard_patternContext

	// IsStar_patternContext differentiates from other interfaces.
	IsStar_patternContext()
}

type Star_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_patternContext() *Star_patternContext {
	var p = new(Star_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_pattern
	return p
}

func InitEmptyStar_patternContext(p *Star_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_pattern
}

func (*Star_patternContext) IsStar_patternContext() {}

func NewStar_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_patternContext {
	var p = new(Star_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_pattern

	return p
}

func (s *Star_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_patternContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_patternContext) Pattern_capture_target() IPattern_capture_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPattern_capture_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPattern_capture_targetContext)
}

func (s *Star_patternContext) Wildcard_pattern() IWildcard_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcard_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcard_patternContext)
}

func (s *Star_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_pattern(s)
	}
}

func (s *Star_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_pattern(s)
	}
}

func (p *Python3Parser) Star_pattern() (localctx IStar_patternContext) {
	localctx = NewStar_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Python3ParserRULE_star_pattern)
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(980)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(981)
			p.Pattern_capture_target()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(982)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.Wildcard_pattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapping_patternContext is an interface to support dynamic dispatch.
type IMapping_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	Double_star_pattern() IDouble_star_patternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Items_pattern() IItems_patternContext

	// IsMapping_patternContext differentiates from other interfaces.
	IsMapping_patternContext()
}

type Mapping_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapping_patternContext() *Mapping_patternContext {
	var p = new(Mapping_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_mapping_pattern
	return p
}

func InitEmptyMapping_patternContext(p *Mapping_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_mapping_pattern
}

func (*Mapping_patternContext) IsMapping_patternContext() {}

func NewMapping_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mapping_patternContext {
	var p = new(Mapping_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_mapping_pattern

	return p
}

func (s *Mapping_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Mapping_patternContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACE, 0)
}

func (s *Mapping_patternContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACE, 0)
}

func (s *Mapping_patternContext) Double_star_pattern() IDouble_star_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDouble_star_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDouble_star_patternContext)
}

func (s *Mapping_patternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Mapping_patternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Mapping_patternContext) Items_pattern() IItems_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IItems_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IItems_patternContext)
}

func (s *Mapping_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mapping_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mapping_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterMapping_pattern(s)
	}
}

func (s *Mapping_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitMapping_pattern(s)
	}
}

func (p *Python3Parser) Mapping_pattern() (localctx IMapping_patternContext) {
	localctx = NewMapping_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Python3ParserRULE_mapping_pattern)
	var _la int

	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(987)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(988)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(989)
			p.Double_star_pattern()
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(990)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(993)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(995)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(996)
			p.Items_pattern()
		}
		{
			p.SetState(997)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.Double_star_pattern()
		}
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(999)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1002)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1004)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1005)
			p.Items_pattern()
		}
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1006)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1009)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IItems_patternContext is an interface to support dynamic dispatch.
type IItems_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKey_value_pattern() []IKey_value_patternContext
	Key_value_pattern(i int) IKey_value_patternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsItems_patternContext differentiates from other interfaces.
	IsItems_patternContext()
}

type Items_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItems_patternContext() *Items_patternContext {
	var p = new(Items_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_items_pattern
	return p
}

func InitEmptyItems_patternContext(p *Items_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_items_pattern
}

func (*Items_patternContext) IsItems_patternContext() {}

func NewItems_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Items_patternContext {
	var p = new(Items_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_items_pattern

	return p
}

func (s *Items_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Items_patternContext) AllKey_value_pattern() []IKey_value_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKey_value_patternContext); ok {
			len++
		}
	}

	tst := make([]IKey_value_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKey_value_patternContext); ok {
			tst[i] = t.(IKey_value_patternContext)
			i++
		}
	}

	return tst
}

func (s *Items_patternContext) Key_value_pattern(i int) IKey_value_patternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_value_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_value_patternContext)
}

func (s *Items_patternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Items_patternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Items_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Items_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Items_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterItems_pattern(s)
	}
}

func (s *Items_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitItems_pattern(s)
	}
}

func (p *Python3Parser) Items_pattern() (localctx IItems_patternContext) {
	localctx = NewItems_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Python3ParserRULE_items_pattern)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Key_value_pattern()
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1014)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1015)
				p.Key_value_pattern()
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_value_patternContext is an interface to support dynamic dispatch.
type IKey_value_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Pattern() IPatternContext
	Literal_expr() ILiteral_exprContext
	Attr() IAttrContext

	// IsKey_value_patternContext differentiates from other interfaces.
	IsKey_value_patternContext()
}

type Key_value_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_value_patternContext() *Key_value_patternContext {
	var p = new(Key_value_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_key_value_pattern
	return p
}

func InitEmptyKey_value_patternContext(p *Key_value_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_key_value_pattern
}

func (*Key_value_patternContext) IsKey_value_patternContext() {}

func NewKey_value_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_value_patternContext {
	var p = new(Key_value_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_key_value_pattern

	return p
}

func (s *Key_value_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_value_patternContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Key_value_patternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Key_value_patternContext) Literal_expr() ILiteral_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteral_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteral_exprContext)
}

func (s *Key_value_patternContext) Attr() IAttrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttrContext)
}

func (s *Key_value_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_value_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_value_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterKey_value_pattern(s)
	}
}

func (s *Key_value_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitKey_value_pattern(s)
	}
}

func (p *Python3Parser) Key_value_pattern() (localctx IKey_value_patternContext) {
	localctx = NewKey_value_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Python3ParserRULE_key_value_pattern)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserFALSE, Python3ParserNONE, Python3ParserTRUE, Python3ParserMINUS:
		{
			p.SetState(1021)
			p.Literal_expr()
		}

	case Python3ParserMATCH, Python3ParserUNDERSCORE, Python3ParserNAME:
		{
			p.SetState(1022)
			p.Attr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1025)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1026)
		p.Pattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDouble_star_patternContext is an interface to support dynamic dispatch.
type IDouble_star_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POWER() antlr.TerminalNode
	Pattern_capture_target() IPattern_capture_targetContext

	// IsDouble_star_patternContext differentiates from other interfaces.
	IsDouble_star_patternContext()
}

type Double_star_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDouble_star_patternContext() *Double_star_patternContext {
	var p = new(Double_star_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_double_star_pattern
	return p
}

func InitEmptyDouble_star_patternContext(p *Double_star_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_double_star_pattern
}

func (*Double_star_patternContext) IsDouble_star_patternContext() {}

func NewDouble_star_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Double_star_patternContext {
	var p = new(Double_star_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_double_star_pattern

	return p
}

func (s *Double_star_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Double_star_patternContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *Double_star_patternContext) Pattern_capture_target() IPattern_capture_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPattern_capture_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPattern_capture_targetContext)
}

func (s *Double_star_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_star_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Double_star_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDouble_star_pattern(s)
	}
}

func (s *Double_star_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDouble_star_pattern(s)
	}
}

func (p *Python3Parser) Double_star_pattern() (localctx IDouble_star_patternContext) {
	localctx = NewDouble_star_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Python3ParserRULE_double_star_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1028)
		p.Match(Python3ParserPOWER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1029)
		p.Pattern_capture_target()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_patternContext is an interface to support dynamic dispatch.
type IClass_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name_or_attr() IName_or_attrContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Positional_patterns() IPositional_patternsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Keyword_patterns() IKeyword_patternsContext

	// IsClass_patternContext differentiates from other interfaces.
	IsClass_patternContext()
}

type Class_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_patternContext() *Class_patternContext {
	var p = new(Class_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_class_pattern
	return p
}

func InitEmptyClass_patternContext(p *Class_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_class_pattern
}

func (*Class_patternContext) IsClass_patternContext() {}

func NewClass_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_patternContext {
	var p = new(Class_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_class_pattern

	return p
}

func (s *Class_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_patternContext) Name_or_attr() IName_or_attrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_or_attrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_or_attrContext)
}

func (s *Class_patternContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *Class_patternContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *Class_patternContext) Positional_patterns() IPositional_patternsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPositional_patternsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPositional_patternsContext)
}

func (s *Class_patternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Class_patternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Class_patternContext) Keyword_patterns() IKeyword_patternsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_patternsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_patternsContext)
}

func (s *Class_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClass_pattern(s)
	}
}

func (s *Class_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClass_pattern(s)
	}
}

func (p *Python3Parser) Class_pattern() (localctx IClass_patternContext) {
	localctx = NewClass_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Python3ParserRULE_class_pattern)
	var _la int

	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1031)
			p.Name_or_attr()
		}
		{
			p.SetState(1032)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1033)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1035)
			p.Name_or_attr()
		}
		{
			p.SetState(1036)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1037)
			p.Positional_patterns()
		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1038)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1041)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1043)
			p.Name_or_attr()
		}
		{
			p.SetState(1044)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1045)
			p.Keyword_patterns()
		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1046)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1049)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1051)
			p.Name_or_attr()
		}
		{
			p.SetState(1052)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Positional_patterns()
		}
		{
			p.SetState(1054)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)
			p.Keyword_patterns()
		}
		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1056)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1059)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPositional_patternsContext is an interface to support dynamic dispatch.
type IPositional_patternsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPattern() []IPatternContext
	Pattern(i int) IPatternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPositional_patternsContext differentiates from other interfaces.
	IsPositional_patternsContext()
}

type Positional_patternsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPositional_patternsContext() *Positional_patternsContext {
	var p = new(Positional_patternsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_positional_patterns
	return p
}

func InitEmptyPositional_patternsContext(p *Positional_patternsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_positional_patterns
}

func (*Positional_patternsContext) IsPositional_patternsContext() {}

func NewPositional_patternsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Positional_patternsContext {
	var p = new(Positional_patternsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_positional_patterns

	return p
}

func (s *Positional_patternsContext) GetParser() antlr.Parser { return s.parser }

func (s *Positional_patternsContext) AllPattern() []IPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternContext); ok {
			len++
		}
	}

	tst := make([]IPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternContext); ok {
			tst[i] = t.(IPatternContext)
			i++
		}
	}

	return tst
}

func (s *Positional_patternsContext) Pattern(i int) IPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Positional_patternsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Positional_patternsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Positional_patternsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Positional_patternsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Positional_patternsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPositional_patterns(s)
	}
}

func (s *Positional_patternsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPositional_patterns(s)
	}
}

func (p *Python3Parser) Positional_patterns() (localctx IPositional_patternsContext) {
	localctx = NewPositional_patternsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Python3ParserRULE_positional_patterns)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Pattern()
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1064)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1065)
				p.Pattern()
			}

		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_patternsContext is an interface to support dynamic dispatch.
type IKeyword_patternsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyword_pattern() []IKeyword_patternContext
	Keyword_pattern(i int) IKeyword_patternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsKeyword_patternsContext differentiates from other interfaces.
	IsKeyword_patternsContext()
}

type Keyword_patternsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_patternsContext() *Keyword_patternsContext {
	var p = new(Keyword_patternsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_keyword_patterns
	return p
}

func InitEmptyKeyword_patternsContext(p *Keyword_patternsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_keyword_patterns
}

func (*Keyword_patternsContext) IsKeyword_patternsContext() {}

func NewKeyword_patternsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_patternsContext {
	var p = new(Keyword_patternsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_keyword_patterns

	return p
}

func (s *Keyword_patternsContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_patternsContext) AllKeyword_pattern() []IKeyword_patternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyword_patternContext); ok {
			len++
		}
	}

	tst := make([]IKeyword_patternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyword_patternContext); ok {
			tst[i] = t.(IKeyword_patternContext)
			i++
		}
	}

	return tst
}

func (s *Keyword_patternsContext) Keyword_pattern(i int) IKeyword_patternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyword_patternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyword_patternContext)
}

func (s *Keyword_patternsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Keyword_patternsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Keyword_patternsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_patternsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_patternsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterKeyword_patterns(s)
	}
}

func (s *Keyword_patternsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitKeyword_patterns(s)
	}
}

func (p *Python3Parser) Keyword_patterns() (localctx IKeyword_patternsContext) {
	localctx = NewKeyword_patternsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Python3ParserRULE_keyword_patterns)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1071)
		p.Keyword_pattern()
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1072)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1073)
				p.Keyword_pattern()
			}

		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyword_patternContext is an interface to support dynamic dispatch.
type IKeyword_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext
	ASSIGN() antlr.TerminalNode
	Pattern() IPatternContext

	// IsKeyword_patternContext differentiates from other interfaces.
	IsKeyword_patternContext()
}

type Keyword_patternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyword_patternContext() *Keyword_patternContext {
	var p = new(Keyword_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_keyword_pattern
	return p
}

func InitEmptyKeyword_patternContext(p *Keyword_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_keyword_pattern
}

func (*Keyword_patternContext) IsKeyword_patternContext() {}

func NewKeyword_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Keyword_patternContext {
	var p = new(Keyword_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_keyword_pattern

	return p
}

func (s *Keyword_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Keyword_patternContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Keyword_patternContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *Keyword_patternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Keyword_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Keyword_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Keyword_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterKeyword_pattern(s)
	}
}

func (s *Keyword_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitKeyword_pattern(s)
	}
}

func (p *Python3Parser) Keyword_pattern() (localctx IKeyword_patternContext) {
	localctx = NewKeyword_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Python3ParserRULE_keyword_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1079)
		p.Name()
	}
	{
		p.SetState(1080)
		p.Match(Python3ParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1081)
		p.Pattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOr_test() []IOr_testContext
	Or_test(i int) IOr_testContext
	IF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Test() ITestContext
	Lambdef() ILambdefContext

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
	return p
}

func InitEmptyTestContext(p *TestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOr_testContext); ok {
			len++
		}
	}

	tst := make([]IOr_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOr_testContext); ok {
			tst[i] = t.(IOr_testContext)
			i++
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTest(s)
	}
}

func (p *Python3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Python3ParserRULE_test)
	var _la int

	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1083)
			p.Or_test()
		}
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserIF {
			{
				p.SetState(1084)
				p.Match(Python3ParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1085)
				p.Or_test()
			}
			{
				p.SetState(1086)
				p.Match(Python3ParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1087)
				p.Test()
			}

		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.Lambdef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITest_nocondContext is an interface to support dynamic dispatch.
type ITest_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Or_test() IOr_testContext
	Lambdef_nocond() ILambdef_nocondContext

	// IsTest_nocondContext differentiates from other interfaces.
	IsTest_nocondContext()
}

type Test_nocondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_nocondContext() *Test_nocondContext {
	var p = new(Test_nocondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
	return p
}

func InitEmptyTest_nocondContext(p *Test_nocondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
}

func (*Test_nocondContext) IsTest_nocondContext() {}

func NewTest_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_nocondContext {
	var p = new(Test_nocondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test_nocond

	return p
}

func (s *Test_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_nocondContext) Or_test() IOr_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Test_nocondContext) Lambdef_nocond() ILambdef_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdef_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdef_nocondContext)
}

func (s *Test_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Test_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTest_nocond(s)
	}
}

func (s *Test_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTest_nocond(s)
	}
}

func (p *Python3Parser) Test_nocond() (localctx ITest_nocondContext) {
	localctx = NewTest_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Python3ParserRULE_test_nocond)
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Or_test()
		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1095)
			p.Lambdef_nocond()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAMBDA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Test() ITestContext
	Varargslist() IVarargslistContext

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
	return p
}

func InitEmptyLambdefContext(p *LambdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *LambdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *LambdefContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLambdef(s)
	}
}

func (p *Python3Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Python3ParserRULE_lambdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.Match(Python3ParserLAMBDA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4683779897422774272) != 0 {
		{
			p.SetState(1099)
			p.Varargslist()
		}

	}
	{
		p.SetState(1102)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1103)
		p.Test()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdef_nocondContext is an interface to support dynamic dispatch.
type ILambdef_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAMBDA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Test_nocond() ITest_nocondContext
	Varargslist() IVarargslistContext

	// IsLambdef_nocondContext differentiates from other interfaces.
	IsLambdef_nocondContext()
}

type Lambdef_nocondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdef_nocondContext() *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
	return p
}

func InitEmptyLambdef_nocondContext(p *Lambdef_nocondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
}

func (*Lambdef_nocondContext) IsLambdef_nocondContext() {}

func NewLambdef_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef_nocond

	return p
}

func (s *Lambdef_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambdef_nocondContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *Lambdef_nocondContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Lambdef_nocondContext) Test_nocond() ITest_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITest_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Lambdef_nocondContext) Varargslist() IVarargslistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarargslistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Lambdef_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambdef_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambdef_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitLambdef_nocond(s)
	}
}

func (p *Python3Parser) Lambdef_nocond() (localctx ILambdef_nocondContext) {
	localctx = NewLambdef_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Python3ParserRULE_lambdef_nocond)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.Match(Python3ParserLAMBDA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4683779897422774272) != 0 {
		{
			p.SetState(1106)
			p.Varargslist()
		}

	}
	{
		p.SetState(1109)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1110)
		p.Test_nocond()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_test() []IAnd_testContext
	And_test(i int) IAnd_testContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
	return p
}

func InitEmptyOr_testContext(p *Or_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_testContext); ok {
			len++
		}
	}

	tst := make([]IAnd_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_testContext); ok {
			tst[i] = t.(IAnd_testContext)
			i++
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR)
}

func (s *Or_testContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR, i)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitOr_test(s)
	}
}

func (p *Python3Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Python3ParserRULE_or_test)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1112)
		p.And_test()
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR {
		{
			p.SetState(1113)
			p.Match(Python3ParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1114)
			p.And_test()
		}

		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNot_test() []INot_testContext
	Not_test(i int) INot_testContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
	return p
}

func InitEmptyAnd_testContext(p *And_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INot_testContext); ok {
			len++
		}
	}

	tst := make([]INot_testContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INot_testContext); ok {
			tst[i] = t.(INot_testContext)
			i++
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_testContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND)
}

func (s *And_testContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND, i)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnd_test(s)
	}
}

func (p *Python3Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Python3ParserRULE_and_test)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Not_test()
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND {
		{
			p.SetState(1121)
			p.Match(Python3ParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Not_test()
		}

		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	Not_test() INot_testContext
	Comparison() IComparisonContext

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
	return p
}

func InitEmptyNot_testContext(p *Not_testContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Not_testContext) Not_test() INot_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitNot_test(s)
	}
}

func (p *Python3Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Python3ParserRULE_not_test)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1128)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1129)
			p.Not_test()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			p.Comparison()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComp_op() []IComp_opContext
	Comp_op(i int) IComp_opContext

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
	return p
}

func InitEmptyComparisonContext(p *ComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComp_opContext); ok {
			len++
		}
	}

	tst := make([]IComp_opContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComp_opContext); ok {
			tst[i] = t.(IComp_opContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_opContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *Python3Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Python3ParserRULE_comparison)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.Expr()
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1134)
				p.Comp_op()
			}
			{
				p.SetState(1135)
				p.Expr()
			}

		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS_THAN() antlr.TerminalNode
	GREATER_THAN() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	GT_EQ() antlr.TerminalNode
	LT_EQ() antlr.TerminalNode
	NOT_EQ_1() antlr.TerminalNode
	NOT_EQ_2() antlr.TerminalNode
	IN() antlr.TerminalNode
	NOT() antlr.TerminalNode
	IS() antlr.TerminalNode

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
	return p
}

func InitEmptyComp_opContext(p *Comp_opContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_opContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserLESS_THAN, 0)
}

func (s *Comp_opContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(Python3ParserGREATER_THAN, 0)
}

func (s *Comp_opContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(Python3ParserEQUALS, 0)
}

func (s *Comp_opContext) GT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserGT_EQ, 0)
}

func (s *Comp_opContext) LT_EQ() antlr.TerminalNode {
	return s.GetToken(Python3ParserLT_EQ, 0)
}

func (s *Comp_opContext) NOT_EQ_1() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_1, 0)
}

func (s *Comp_opContext) NOT_EQ_2() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_EQ_2, 0)
}

func (s *Comp_opContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Comp_opContext) IS() antlr.TerminalNode {
	return s.GetToken(Python3ParserIS, 0)
}

func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_op(s)
	}
}

func (p *Python3Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Python3ParserRULE_comp_op)
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1142)
			p.Match(Python3ParserLESS_THAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1143)
			p.Match(Python3ParserGREATER_THAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1144)
			p.Match(Python3ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1145)
			p.Match(Python3ParserGT_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1146)
			p.Match(Python3ParserLT_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1147)
			p.Match(Python3ParserNOT_EQ_1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1148)
			p.Match(Python3ParserNOT_EQ_2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1149)
			p.Match(Python3ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1150)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.Match(Python3ParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1152)
			p.Match(Python3ParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1153)
			p.Match(Python3ParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1154)
			p.Match(Python3ParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	Expr() IExprContext

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
	return p
}

func InitEmptyStar_exprContext(p *Star_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *Star_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (p *Python3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Python3ParserRULE_star_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Match(Python3ParserSTAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1158)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllXor_expr() []IXor_exprContext
	Xor_expr(i int) IXor_exprContext
	AllOR_OP() []antlr.TerminalNode
	OR_OP(i int) antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXor_exprContext); ok {
			len++
		}
	}

	tst := make([]IXor_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXor_exprContext); ok {
			tst[i] = t.(IXor_exprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) AllOR_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR_OP)
}

func (s *ExprContext) OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR_OP, i)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *Python3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Python3ParserRULE_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Xor_expr()
	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR_OP {
		{
			p.SetState(1161)
			p.Match(Python3ParserOR_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			p.Xor_expr()
		}

		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnd_expr() []IAnd_exprContext
	And_expr(i int) IAnd_exprContext
	AllXOR() []antlr.TerminalNode
	XOR(i int) antlr.TerminalNode

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
	return p
}

func InitEmptyXor_exprContext(p *Xor_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnd_exprContext); ok {
			len++
		}
	}

	tst := make([]IAnd_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnd_exprContext); ok {
			tst[i] = t.(IAnd_exprContext)
			i++
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserXOR)
}

func (s *Xor_exprContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserXOR, i)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (p *Python3Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Python3ParserRULE_xor_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1168)
		p.And_expr()
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserXOR {
		{
			p.SetState(1169)
			p.Match(Python3ParserXOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1170)
			p.And_expr()
		}

		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllShift_expr() []IShift_exprContext
	Shift_expr(i int) IShift_exprContext
	AllAND_OP() []antlr.TerminalNode
	AND_OP(i int) antlr.TerminalNode

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
	return p
}

func InitEmptyAnd_exprContext(p *And_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShift_exprContext); ok {
			len++
		}
	}

	tst := make([]IShift_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShift_exprContext); ok {
			tst[i] = t.(IShift_exprContext)
			i++
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) AllAND_OP() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND_OP)
}

func (s *And_exprContext) AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND_OP, i)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (p *Python3Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Python3ParserRULE_and_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Shift_expr()
	}
	p.SetState(1181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND_OP {
		{
			p.SetState(1177)
			p.Match(Python3ParserAND_OP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1178)
			p.Shift_expr()
		}

		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArith_expr() []IArith_exprContext
	Arith_expr(i int) IArith_exprContext
	AllLEFT_SHIFT() []antlr.TerminalNode
	LEFT_SHIFT(i int) antlr.TerminalNode
	AllRIGHT_SHIFT() []antlr.TerminalNode
	RIGHT_SHIFT(i int) antlr.TerminalNode

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
	return p
}

func InitEmptyShift_exprContext(p *Shift_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArith_exprContext); ok {
			len++
		}
	}

	tst := make([]IArith_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArith_exprContext); ok {
			tst[i] = t.(IArith_exprContext)
			i++
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArith_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) AllLEFT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserLEFT_SHIFT)
}

func (s *Shift_exprContext) LEFT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserLEFT_SHIFT, i)
}

func (s *Shift_exprContext) AllRIGHT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserRIGHT_SHIFT)
}

func (s *Shift_exprContext) RIGHT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserRIGHT_SHIFT, i)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (p *Python3Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Python3ParserRULE_shift_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.Arith_expr()
	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT {
		{
			p.SetState(1185)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1186)
			p.Arith_expr()
		}

		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTerm() []ITermContext
	Term(i int) ITermContext
	AllADD() []antlr.TerminalNode
	ADD(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
	return p
}

func InitEmptyArith_exprContext(p *Arith_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserADD)
}

func (s *Arith_exprContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, i)
}

func (s *Arith_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMINUS)
}

func (s *Arith_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, i)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArith_expr(s)
	}
}

func (p *Python3Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Python3ParserRULE_arith_expr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.Term()
	}
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1193)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Python3ParserADD || _la == Python3ParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1194)
				p.Term()
			}

		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFactor() []IFactorContext
	Factor(i int) IFactorContext
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllDIV() []antlr.TerminalNode
	DIV(i int) antlr.TerminalNode
	AllMOD() []antlr.TerminalNode
	MOD(i int) antlr.TerminalNode
	AllIDIV() []antlr.TerminalNode
	IDIV(i int) antlr.TerminalNode

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFactorContext); ok {
			len++
		}
	}

	tst := make([]IFactorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFactorContext); ok {
			tst[i] = t.(IFactorContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTAR)
}

func (s *TermContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, i)
}

func (s *TermContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAT)
}

func (s *TermContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAT, i)
}

func (s *TermContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserDIV)
}

func (s *TermContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserDIV, i)
}

func (s *TermContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserMOD)
}

func (s *TermContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserMOD, i)
}

func (s *TermContext) AllIDIV() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserIDIV)
}

func (s *TermContext) IDIV(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserIDIV, i)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *Python3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Python3ParserRULE_term)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.Factor()
	}
	p.SetState(1205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1201)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-56)) & ^0x3f) == 0 && ((int64(1)<<(_la-56))&1074659329) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1202)
				p.Factor()
			}

		}
		p.SetState(1207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	ADD() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT_OP() antlr.TerminalNode
	Power() IPowerContext

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) ADD() antlr.TerminalNode {
	return s.GetToken(Python3ParserADD, 0)
}

func (s *FactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(Python3ParserMINUS, 0)
}

func (s *FactorContext) NOT_OP() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT_OP, 0)
}

func (s *FactorContext) Power() IPowerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (p *Python3Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Python3ParserRULE_factor)
	var _la int

	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1208)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&35) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1209)
			p.Factor()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1210)
			p.Power()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom_expr() IAtom_exprContext
	POWER() antlr.TerminalNode
	Factor() IFactorContext

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_power
	return p
}

func InitEmptyPowerContext(p *PowerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_power
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom_expr() IAtom_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtom_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtom_exprContext)
}

func (s *PowerContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *PowerContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *Python3Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Python3ParserRULE_power)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Atom_expr()
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserPOWER {
		{
			p.SetState(1214)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1215)
			p.Factor()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtom_exprContext is an interface to support dynamic dispatch.
type IAtom_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom() IAtomContext
	AWAIT() antlr.TerminalNode
	AllTrailer() []ITrailerContext
	Trailer(i int) ITrailerContext

	// IsAtom_exprContext differentiates from other interfaces.
	IsAtom_exprContext()
}

type Atom_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_exprContext() *Atom_exprContext {
	var p = new(Atom_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom_expr
	return p
}

func InitEmptyAtom_exprContext(p *Atom_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom_expr
}

func (*Atom_exprContext) IsAtom_exprContext() {}

func NewAtom_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_exprContext {
	var p = new(Atom_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom_expr

	return p
}

func (s *Atom_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_exprContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Atom_exprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(Python3ParserAWAIT, 0)
}

func (s *Atom_exprContext) AllTrailer() []ITrailerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITrailerContext); ok {
			len++
		}
	}

	tst := make([]ITrailerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITrailerContext); ok {
			tst[i] = t.(ITrailerContext)
			i++
		}
	}

	return tst
}

func (s *Atom_exprContext) Trailer(i int) ITrailerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *Atom_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAtom_expr(s)
	}
}

func (s *Atom_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAtom_expr(s)
	}
}

func (p *Python3Parser) Atom_expr() (localctx IAtom_exprContext) {
	localctx = NewAtom_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Python3ParserRULE_atom_expr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAWAIT {
		{
			p.SetState(1218)
			p.Match(Python3ParserAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1221)
		p.Atom()
	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1222)
				p.Trailer()
			}

		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Yield_expr() IYield_exprContext
	Testlist_comp() ITestlist_compContext
	OPEN_BRACK() antlr.TerminalNode
	CLOSE_BRACK() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	Dictorsetmaker() IDictorsetmakerContext
	Name() INameContext
	NUMBER() antlr.TerminalNode
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	ELLIPSIS() antlr.TerminalNode
	NONE() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *AtomContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlist_compContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *AtomContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *AtomContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACE, 0)
}

func (s *AtomContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACE, 0)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictorsetmakerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AtomContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserNUMBER, 0)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING, i)
}

func (s *AtomContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Python3ParserELLIPSIS, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *AtomContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *AtomContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *Python3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Python3ParserRULE_atom)
	var _la int

	var _alt int

	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1228)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(1229)
				p.Yield_expr()
			}

		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(1230)
				p.Testlist_comp()
			}

		case Python3ParserCLOSE_PAREN:

		default:
		}
		{
			p.SetState(1233)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1234)
			p.Match(Python3ParserOPEN_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&252238150243451928) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1235)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(1238)
			p.Match(Python3ParserCLOSE_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1239)
			p.Match(Python3ParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4863924168670839832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1240)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(1243)
			p.Match(Python3ParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserMATCH, Python3ParserUNDERSCORE, Python3ParserNAME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1244)
			p.Name()
		}

	case Python3ParserNUMBER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1245)
			p.Match(Python3ParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserSTRING:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1246)
					p.Match(Python3ParserSTRING)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1249)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case Python3ParserELLIPSIS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1251)
			p.Match(Python3ParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserNONE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1252)
			p.Match(Python3ParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserTRUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1253)
			p.Match(Python3ParserTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserFALSE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1254)
			p.Match(Python3ParserFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	UNDERSCORE() antlr.TerminalNode
	MATCH() antlr.TerminalNode

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *NameContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(Python3ParserUNDERSCORE, 0)
}

func (s *NameContext) MATCH() antlr.TerminalNode {
	return s.GetToken(Python3ParserMATCH, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *Python3Parser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Python3ParserRULE_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1257)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&36284957458432) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	Comp_for() IComp_forContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
	return p
}

func InitEmptyTestlist_compContext(p *Testlist_compContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *Testlist_compContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *Testlist_compContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (p *Python3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Python3ParserRULE_testlist_comp)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(1259)
			p.Test()
		}

	case Python3ParserSTAR:
		{
			p.SetState(1260)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserASYNC, Python3ParserFOR:
		{
			p.SetState(1263)
			p.Comp_for()
		}

	case Python3ParserCLOSE_PAREN, Python3ParserCOMMA, Python3ParserCLOSE_BRACK:
		p.SetState(1271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1264)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1267)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
					{
						p.SetState(1265)
						p.Test()
					}

				case Python3ParserSTAR:
					{
						p.SetState(1266)
						p.Star_expr()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(1273)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1274)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext
	OPEN_BRACK() antlr.TerminalNode
	Subscriptlist() ISubscriptlistContext
	CLOSE_BRACK() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Name() INameContext

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
	return p
}

func InitEmptyTrailerContext(p *TrailerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *TrailerContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *TrailerContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) OPEN_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_BRACK, 0)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscriptlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) CLOSE_BRACK() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_BRACK, 0)
}

func (s *TrailerContext) DOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDOT, 0)
}

func (s *TrailerContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (p *Python3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Python3ParserRULE_trailer)
	var _la int

	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1279)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4863924168670839832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1280)
				p.Arglist()
			}

		}
		{
			p.SetState(1283)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1284)
			p.Match(Python3ParserOPEN_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.Subscriptlist()
		}
		{
			p.SetState(1286)
			p.Match(Python3ParserCLOSE_BRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Python3ParserDOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1288)
			p.Match(Python3ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.Name()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubscript_() []ISubscript_Context
	Subscript_(i int) ISubscript_Context
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
	return p
}

func InitEmptySubscriptlistContext(p *SubscriptlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript_() []ISubscript_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubscript_Context); ok {
			len++
		}
	}

	tst := make([]ISubscript_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubscript_Context); ok {
			tst[i] = t.(ISubscript_Context)
			i++
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript_(i int) ISubscript_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscript_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscript_Context)
}

func (s *SubscriptlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *SubscriptlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (p *Python3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Python3ParserRULE_subscriptlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Subscript_()
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1293)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1294)
				p.Subscript_()
			}

		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(1300)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubscript_Context is an interface to support dynamic dispatch.
type ISubscript_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	COLON() antlr.TerminalNode
	Sliceop() ISliceopContext

	// IsSubscript_Context differentiates from other interfaces.
	IsSubscript_Context()
}

type Subscript_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscript_Context() *Subscript_Context {
	var p = new(Subscript_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript_
	return p
}

func InitEmptySubscript_Context(p *Subscript_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript_
}

func (*Subscript_Context) IsSubscript_Context() {}

func NewSubscript_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subscript_Context {
	var p = new(Subscript_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscript_

	return p
}

func (s *Subscript_Context) GetParser() antlr.Parser { return s.parser }

func (s *Subscript_Context) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *Subscript_Context) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Subscript_Context) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *Subscript_Context) Sliceop() ISliceopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISliceopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *Subscript_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subscript_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subscript_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSubscript_(s)
	}
}

func (s *Subscript_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSubscript_(s)
	}
}

func (p *Python3Parser) Subscript_() (localctx ISubscript_Context) {
	localctx = NewSubscript_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Python3ParserRULE_subscript_)
	var _la int

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1303)
			p.Test()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1304)
				p.Test()
			}

		}
		{
			p.SetState(1307)
			p.Match(Python3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1308)
				p.Test()
			}

		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOLON {
			{
				p.SetState(1311)
				p.Sliceop()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Test() ITestContext

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
	return p
}

func InitEmptySliceopContext(p *SliceopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *SliceopContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (p *Python3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Python3ParserRULE_sliceop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556205523992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(1317)
			p.Test()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
	return p
}

func InitEmptyExprlistContext(p *ExprlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *ExprlistContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (p *Python3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Python3ParserRULE_exprlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		{
			p.SetState(1320)
			p.Expr()
		}

	case Python3ParserSTAR:
		{
			p.SetState(1321)
			p.Star_expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1324)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserMATCH, Python3ParserNONE, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(1325)
					p.Expr()
				}

			case Python3ParserSTAR:
				{
					p.SetState(1326)
					p.Star_expr()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(1334)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
	return p
}

func InitEmptyTestlistContext(p *TestlistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *TestlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (p *Python3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Python3ParserRULE_testlist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.Test()
	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1338)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1339)
				p.Test()
			}

		}
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(1345)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllPOWER() []antlr.TerminalNode
	POWER(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Comp_for() IComp_forContext
	AllStar_expr() []IStar_exprContext
	Star_expr(i int) IStar_exprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
	return p
}

func InitEmptyDictorsetmakerContext(p *DictorsetmakerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOLON)
}

func (s *DictorsetmakerContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, i)
}

func (s *DictorsetmakerContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserPOWER)
}

func (s *DictorsetmakerContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, i)
}

func (s *DictorsetmakerContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) AllStar_expr() []IStar_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStar_exprContext); ok {
			len++
		}
	}

	tst := make([]IStar_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStar_exprContext); ok {
			tst[i] = t.(IStar_exprContext)
			i++
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Star_expr(i int) IStar_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStar_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *DictorsetmakerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *DictorsetmakerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (p *Python3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Python3ParserRULE_dictorsetmaker)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(1348)
				p.Test()
			}
			{
				p.SetState(1349)
				p.Match(Python3ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1350)
				p.Test()
			}

		case Python3ParserPOWER:
			{
				p.SetState(1352)
				p.Match(Python3ParserPOWER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1353)
				p.Expr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserASYNC, Python3ParserFOR:
			{
				p.SetState(1356)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1368)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1357)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1364)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(1358)
							p.Test()
						}
						{
							p.SetState(1359)
							p.Match(Python3ParserCOLON)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1360)
							p.Test()
						}

					case Python3ParserPOWER:
						{
							p.SetState(1362)
							p.Match(Python3ParserPOWER)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1363)
							p.Expr()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(1370)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(1371)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(1376)
				p.Test()
			}

		case Python3ParserSTAR:
			{
				p.SetState(1377)
				p.Star_expr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Python3ParserASYNC, Python3ParserFOR:
			{
				p.SetState(1380)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(1388)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1381)
						p.Match(Python3ParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1384)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}

					switch p.GetTokenStream().LA(1) {
					case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
						{
							p.SetState(1382)
							p.Test()
						}

					case Python3ParserSTAR:
						{
							p.SetState(1383)
							p.Star_expr()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

				}
				p.SetState(1390)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1392)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(1391)
					p.Match(Python3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Name() INameContext
	COLON() antlr.TerminalNode
	Block() IBlockContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Arglist() IArglistContext

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
	return p
}

func InitEmptyClassdefContext(p *ClassdefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLASS, 0)
}

func (s *ClassdefContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ClassdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(Python3ParserCOLON, 0)
}

func (s *ClassdefContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserOPEN_PAREN, 0)
}

func (s *ClassdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLOSE_PAREN, 0)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArglistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (p *Python3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Python3ParserRULE_classdef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Match(Python3ParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1399)
		p.Name()
	}
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(1400)
			p.Match(Python3ParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4863924168670839832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
			{
				p.SetState(1401)
				p.Arglist()
			}

		}
		{
			p.SetState(1404)
			p.Match(Python3ParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1407)
		p.Match(Python3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1408)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
	return p
}

func InitEmptyArglistContext(p *ArglistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserCOMMA)
}

func (s *ArglistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserCOMMA, i)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArglist(s)
	}
}

func (p *Python3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Python3ParserRULE_arglist)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1410)
		p.Argument()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1411)
				p.Match(Python3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1412)
				p.Argument()
			}

		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(1418)
			p.Match(Python3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTest() []ITestContext
	Test(i int) ITestContext
	ASSIGN() antlr.TerminalNode
	POWER() antlr.TerminalNode
	STAR() antlr.TerminalNode
	Comp_for() IComp_forContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITestContext); ok {
			len++
		}
	}

	tst := make([]ITestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITestContext); ok {
			tst[i] = t.(ITestContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSIGN, 0)
}

func (s *ArgumentContext) POWER() antlr.TerminalNode {
	return s.GetToken(Python3ParserPOWER, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTAR, 0)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *Python3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Python3ParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1421)
			p.Test()
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASYNC || _la == Python3ParserFOR {
			{
				p.SetState(1422)
				p.Comp_for()
			}

		}

	case 2:
		{
			p.SetState(1425)
			p.Test()
		}
		{
			p.SetState(1426)
			p.Match(Python3ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.Test()
		}

	case 3:
		{
			p.SetState(1429)
			p.Match(Python3ParserPOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1430)
			p.Test()
		}

	case 4:
		{
			p.SetState(1431)
			p.Match(Python3ParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)
			p.Test()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comp_for() IComp_forContext
	Comp_if() IComp_ifContext

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
	return p
}

func InitEmptyComp_iterContext(p *Comp_iterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_ifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (p *Python3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Python3ParserRULE_comp_iter)
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserASYNC, Python3ParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1435)
			p.Comp_for()
		}

	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1436)
			p.Comp_if()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Exprlist() IExprlistContext
	IN() antlr.TerminalNode
	Or_test() IOr_testContext
	ASYNC() antlr.TerminalNode
	Comp_iter() IComp_iterContext

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
	return p
}

func InitEmptyComp_forContext(p *Comp_forContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_testContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(Python3ParserASYNC, 0)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (p *Python3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Python3ParserRULE_comp_for)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserASYNC {
		{
			p.SetState(1439)
			p.Match(Python3ParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1442)
		p.Match(Python3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1443)
		p.Exprlist()
	}
	{
		p.SetState(1444)
		p.Match(Python3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1445)
		p.Or_test()
	}
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&37749248) != 0 {
		{
			p.SetState(1446)
			p.Comp_iter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Test_nocond() ITest_nocondContext
	Comp_iter() IComp_iterContext

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
	return p
}

func InitEmptyComp_ifContext(p *Comp_ifContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *Comp_ifContext) Test_nocond() ITest_nocondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITest_nocondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComp_iterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitComp_if(s)
	}
}

func (p *Python3Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Python3ParserRULE_comp_if)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Match(Python3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1450)
		p.Test_nocond()
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&37749248) != 0 {
		{
			p.SetState(1451)
			p.Comp_iter()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEncoding_declContext is an interface to support dynamic dispatch.
type IEncoding_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name() INameContext

	// IsEncoding_declContext differentiates from other interfaces.
	IsEncoding_declContext()
}

type Encoding_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoding_declContext() *Encoding_declContext {
	var p = new(Encoding_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_encoding_decl
	return p
}

func InitEmptyEncoding_declContext(p *Encoding_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_encoding_decl
}

func (*Encoding_declContext) IsEncoding_declContext() {}

func NewEncoding_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoding_declContext {
	var p = new(Encoding_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_encoding_decl

	return p
}

func (s *Encoding_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoding_declContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Encoding_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoding_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Encoding_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterEncoding_decl(s)
	}
}

func (s *Encoding_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitEncoding_decl(s)
	}
}

func (p *Python3Parser) Encoding_decl() (localctx IEncoding_declContext) {
	localctx = NewEncoding_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Python3ParserRULE_encoding_decl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Yield_arg() IYield_argContext

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
	return p
}

func InitEmptyYield_exprContext(p *Yield_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Python3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYield_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (p *Python3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Python3ParserRULE_yield_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1456)
		p.Match(Python3ParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&180180556213912600) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&12673) != 0) {
		{
			p.SetState(1457)
			p.Yield_arg()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Test() ITestContext
	Testlist() ITestlistContext

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
	return p
}

func InitEmptyYield_argContext(p *Yield_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITestlistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (p *Python3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Python3ParserRULE_yield_arg)
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1460)
			p.Match(Python3ParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.Test()
		}

	case Python3ParserSTRING, Python3ParserNUMBER, Python3ParserAWAIT, Python3ParserFALSE, Python3ParserLAMBDA, Python3ParserMATCH, Python3ParserNONE, Python3ParserNOT, Python3ParserTRUE, Python3ParserUNDERSCORE, Python3ParserNAME, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1462)
			p.Testlist()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringsContext is an interface to support dynamic dispatch.
type IStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsStringsContext differentiates from other interfaces.
	IsStringsContext()
}

type StringsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringsContext() *StringsContext {
	var p = new(StringsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_strings
	return p
}

func InitEmptyStringsContext(p *StringsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Python3ParserRULE_strings
}

func (*StringsContext) IsStringsContext() {}

func NewStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringsContext {
	var p = new(StringsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_strings

	return p
}

func (s *StringsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringsContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserSTRING)
}

func (s *StringsContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING, i)
}

func (s *StringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.EnterStrings(s)
	}
}

func (s *StringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3ParserListener); ok {
		listenerT.ExitStrings(s)
	}
}

func (p *Python3Parser) Strings() (localctx IStringsContext) {
	localctx = NewStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Python3ParserRULE_strings)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Python3ParserSTRING {
		{
			p.SetState(1465)
			p.Match(Python3ParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Python3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 60:
		var t *Literal_patternContext = nil
		if localctx != nil {
			t = localctx.(*Literal_patternContext)
		}
		return p.Literal_pattern_Sempred(t, predIndex)

	case 61:
		var t *Literal_exprContext = nil
		if localctx != nil {
			t = localctx.(*Literal_exprContext)
		}
		return p.Literal_expr_Sempred(t, predIndex)

	case 68:
		var t *Pattern_capture_targetContext = nil
		if localctx != nil {
			t = localctx.(*Pattern_capture_targetContext)
		}
		return p.Pattern_capture_target_Sempred(t, predIndex)

	case 70:
		var t *Value_patternContext = nil
		if localctx != nil {
			t = localctx.(*Value_patternContext)
		}
		return p.Value_pattern_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Python3Parser) Literal_pattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.CannotBePlusMinus()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Literal_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.CannotBePlusMinus()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Pattern_capture_target_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.CannotBeDotLpEq()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Python3Parser) Value_pattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.CannotBeDotLpEq()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
